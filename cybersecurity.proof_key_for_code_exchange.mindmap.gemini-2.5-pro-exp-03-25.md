# Proof Key for Code Exchange (PKCE - RFC 7636) #PKCE #OAuth #Security
Defines an extension to the OAuth 2.0 Authorization Code flow to mitigate authorization code interception attacks. Specified in RFC 7636.

## Introduction and Motivation #Overview #ProblemStatement #Security
Context and the problem PKCE solves.

### The OAuth 2.0 Authorization Code Flow #OAuth2 #AuthorizationCode #Background
Brief overview of the standard flow PKCE extends.
#### Roles (Client, Resource Owner, Authorization Server, Resource Server) #OAuthRoles
#### Standard Authorization Code Grant Steps #OAuthFlow

### The Authorization Code Interception Attack #ThreatModel #Vulnerability #PublicClients
Describes the specific attack vector PKCE addresses, particularly for public clients.
#### Public vs. Confidential Clients #ClientTypes #SecurityContext
#### Attack Scenario on Public Clients #AttackVector #MobileApps #SPA
How a malicious app can intercept the authorization code.
#### Why Traditional Client Secrets Don't Work for Public Clients #ClientAuthentication #Limitations

### PKCE as a Solution #Solution #Mitigation #CoreConcept
Introducing PKCE as the mechanism to prevent the interception attack.

## Core PKCE Protocol Flow #Protocol #Sequence #Mechanism
Detailed steps involved in the PKCE-enhanced Authorization Code flow.

### Step 1: Client Creates Code Verifier #ClientSide #Cryptography #Secret
The client generates a high-entropy cryptographic random string.
#### `code_verifier` Generation Requirements #Randomness #Entropy #Specification

### Step 2: Client Creates Code Challenge #ClientSide #Transformation #Hashing
The client derives the code challenge from the code verifier.
#### `code_challenge_method` #Parameter #Algorithm
##### `plain` Method (Not Recommended) #Discouraged #Compatibility
##### `S256` Method (Recommended) #SHA256 #Hashing #Security
Calculation: BASE64URL-ENCODE(SHA256(ASCII(code_verifier)))
#### Selecting the Transformation Method #SecurityPolicy #ImplementationChoice

### Step 3: Client Initiates Authorization Request #AuthorizationRequest #ClientSide #Parameters
The client directs the user agent to the authorization endpoint, including PKCE parameters.
#### Adding `code_challenge` to the Request #Parameter #RequestSyntax
#### Adding `code_challenge_method` to the Request #Parameter #RequestSyntax
#### Example Authorization Request URL #Example #Syntax

### Step 4: Authorization Server Receives Request #ServerSide #Processing #Storage
The server processes the request, noting the PKCE parameters.
#### Storing `code_challenge` and `code_challenge_method` #StateManagement #Association
Association with the authorization code being generated.

### Step 5: Authorization Server Issues Authorization Code #AuthorizationResponse #ServerSide #Redirect
Standard authorization code issuance, after user consent.

### Step 6: Client Receives Authorization Code #ClientSide #RedirectHandling #CodeReceipt
The client receives the code via redirection.

### Step 7: Client Requests Access Token #TokenRequest #ClientSide #Verification
The client sends the authorization code and the *original* code verifier to the token endpoint.
#### Adding `code_verifier` to the Token Request #Parameter #RequestSyntax
#### Example Token Request #Example #Syntax

### Step 8: Authorization Server Validates and Issues Tokens #TokenResponse #ServerSide #Validation
The server verifies the code verifier against the stored challenge and issues tokens.
#### Retrieving Stored `code_challenge` and `code_challenge_method` #StateManagement #Lookup
#### Performing the Code Verification #Cryptography #Comparison
##### Verification for `plain` #DirectComparison
##### Verification for `S256` #Hashing #Comparison
Calculation: BASE64URL-ENCODE(SHA256(ASCII(received_code_verifier))) == stored_code_challenge
#### Token Issuance on Success #AccessGrant #Tokens
#### Error Handling on Failure #ErrorResponse #SecurityFailure

## Key Parameters and Transformations #Parameters #Definitions #Cryptography
Detailed definition of the core PKCE components.

### `code_verifier` #Secret #Randomness #ClientGenerated
The high-entropy secret generated by the client for each authorization request.
#### Syntax and Character Set (ABNF) #RFC7636 #Specification
#### Entropy Requirements #Security #BestPractice
Minimum length of 43 octets, maximum of 128 octets recommended.

### `code_challenge` #DerivedValue #Hashing #AuthorizationRequest
The value derived from the `code_verifier` sent in the authorization request.
#### Syntax and Character Set (ABNF) #RFC7636 #Specification

### `code_challenge_method` #Algorithm #Transformation #Parameter
Indicates the transformation method used to derive the `code_challenge`.
#### `plain` #Compatibility #Legacy
Value: "plain". Discouraged due to exposure of verifier.
#### `S256` #Hashing #SHA256 #Recommended
Value: "S256". Preferred method.
#### Default Method Handling #Specification #ServerBehavior
If omitted, the server assumes "plain" (though S256 is strongly recommended).

### Base64url Encoding #Encoding #DataFormat #RFC4648
The specific Base64 variant used for PKCE parameters.

## Security Considerations #Security #ThreatMitigation #Analysis
Analysis of how PKCE enhances security and potential residual risks.

### Mitigation of Authorization Code Interception #PrimaryGoal #AttackPrevention
How PKCE prevents the main attack by requiring the verifier at the token endpoint.

### Prevention of Code Injection #AttackVector #SecurityBenefit
How requiring the `code_verifier` prevents attackers from injecting stolen codes.

### Replay Attack Prevention #SecurityBenefit #StateManagement
The one-time nature of the code verifier / code challenge pair for each flow.

### Cryptographic Strength (`S256` vs `plain`) #Hashing #SecurityLevel #Recommendation
Why S256 is significantly more secure than plain.

### `code_verifier` Entropy #Randomness #SecurityRequirement
Importance of sufficient randomness to prevent guessing.

### Transport Layer Security (TLS) #HTTPS #Prerequisite #Encryption
PKCE does not replace the need for TLS. It protects against threats *within* the TLS assumptions (e.g., malicious apps on the same device).

### Cross-Site Request Forgery (CSRF) Protection #CSRF #StateParameter #OrthogonalConcern
PKCE does not mitigate CSRF; the `state` parameter in OAuth 2.0 should still be used.

### Client Impersonation #Limitations #SecurityContext
PKCE does not prevent a malicious client *masquerading* as a legitimate client if the legitimate client's details are compromised (different threat model).

## Implementation Aspects #Implementation #ClientSide #ServerSide
Guidance for developers implementing PKCE.

### Client Implementation #PublicClients #MobileApps #SPA
Responsibilities of the client application.
#### Generating `code_verifier` #LibrarySupport #Cryptography
#### Storing `code_verifier` Securely #Storage #Security
Temporary storage between authorization request and token request.
#### Handling Redirects #URLParsing #CodeExtraction
#### Constructing Authorization and Token Requests #APIUsage #ParameterEncoding

### Authorization Server Implementation #OAuthServer #IdentityProvider #Validation
Responsibilities of the authorization server.
#### Advertising PKCE Support #Discovery #Metadata
Using OAuth 2.0 Authorization Server Metadata (RFC 8414).
#### Processing PKCE Parameters in Authorization Request #Parsing #Validation
#### Storing PKCE Parameters #Database #Session #StateManagement
Associating `code_challenge` and `method` with the authorization code.
#### Verifying `code_verifier` at Token Endpoint #Logic #Comparison #SecurityCheck
#### Handling Missing or Invalid Parameters #ErrorHandling #RFCCompliance

## Relationship with OAuth 2.0 #OAuth2 #Standard #Extension
How PKCE fits into the broader OAuth 2.0 ecosystem.

### An Extension to the Authorization Code Grant #AuthorizationCode #Enhancement
PKCE modifies/extends the standard Authorization Code flow.
### Not Applicable to Other Grants (Implicit, Client Credentials, ROPC) #GrantTypes #Scope
PKCE is specifically designed for the code flow. Implicit grant has different vulnerabilities.
### Interaction with `state` Parameter #CSRF #Complementary
PKCE and `state` provide orthogonal security benefits. Both should be used.
### OAuth 2.0 Security Best Current Practice (BCP 212) #BCP212 #NativeApps #Recommendation
Strongly recommends PKCE for native applications.
### OAuth 2.1 #OAuth21 #FutureStandard #Mandatory
Draft specification mandates PKCE for the authorization code flow.

## Applicability and Use Cases #Applications #ClientTypes #Scenarios
Where PKCE is most relevant and commonly used.

### Native Mobile Applications #MobileApps #iOS #Android
Primary use case due to custom URL scheme redirects and potential for app interception.
### Single-Page Applications (SPAs) #SPA #JavaScript #WebApps
Browsers lack mechanisms to guarantee delivery to the correct SPA; PKCE protects code leakage.
### Other Public Clients #DesktopApps #IoT #PublicClients
Any client unable to securely store a client secret benefits from PKCE.
### Confidential Clients #ConfidentialClients #ServerSideApps #OptionalBenefit
PKCE can provide additional defense-in-depth even for confidential clients.

## RFC 7636 Specification Details #RFC #Standard #Documentation
Key sections and aspects of the formal specification.

### Abstract and Introduction #RFCStructure #Overview
### Terminology #Definitions #RFCStructure
### Protocol Flow Description #Sequence #Diagrams #RFCStructure
### Parameter Definitions #Syntax #ABNF #RFCStructure
### Security Considerations Section #ThreatAnalysis #RFCStructure
### IANA Considerations #Registry #RFCStructure
(`code_challenge_method` registry)

## Comparison with Alternatives #Comparison #OAuthGrants #SecurityPatterns

### PKCE vs. Implicit Grant #ImplicitGrant #SecurityIssues
Implicit grant exposes tokens directly in the redirect URI, generally discouraged. PKCE + Auth Code is preferred.
### PKCE vs. Client Secrets for Public Clients #ClientSecrets #Insecurity
Why embedding secrets in public clients is insecure.
### PKCE vs. Nonce (OpenID Connect) #Nonce #OIDC #DifferentPurpose
Nonce in OIDC prevents ID Token replay, different purpose than PKCE.
### PKCE vs. Custom URI Schemes #URIschemes #SecurityFlaws
Reliance solely on URI scheme uniqueness is insufficient protection.

## Benefits and Considerations #Advantages #Tradeoffs #Evaluation

### Benefits #SecurityEnhancement #Standardization #WideAdoption
*   Mitigates code interception.
*   Industry standard, widely supported.
*   Required by modern security best practices (BCP 212, OAuth 2.1).
*   Relatively simple to implement on top of standard Auth Code flow.
### Considerations #Complexity #StateManagement #Compatibility
*   Adds slight complexity to the client and server implementation.
*   Requires server-side storage of challenge/method per authorization code.
*   Older authorization servers might not support it (though rare now).

## Related Standards and Evolution #BCP212 #OAuth21 #Future #Ecosystem

### OAuth 2.0 Security Best Current Practice (BCP 212) #Recommendation #NativeApps
Mandates PKCE for native apps using the authorization code grant.
### OAuth 2.1 Draft #FutureStandard #Consolidation
Incorporates PKCE as a required component of the authorization code grant, deprecating implicit grant.
### OpenID Connect (OIDC) #OIDC #Authentication #Integration
PKCE is used within OIDC flows when the underlying OAuth 2.0 flow is Authorization Code.
### FAPI (Financial-grade API) #FAPI #HighSecurity #Requirement
Often requires PKCE as part of stricter security profiles.
