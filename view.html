<!DOCTYPE html>
<html lang="en" class=""> <!-- Start with no 'dark' class -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive eBook</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>

    <script>
      // Configure Tailwind CSS
      tailwind.config = {
        darkMode: 'class', // Enable class-based dark mode
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
            },
          },
        },
      };
    </script>
    <style>
      /* Basic body styling */
      body {
        font-family: "Inter", sans-serif;
      }
      /* --- Light Mode Colors (Defaults) --- */
      hr { border-color: #e5e7eb; /* gray-200 */ }
      ul { margin-bottom: 0.5rem; }
      ul li { margin-bottom: 0.5rem; list-style: disc; list-style-position: inside; }
      #output p, #renderedContentDisplay p { color: #1f2937; /* gray-800 */ }
      .content-textarea { background-color: #ffffff; color: #1f2937; border-color: #d1d5db; /* gray-300 */ }
      .content-textarea:focus { border-color: #4f46e5; /* indigo-600 */ box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); }
      #output h1, #renderedContentDisplay h1, #output h2, #renderedContentDisplay h2, #output h3, #renderedContentDisplay h3, #output h4, #renderedContentDisplay h4, #output h5, #renderedContentDisplay h5, #output h6, #renderedContentDisplay h6 { color: #111827; /* gray-900 */ }
      #output h1, #renderedContentDisplay h1 { color: rgb(20 184 166); /* teal-500 */ }
      #output h2, #renderedContentDisplay h2 { color: rgb(234 88 12); /* orange-500 */ }
      #output h3, #renderedContentDisplay h3 { color: rgb(185 28 28); /* red-700 */ }
      #output h4, #renderedContentDisplay h4 { color: rgb(37 99 235); /* blue-600 */ }
      #output h5, #renderedContentDisplay h5 { color: rgb(168, 85, 247); /* purple-500 */ }
      #output h6, #renderedContentDisplay h6 { color: rgb(107, 114, 128); /* gray-500 */ }
      #mindMapCanvas { border-color: #d1d5db; /* gray-300 */ }
      .modal-content { background-color: white; }
      .modal-header { border-color: #e5e7eb; /* gray-200 */ }
      .modal-title { color: #1f2937; /* gray-800 */ }
      .help-icon { color: #3b82f6; /* blue-500 */ }
      .help-icon:hover { color: #1d4ed8; /* blue-700 */ }
      .modal-close-button { color: #9ca3af; /* gray-400 */ }
      .modal-close-button:hover { color: #1f2937; /* gray-800 */ }
      .modal-body pre { background-color: #f4f4f4; color: #333; border-color: #ddd; }
      .modal-footer { border-color: #e5e7eb; /* gray-200 */ }
      #rawMdEditorTextarea { border-color: #d1d5db; /* gray-300 */ }
      #jupyterJsonDisplayContainer { background-color: #f3f4f6; border-color: #e5e7eb; }
      #jupyterJsonDisplay { color: #1f2937; /* gray-800 */ }
      #geminiOptionsPanel { background-color: #ffffff; }
      #geminiModelSelect:disabled { background-color: #f3f4f6; }
      #geminiResponseTextarea { background-color: #f9fafb; /* gray-50 */ }
      #tokenCountArea { background-color: #f9fafb; border-color: #e5e7eb; }
      .custom-prompt-textarea { border-color: #d1d5db; }
      .custom-prompt-textarea:focus { border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); }
      .main-view-action-button { background-color: #f3f4f6; border-color: #d1d5db; }
      .main-view-action-button:hover { background-color: #e5e7eb; }

      /* --- Dark Mode Overrides --- */
      html.dark body { background-color: #111827; /* gray-900 */ color: #d1d5db; /* gray-300 */ }
      html.dark hr { border-color: #4b5563; /* gray-600 */ }
      html.dark #output p, html.dark #renderedContentDisplay p { color: #d1d5db; /* gray-300 */ }
      html.dark .content-textarea { background-color: #374151; /* gray-700 */ color: #f3f4f6; /* gray-100 */ border-color: #4b5563; /* gray-600 */ }
      html.dark .content-textarea:focus { border-color: #6366f1; /* indigo-500 */ box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4); }
      html.dark #output h1, html.dark #renderedContentDisplay h1, html.dark #output h2, html.dark #renderedContentDisplay h2, html.dark #output h3, html.dark #renderedContentDisplay h3, html.dark #output h4, html.dark #renderedContentDisplay h4, html.dark #output h5, html.dark #renderedContentDisplay h5, html.dark #output h6, html.dark #renderedContentDisplay h6 { color: #f9fafb; /* gray-50 */ }
      /* Adjust dark header colors slightly for better visibility if needed, keeping originals for vibrancy */
      html.dark #output h1, html.dark #renderedContentDisplay h1 { color: rgb(20 184 166); } /* teal-500 */
      html.dark #output h2, html.dark #renderedContentDisplay h2 { color: rgb(234 88 12); } /* orange-500 */
      html.dark #output h3, html.dark #renderedContentDisplay h3 { color: #ef4444; /* red-500 (lighter red) */ }
      html.dark #output h4, html.dark #renderedContentDisplay h4 { color: #60a5fa; /* blue-400 (lighter blue) */ }
      html.dark #output h5, html.dark #renderedContentDisplay h5 { color: #c084fc; /* purple-400 (lighter purple) */ }
      html.dark #output h6, html.dark #renderedContentDisplay h6 { color: #9ca3af; /* gray-400 (lighter gray) */ }
      html.dark #mindMapCanvas { border-color: #4b5563; /* gray-600 */ }
      html.dark .modal-overlay { background-color: rgba(0, 0, 0, 0.8); } /* Darker overlay */
      html.dark .modal-content { background-color: #1f2937; /* gray-800 */ color: #d1d5db; /* gray-300 */ }
      html.dark .modal-header { border-color: #4b5563; /* gray-600 */ }
      html.dark .modal-title { color: #f3f4f6; /* gray-100 */ }
      html.dark .help-icon { color: #60a5fa; /* blue-400 */ }
      html.dark .help-icon:hover { color: #93c5fd; /* blue-300 */ }
      html.dark .modal-close-button { color: #6b7280; /* gray-500 */ }
      html.dark .modal-close-button:hover { color: #d1d5db; /* gray-300 */ }
      html.dark .modal-body { color: #d1d5db; /* gray-300 */ }
      html.dark .modal-body pre { background-color: #374151; /* gray-700 */ color: #e5e7eb; border-color: #4b5563; }
      html.dark .modal-footer { border-color: #4b5563; /* gray-600 */ }
      html.dark #rawMdEditorTextarea { background-color: #374151; color: #f3f4f6; border-color: #4b5563; }
      html.dark #jupyterJsonDisplayContainer { background-color: #374151; /* gray-700 */ border-color: #4b5563; /* gray-600 */ }
      html.dark #jupyterJsonDisplay { color: #e5e7eb; /* gray-200 */ }
      html.dark #geminiOptionsPanel { background-color: #1f2937; /* gray-800 */ color: #d1d5db; box-shadow: -2px 0 10px rgba(255, 255, 255, 0.05); }
      html.dark #geminiOptionsPanel label, html.dark #geminiOptionsPanel h3, html.dark #geminiOptionsPanel h4, html.dark #geminiOptionsPanel h5, html.dark #geminiOptionsPanel li { color: #d1d5db; /* gray-300 */}
      html.dark #geminiOptionsPanel .text-gray-700 { color: #d1d5db !important; /* Force override */ }
      html.dark #geminiOptionsPanel .text-gray-600 { color: #9ca3af !important; /* Force override */ }
      html.dark #geminiOptionsPanel .text-gray-500 { color: #6b7280 !important; /* Force override */ }
       html.dark #geminiOptionsPanel .text-gray-400 { color: #9ca3af !important; /* Force override */}
      html.dark #geminiOptionsPanel input, html.dark #geminiOptionsPanel select, html.dark #geminiOptionsPanel textarea {
        background-color: #374151; /* gray-700 */
        color: #f3f4f6; /* gray-100 */
        border-color: #4b5563; /* gray-600 */
      }
       html.dark #geminiOptionsPanel input::placeholder, html.dark #geminiOptionsPanel textarea::placeholder { color: #9ca3af; }
      html.dark #geminiModelSelect:disabled { background-color: #4b5563; /* gray-600 */ opacity: 0.6; }
      html.dark #geminiResponseTextarea { background-color: #4b5563; /* gray-600 */ }
      html.dark #tokenCountArea { background-color: #374151; /* gray-700 */ border-color: #4b5563; color: #9ca3af; }
      html.dark .custom-prompt-textarea { border-color: #4b5563; }
      html.dark .custom-prompt-textarea:focus { border-color: #6366f1; /* indigo-500 */ box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4); }
      html.dark .main-view-action-button { background-color: #4b5563; border-color: #6b7280; color: #e5e7eb; }
      html.dark .main-view-action-button:hover { background-color: #525a67; }
      html.dark .main-view-action-button:disabled { opacity: 0.4; }


      /* Other existing styles below... */
      /* Basic body styling */
      body {
        font-family: "Inter", sans-serif;
      }
      /* Horizontal rule styling */
      hr {
        /* border: 1px solid #e5e7eb; Light mode color set above */
        margin: 1.5rem 0 !important;
      }
      /* Unordered list styling */
      ul {
        margin-bottom: 0.5rem;
      }
      ul li {
        margin-bottom: 0.5rem;
        list-style: disc;
        list-style-position: inside;
      }
      /* Paragraph styling in output areas */
      #output p, #renderedContentDisplay p {
        font-size: 1rem;
        font-weight: 500;
        margin-top: 1rem;
        margin-bottom: 1rem;
        line-height: 1.6;
        /* color: #1f2937; Light mode color set above */
      }
      /* Style for the EDITABLE textareas in main preview view */
      .content-textarea {
        /* width: 100%; */ /* Width handled by flex-grow now */
        min-height: 100px; /* Minimum height */
        padding: 10px;
        margin-top: 0px; /* Margin handled by container now */
        margin-bottom: 0px; /* Margin handled by container now */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        font-family: monospace; /* Monospace font for code-like editing */
        font-size: 0.875rem; /* text-sm */
        line-height: 1.4;
        /* background-color: #ffffff; Color set above */
        /* color: #1f2937; Color set above */
        resize: vertical; /* Allow vertical resizing */
        box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s, color 0.2s; /* Added transitions */
      }
      .content-textarea:focus {
        outline: none;
        /* border-color: #4f46e5; Color set above */
        /* box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); Color set above */
      }

      /* Style for rendered headers (H1-H6) in main preview and rendered view */
      #output h1, #renderedContentDisplay h1,
      #output h2, #renderedContentDisplay h2,
      #output h3, #renderedContentDisplay h3,
      #output h4, #renderedContentDisplay h4,
      #output h5, #renderedContentDisplay h5,
      #output h6, #renderedContentDisplay h6 {
        margin-bottom: 0.5rem;
        line-height: 1.3;
        /* color: #111827; Color set above */
        padding-top: 1rem; /* Space above headers */
      }
      /* Specific header colors - set above */

      /* Remove top padding from the very first header */
      #output h1:first-child, #renderedContentDisplay h1:first-child,
      #output h2:first-child, #renderedContentDisplay h2:first-child,
      #output h3:first-child, #renderedContentDisplay h3:first-child,
      #output h4:first-child, #renderedContentDisplay h4:first-child,
      #output h5:first-child, #renderedContentDisplay h5:first-child,
      #output h6:first-child, #renderedContentDisplay h6:first-child {
        padding-top: 0;
      }
      /* Header font sizes */
      #output h1, #renderedContentDisplay h1 { font-size: 1.875rem; } /* text-3xl */
      #output h2, #renderedContentDisplay h2 { font-size: 1.5rem; } /* text-2xl */
      #output h3, #renderedContentDisplay h3 { font-size: 1.25rem; } /* text-xl */
      #output h4, #renderedContentDisplay h4 { font-size: 1.125rem; } /* text-lg */
      #output h5, #renderedContentDisplay h5 { font-size: 1rem; } /* text-base */
      #output h6, #renderedContentDisplay h6 { font-size: 0.875rem; } /* text-sm */


      /* --- Animation Styles --- */
      /* Wrapper for subsections to apply fade-in animation */
      .subsection-wrapper {
        opacity: 0;
        transform: translateY(15px); /* Start slightly lower */
        transition: opacity 0.6s ease-out, transform 0.5s ease-out;
        margin-bottom: 1.25rem; /* Add space below each section (mb-5) */
      }
      .subsection-wrapper.fade-in {
        opacity: 1;
        transform: translateY(0); /* Move to final position */
      }

      /* --- Canvas Style --- */
      #mindMapCanvas {
        width: 100%;
        height: 60vh; /* Default height, adjust as needed */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        cursor: grab; /* Indicate draggable */
        display: block; /* Prevent extra space below canvas */
      }
      #mindMapCanvas:active {
        cursor: grabbing; /* Indicate dragging */
      }

      /* --- Modal Styles --- */
      /* Overlay for modals */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent black */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000; /* Ensure modals are on top */
        padding: 1rem;
      }
      /* Content area of modals */
      .modal-content {
        /* background-color: white; Color set above */
        padding: 1.5rem;
        border-radius: 0.5rem; /* rounded-lg */
        max-width: 90%; /* Max width relative to viewport */
        max-height: 85vh; /* Max height relative to viewport */
        display: flex;
        flex-direction: column; /* Stack header, body, footer vertically */
        overflow: hidden; /* Prevent content spilling */
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
        transition: background-color 0.2s, color 0.2s; /* Added transition */
      }
      /* Specific modal widths */
      #confirmNewModal .modal-content,
      #jupyterHelpModal .modal-content {
        width: 32rem; /* Fixed width for smaller modals */
        max-width: 90%;
        max-height: 90vh;
      }
       /* Jupyter JSON Modal width */
      #jupyterJsonModal .modal-content {
         width: 48rem; /* Increase width for better JSON view */
         max-width: 90%;
      }
      /* Raw MD and Rendered HTML Modal width */
       #rawMdModal .modal-content,
       #renderedHtmlModal .modal-content {
         width: 60rem; /* Wider for editing/viewing */
         max-width: 90%;
       }

      /* Modal header styling */
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        border-bottom: 1px solid; /* Color set above */
        padding-bottom: 0.75rem;
      }
      /* Modal title styling */
      .modal-title {
        font-size: 1.125rem; /* text-lg */
        font-weight: 600; /* font-semibold */
        /* color: #1f2937; Color set above */
        display: flex;
        align-items: center;
      }
      /* Help icon styling (?) */
      .help-icon {
        margin-left: 0.5rem;
        /* color: #3b82f6; Color set above */
        font-weight: bold;
        cursor: pointer;
        font-size: 0.8rem; /* Adjust size if needed for emoji */
        width: 1.1rem; /* Keep size or adjust */
        height: 1.1rem; /* Keep size or adjust */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        transition: color 0.2s;
      }
      .help-icon:hover {
        /* color: #1d4ed8; Color set above */
      }
      /* Modal close button (X) styling */
      .modal-close-button {
        background: none;
        border: none;
        font-size: 1.8rem;
        line-height: 1;
        cursor: pointer;
        /* color: #9ca3af; Color set above */
        padding: 0.25rem;
        transition: color 0.2s;
      }
      .modal-close-button:hover {
        /* color: #1f2937; Color set above */
      }
      /* Modal body styling */
      .modal-body {
        flex-grow: 1; /* Allow body to take available space */
        overflow-y: auto; /* Enable vertical scrolling if needed */
        margin-bottom: 1rem;
        line-height: 1.6;
        font-size: 0.9rem;
      }
      /* Ordered list styling within modal body */
      .modal-body ol {
        list-style-type: decimal;
        margin-left: 1.5rem;
      }
      /* List item styling within modal body */
      .modal-body li {
        margin-bottom: 0.5rem;
        margin-left: 0.5rem;
      }
      /* Code block styling within modal body */
      .modal-body pre {
        /* background-color: #f4f4f4; Color set above */
        padding: 2.5px;
        border-radius: 4px;
        overflow-x: auto;         /* Horizontal scrolling if needed */
        font-family: monospace;
        /* color: #333; Color set above */
        line-height: 1.4;         /* Better readability */
        border: 1px solid;   /* Color set above */
        margin-block: 5px;
      }
      /* Modal footer styling */
      .modal-footer {
        border-top: 1px solid; /* Color set above */
        padding-top: 1rem;
        display: flex;
        justify-content: flex-end; /* Align buttons to the right */
        gap: 0.75rem; /* Space between buttons */
      }
      /* Specific footer alignment for Jupyter JSON modal */
      #jupyterJsonModal .modal-footer {
        justify-content: space-between; /* Space out text and button */
        align-items: center;
      }

      /* Style for EDITABLE Raw Markdown Editor Textarea in modal */
      #rawMdEditorTextarea {
        width: 100%;
        height: 100%;
        min-height: 40vh; /* Ensure decent minimum height */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        padding: 0.75rem;
        font-family: monospace;
        font-size: 0.875rem; /* text-sm */
        line-height: 1.5;
        resize: none; /* Disable resizing */
        box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        transition: background-color 0.2s, color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for Jupyter JSON display container in modal */
      #jupyterJsonDisplayContainer {
        /* background-color: #f3f4f6; Color set above */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        padding: 1rem;
        flex-grow: 1; /* Take available space */
        overflow: hidden; /* Hide overflow */
        display: flex; /* Use flexbox */
        transition: background-color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for the preformatted text element holding JSON */
      #jupyterJsonDisplay {
        font-family: monospace;
        font-size: 0.875rem; /* text-sm */
        white-space: pre; /* Preserve whitespace and line breaks */
        overflow: auto; /* Enable scrolling for long JSON */
        width: 100%;
        height: 100%;
        margin: 0;
        /* color: #1f2937; Color set above */
        transition: color 0.2s; /* Added transition */
      }
      /* Ensure code tag inside pre takes full block */
      #jupyterJsonDisplay code {
        display: block;
        padding: 0;
      }
      /* Basic styling for RENDERED HTML content in modal */
      #renderedContentDisplay {
        /* Inherits modal body styles, specific overrides can go here */
      }

      /* --- Gemini Options Panel Styles --- */
      #geminiOptionsPanel {
        position: fixed; /* Keep it in view */
        top: 0;
        right: 0;
        height: 100vh; /* Full viewport height */
        width: 300px; /* Panel width */
        max-width: 80%; /* Max width on smaller screens */
        /* background-color: #ffffff; Color set above */
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1); /* Left shadow */
        padding: 1.5rem; /* p-6 */
        z-index: 1100; /* Above modals */
        transform: translateX(100%); /* Initially hidden off-screen */
        transition: transform 0.3s ease-in-out, background-color 0.2s, color 0.2s; /* Added transitions */
        overflow-y: auto; /* Allow scrolling if content overflows */
        display: flex; /* Use flex for layout */
        flex-direction: column; /* Stack sections vertically */
      }
      #geminiOptionsPanel.visible {
        transform: translateX(0); /* Slide into view */
      }
      /* Style for disabled select */
      #geminiModelSelect:disabled {
          /* background-color: #f3f4f6; Color set above */
          cursor: not-allowed;
          opacity: 0.7;
      }
      /* Style for response textarea */
      #geminiResponseTextarea {
          font-family: monospace;
          font-size: 0.8rem;
          line-height: 1.4;
          /* background-color: #f9fafb; Color set above */
          min-height: 80px; /* Give it some initial height */
          transition: background-color 0.2s, color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for token count area */
      #tokenCountArea {
          /* background-color: #f9fafb; Color set above */
          padding: 0.5rem 0.75rem; /* py-2 px-3 */
          border-radius: 0.375rem; /* rounded-md */
          border: 1px solid; /* Color set above */
          transition: background-color 0.2s, color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for custom prompt textareas */
      .custom-prompt-textarea {
        width: 100%;
        padding: 0.5rem 0.75rem; /* py-2 px-3 */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        font-size: 0.875rem; /* text-sm */
        line-height: 1.4;
        box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        resize: vertical; /* Allow vertical resize */
        transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s; /* Added transition */
      }
      .custom-prompt-textarea:focus {
        outline: none;
        /* border-color: #4f46e5; Color set above */
        /* box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); Color set above */
      }
       /* Style for main view action buttons (next to textareas) */
       .main-view-action-button {
         width: 1.5rem; /* w-6 */
         height: 1.5rem; /* h-6 */
         /* background-color: #f3f4f6; Color set above */
         border: 1px solid; /* Color set above */
         border-radius: 0.25rem; /* rounded */
         font-size: 0.75rem; /* text-xs */
         display: flex;
         align-items: center;
         justify-content: center;
         transition: background-color 0.15s ease-in-out, color 0.15s, border-color 0.15s; /* Added transitions */
       }
       .main-view-action-button:hover {
         /* background-color: #e5e7eb; Color set above */
       }
       .main-view-action-button:disabled {
         opacity: 0.5;
         cursor: not-allowed;
       }

       /* Style for the new Refresh button (similar size to Options icon) */
       #refreshPreviewButton {
         padding: 0.5rem; /* Adjust padding to make it squarish like icon buttons */
       }
       #refreshPreviewButton svg {
          width: 1rem; /* h-4 */
          height: 1rem; /* w-4 */
          display: inline-block; /* Keep SVG inline */
       }

       /* Task List Panel Specific Dark Mode */
       html.dark #taskListPanel {
           background-color: #1f2937; /* gray-800 */
           color: #d1d5db; /* gray-300 */
           box-shadow: 0 10px 15px -3px rgba(255, 255, 255, 0.05), 0 4px 6px -2px rgba(255, 255, 255, 0.03); /* Lighter shadow */
       }
       html.dark #taskListPanel h4 { color: #f3f4f6; } /* gray-100 */
       html.dark #taskListPanel .text-gray-500 { color: #9ca3af; } /* gray-400 */
       html.dark #taskListContainer .bg-gray-50 { background-color: #374151; } /* gray-700 */
       html.dark #taskListContainer .border-gray-200 { border-color: #4b5563; } /* gray-600 */
       html.dark #taskListContainer .text-gray-900 { color: #f9fafb; } /* gray-50 */
       html.dark #taskListContainer .text-gray-700 { color: #d1d5db; } /* gray-300 */
       html.dark #taskListContainer .text-gray-600 { color: #9ca3af; } /* gray-400 */
       html.dark #taskListContainer .text-gray-500 { color: #6b7280; } /* gray-500 */
       /* Status colors */
       html.dark #taskListContainer .text-blue-600 { color: #60a5fa; } /* blue-400 */
       html.dark #taskListContainer .text-yellow-600 { color: #facc15; } /* yellow-400 */
       html.dark #taskListContainer .text-green-600 { color: #4ade80; } /* green-400 */
       html.dark #taskListContainer .text-red-600 { color: #f87171; } /* red-400 */
       html.dark #taskListContainer .text-gray-500 { color: #9ca3af; } /* gray-400 */
       html.dark #taskListContainer .cancel-task-btn { color: #f87171; } /* red-400 */
       html.dark #taskListContainer .cancel-task-btn:hover { color: #ef4444; } /* red-500 */

        /* Dark Mode Toggle Button */
        #darkModeToggle {
            padding: 0.5rem;
        }
        #darkModeToggle .moon-icon { display: inline-block; }
        #darkModeToggle .sun-icon { display: none; }
        html.dark #darkModeToggle .moon-icon { display: none; }
        html.dark #darkModeToggle .sun-icon { display: inline-block; }


    </style>
  </head>
  <body class="bg-gray-100 dark:bg-gray-900 p-4 md:p-8 transition-colors duration-200"> <!-- Added dark bg and transition -->
    <button
      type="button"
      id="taskListButton"
      title="Show Task List"
      class="fixed top-1/2 left-0 transform -translate-y-1/2 z-50 w-16 h-16 bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white rounded-md shadow-lg flex items-center justify-center text-3xl transition duration-150 ease-in-out"
    >
      📧
    </button>
    <div class="max-w-4xl mx-auto bg-white dark:bg-gray-800 p-6 md:p-8 rounded-lg shadow-md relative transition-colors duration-200"> <!-- Added dark bg and transition -->
      <h1 class="text-2xl font-bold mb-6 text-center text-gray-800 dark:text-gray-200 transition-colors duration-200"> <!-- Added dark text -->
        Interactive eBook Editor
      </h1>
      <!-- Task List Panel (Dark mode styles added in <style>) -->
      <div
        id="taskListPanel"
        class="fixed bottom-4 left-[80px] z-40 w-[200px] max-h-[60vh] overflow-y-auto p-4 bg-white rounded-lg shadow-xl transform translate-y-full opacity-0 invisible transition-all duration-300 ease-in-out"
      >
        <h4 class="text-lg font-semibold mb-2 text-gray-800">Task List</h4>
        <div id="taskListContainer">
          <p class="text-sm text-gray-500">No active tasks.</p>
        </div>
      </div>
      <div class="mb-6">
        <div class="border-b border-gray-200 dark:border-gray-700 transition-colors duration-200"> <!-- Added dark border -->
          <nav class="-mb-px flex space-x-8" aria-label="Tabs">
            <!-- Tab Button File -->
            <button
              type="button"
              id="tabButtonFile"
              class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-indigo-500 dark:border-indigo-400 text-indigo-600 dark:text-indigo-400 transition-colors duration-200"
              aria-current="page"
            >
              Load from File
            </button>
            <!-- Tab Button URL -->
            <button
              type="button"
              id="tabButtonUrl"
              class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:border-gray-300 dark:hover:border-gray-600 transition-colors duration-200"
            >
              Load from URL
            </button>
          </nav>
        </div>

        <div class="pt-4">
          <!-- Tab Panel File -->
          <div id="tabPanelFile">
            <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
              <label for="mdFileInput" class="block text-sm font-medium text-gray-700 dark:text-gray-300 transition-colors duration-200"> <!-- Added dark text -->
                Select Markdown File (.md):
              </label>
              <input
                type="file"
                id="mdFileInput"
                accept=".md"
                class="flex-grow-0 w-full sm:w-auto text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 dark:file:bg-indigo-900 file:text-indigo-700 dark:file:text-indigo-300 hover:file:bg-indigo-100 dark:hover:file:bg-indigo-800 transition-colors duration-200"
              />
            </div>
          </div>

          <!-- Tab Panel URL -->
          <div id="tabPanelUrl" class="hidden">
            <div class="flex flex-col sm:flex-row items-center justify-center gap-2">
              <label for="mdUrlInput" class="block text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap sr-only"> <!-- Added dark text -->
                Enter Markdown URL:
              </label>
              <input
                type="url"
                id="mdUrlInput"
                placeholder="Enter Markdown URL..."
                class="flex-grow w-full sm:w-auto px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:focus:border-indigo-400 dark:focus:ring-indigo-400 dark:bg-gray-700 dark:text-gray-100 dark:placeholder-gray-400 text-sm transition-colors duration-200"
              />
              <button
                id="loadFromUrlButton"
                class="bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm flex-shrink-0"
              >
                Load from URL
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="text-center mb-6 flex flex-wrap justify-center items-center gap-3">
        <button
          id="newButton"
          class="bg-teal-500 hover:bg-teal-600 dark:bg-teal-600 dark:hover:bg-teal-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm"
          title="Start a new blank document"
        >
          New
        </button>
        <button
          id="viewRawMdButton"
          class="bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          disabled
        >
          Edit Raw Markdown
        </button>
        <button
          id="viewRenderedButton"
          class="bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          disabled
        >
          View Rendered HTML
        </button>
        <button
          id="exportJupyterButton"
          class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          disabled
          title="Export content as Jupyter Notebook (.ipynb)"
        >
          Export to Jupyter
        </button>
        <button
          id="toggleGeminiPanelButton"
          class="bg-purple-500 hover:bg-purple-600 dark:bg-purple-600 dark:hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm"
          title="Toggle Gemini Options"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
          Options
        </button>
        <button
          id="refreshPreviewButton"
          class="bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700 text-white font-semibold py-2 px-2 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          title="Refresh Preview"
          disabled
        >
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
            <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
          </svg>
        </button>
        <!-- Dark Mode Toggle Button -->
        <button
            id="darkModeToggle"
            class="bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-500 text-white font-semibold py-2 px-2 rounded-md shadow transition duration-150 ease-in-out text-sm"
            title="Toggle Dark Mode"
        >
            <!-- Moon Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 moon-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
            </svg>
            <!-- Sun Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sun-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
        </button>
      </div>

      <!-- Output Area -->
      <div class="border-t border-gray-200 dark:border-gray-700 pt-6 transition-colors duration-200"> <!-- Added dark border -->
        <h2 id="outputTitle" class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200 truncate transition-colors duration-200" title="Preview"> <!-- Added dark text -->
          Preview
        </h2>
        <div id="output">
          <p class="text-gray-500 dark:text-gray-400 transition-colors duration-200" id="outputPlaceholder"> <!-- Added dark text -->
            Select a .md file to automatically load and render, or click 'New'.
          </p>
        </div>
      </div>
    </div>

    <!-- Modals (Dark mode styles added via <style> block and html.dark prefix) -->
    <div id="rawMdModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Edit Raw Markdown</h3>
          <button id="closeRawMdModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <textarea id="rawMdEditorTextarea" spellcheck="false" placeholder="Insert Subject Matter."></textarea>
        </div>
        <div class="modal-footer">
          <button
            id="saveRawMdButton"
            class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm"
          >
            Save Changes & Close
          </button>
        </div>
      </div>
    </div>

    <div id="renderedHtmlModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Rendered HTML View</h3>
          <button id="closeRenderedModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <div id="renderedContentDisplay"></div>
        </div>
      </div>
    </div>

    <div id="confirmNewModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Confirm New Document</h3>
        </div>
        <div class="modal-body">
          <p class="text-sm text-gray-700 dark:text-gray-300"> <!-- Added dark text -->
            Are you sure you want to start a new document? Any unsaved changes will be lost.
          </p>
        </div>
        <div class="modal-footer">
          <button
            id="cancelNewButton"
            class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Cancel
          </button>
          <button
            id="confirmNewButton"
            class="bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Start New
          </button>
        </div>
      </div>
    </div>

    <div id="jupyterJsonModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">
            Jupyter Notebook JSON (.ipynb)
            <span id="jupyterHelpIcon" class="help-icon" title="How to use this JSON?">ℹ️</span>
          </h3>
          <button id="closeJupyterJsonModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <div id="jupyterJsonDisplayContainer">
            <pre id="jupyterJsonDisplay"><code>{/* JSON will be loaded here */}</code></pre>
          </div>
        </div>
        <div class="modal-footer">
          <p class="text-xs text-gray-500 dark:text-gray-400 mr-auto">Copy JSON & save as '.ipynb' file.</p> <!-- Added dark text -->
          <button
            id="copyJupyterJsonButton"
            class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Copy JSON
          </button>
        </div>
      </div>
    </div>

    <div id="jupyterHelpModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">How to Create Jupyter Notebook File</h3>
          <button id="closeJupyterHelpModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <p class="mb-3">To use the generated JSON in Jupyter:</p>
          <ol>
            <li>Click the "Copy JSON" button in the previous modal (or select all text in the JSON display area and copy it manually with <code>Ctrl+C</code> or <code>Cmd+C</code>).</li>
            <li>Open a plain text editor (like Notepad, TextEdit, VS Code, etc.).</li>
            <li>Paste the copied JSON text into a new, blank file.</li>
            <li>Go to <code>File > Save As...</code></li>
            <li>Choose a location and name the file with the <code>.ipynb</code> extension (e.g., <code>my_notebook.ipynb</code>).</li>
            <li>Ensure the "Save as type" is set to "All Files" (if applicable) and the encoding is UTF-8.</li>
            <li>Save the file.</li>
            <li>Open Jupyter Notebook or JupyterLab, navigate to where you saved the file, and click it to open.</li>
          </ol>
        </div>
        <div class="modal-footer">
          <button
            id="closeJupyterHelpModalButtonOk"
            class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Understood
          </button>
        </div>
      </div>
    </div>

    <!-- Gemini Panel (Dark mode styles added via <style> block and html.dark prefix) -->
    <div id="geminiOptionsPanel">
        <!-- Content remains the same, dark mode styles applied via CSS -->
        <div class="flex justify-between items-center mb-4 border-b dark:border-gray-600 pb-2 flex-shrink-0">
            <h3 class="text-lg font-semibold text-gray-700">Gemini Options</h3>
            <button id="closeGeminiPanelButton" class="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-100 text-2xl leading-none transition-colors duration-200">&times;</button>
        </div>

        <div class="flex-grow overflow-y-auto pr-2">
            <div class="mb-4">
                <label for="geminiApiKey" class="block text-sm font-medium text-gray-600 mb-1">Gemini API Key:</label>
                <input type="password" id="geminiApiKey" name="geminiApiKey" placeholder="Enter your API key" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus:border-purple-400 dark:focus:ring-purple-400 dark:placeholder-gray-400 transition-colors duration-200">
                <p id="geminiApiError" class="text-xs text-red-500 dark:text-red-400 mt-1 h-4"></p>
            </div>
            <div class="mb-4">
                 <label for="geminiModelSelect" class="block text-sm font-medium text-gray-600 mb-1">Select Model:</label>
                 <select id="geminiModelSelect" name="geminiModelSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-sm bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus:border-purple-400 dark:focus:ring-purple-400 transition-colors duration-200" disabled>
                     <option value="">-- Enter API Key --</option>
                 </select>
                 <p id="activeModelIndicator" class="text-xs text-gray-500 italic mt-1 h-4"></p>
            </div>

            <div class="mb-4 border-t dark:border-gray-600 pt-4">
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Custom Prompts</h4>
                 <div class="mb-3">
                     <label for="promptCreatePlan" class="block text-sm font-medium text-gray-600 mb-1">Create Plan Prompt:</label>
                     <textarea id="promptCreatePlan" rows="3" class="custom-prompt-textarea" placeholder="Enter prompt for creating a plan..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptGenerateContent" class="block text-sm font-medium text-gray-600 mb-1">Generate Content Prompt:</label>
                     <textarea id="promptGenerateContent" rows="3" class="custom-prompt-textarea" placeholder="Enter prompt for generating content..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptFactCheck" class="block text-sm font-medium text-gray-600 mb-1">Fact Check Prompt:</label>
                     <textarea id="promptFactCheck" rows="3" class="custom-prompt-textarea" placeholder="Enter prompt for fact checking..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptCustom1" class="block text-sm font-medium text-gray-600 mb-1">Custom 1 Prompt:</label>
                     <textarea id="promptCustom1" rows="3" class="custom-prompt-textarea" placeholder="Enter custom prompt 1..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptCustom2" class="block text-sm font-medium text-gray-600 mb-1">Custom 2 Prompt:</label>
                     <textarea id="promptCustom2" rows="3" class="custom-prompt-textarea" placeholder="Enter custom prompt 2..."></textarea>
                 </div>
            </div>

             <div class="mt-4 border-t dark:border-gray-600 pt-4">
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Test Prompt</h4>
                 <button id="sendPromptButton" class="w-full bg-green-500 hover:bg-green-600 dark:bg-green-600 dark:hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm disabled:opacity-50 disabled:cursor-not-allowed">
                   Send "hello world"
                 </button>
                 <label for="geminiResponseTextarea" class="block text-sm font-medium text-gray-600 mt-3 mb-1">Response:</label>
                 <textarea id="geminiResponseTextarea" rows="4" readonly class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm text-sm bg-gray-50 cursor-default dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 transition-colors duration-200"></textarea>
                 <div id="tokenCountArea" class="mt-3 text-xs text-gray-600">
                     <h5 class="font-semibold mb-1">Token Usage (Cumulative):</h5>
                     <div>In: <span id="promptTokenCount" class="font-medium">0</span></div>
                     <div>Out: <span id="completionTokenCount" class="font-medium">0</span></div>
                     <div>Total: <span id="totalTokenCount" class="font-medium">0</span></div>
                 </div>
            </div>

            <div class="mb-4 border-t dark:border-gray-600 pt-4">
                <label for="batchDelayInput" class="block text-sm font-medium text-gray-600 mb-1">Delay Between Batch Tasks (seconds):</label>
                <input
                  type="number"
                  id="batchDelayInput"
                  name="batchDelayInput"
                  min="0"
                  value="15" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus:border-purple-400 dark:focus:ring-purple-400 transition-colors duration-200"
                >
            </div>

            <div class="mt-4 border-t dark:border-gray-600 pt-4">
              <h4 class="text-sm font-semibold text-gray-700 mb-2">Run Task on All Sections</h4>
              <div class="space-y-2">
                <button id="runPlanOnAllBtn" class="w-full bg-teal-500 hover:bg-teal-600 dark:bg-teal-600 dark:hover:bg-teal-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Plan on All
                </button>
                <button id="runGenerateOnAllBtn" class="w-full bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Generate on All
                </button>
                <button id="runCheckOnAllBtn" class="w-full bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Check on All
                </button>
                <button id="runCustom1OnAllBtn" class="w-full bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Custom 1 on All
                </button>
                <button id="runCustom2OnAllBtn" class="w-full bg-purple-500 hover:bg-purple-600 dark:bg-purple-600 dark:hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Custom 2 on All
                </button>
              </div>
            </div>

            <div class="mt-4 border-t dark:border-gray-600 pt-4">
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Version: 1</h4>
                 <ul>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add markdown editing.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add markdown rendering.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add export jupyter.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add gemini integration.</li>
                  </ul>
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Version: 2</h4>
                 <ul>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add mathjax.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add load markdown remotely.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add load by #markdownUrl paramoutside of Gemini</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add tabs to change load markdown ui.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add button emoji instead of numbers.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add tasks panel and tracking.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add ability to cancel pending task.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add dark and light mode.a</li>
                 </ul>
            </div>
        </div>
    </div>


    <script>
      // --- DOM Elements ---
      const htmlElement = document.documentElement; // Get <html> element
      const darkModeToggle = document.getElementById('darkModeToggle'); // Get toggle button
      // ... (keep all existing element references)
      const fileInput = document.getElementById("mdFileInput");
      const viewRawMdButton = document.getElementById("viewRawMdButton");
      const viewRenderedButton = document.getElementById("viewRenderedButton");
      const exportJupyterButton = document.getElementById("exportJupyterButton");
      const newButton = document.getElementById("newButton");
      const outputDiv = document.getElementById("output");
      const outputTitle = document.getElementById("outputTitle");
      const outputPlaceholder = document.getElementById("outputPlaceholder");
      const refreshPreviewButton = document.getElementById("refreshPreviewButton"); // Get reference to the new button
      // Raw MD Modal elements
      const rawMdModal = document.getElementById("rawMdModal");
      const closeRawMdModalButton = document.getElementById("closeRawMdModalButton");
      const rawMdEditorTextarea = document.getElementById("rawMdEditorTextarea");
      const saveRawMdButton = document.getElementById("saveRawMdButton");
      // Rendered HTML Modal elements
      const renderedHtmlModal = document.getElementById("renderedHtmlModal");
      const closeRenderedModalButton = document.getElementById("closeRenderedModalButton");
      const renderedContentDisplay = document.getElementById("renderedContentDisplay");
      // Confirm New Modal elements
      const confirmNewModal = document.getElementById("confirmNewModal");
      const cancelNewButton = document.getElementById("cancelNewButton");
      const confirmNewButton = document.getElementById("confirmNewButton");
      // Jupyter JSON Modal elements
      const jupyterJsonModal = document.getElementById("jupyterJsonModal");
      const closeJupyterJsonModalButton = document.getElementById("closeJupyterJsonModalButton");
      const jupyterJsonDisplay = document.getElementById("jupyterJsonDisplay").querySelector("code");
      const copyJupyterJsonButton = document.getElementById("copyJupyterJsonButton");
      // Jupyter Help Modal elements
      const jupyterHelpIcon = document.getElementById("jupyterHelpIcon");
      const jupyterHelpModal = document.getElementById("jupyterHelpModal");
      const closeJupyterHelpModalButton = document.getElementById("closeJupyterHelpModalButton");
      const closeJupyterHelpModalButtonOk = document.getElementById("closeJupyterHelpModalButtonOk");
      // Gemini Panel Elements
      const geminiOptionsPanel = document.getElementById("geminiOptionsPanel");
      const toggleGeminiPanelButton = document.getElementById("toggleGeminiPanelButton");
      const closeGeminiPanelButton = document.getElementById("closeGeminiPanelButton");
      const geminiApiKeyInput = document.getElementById("geminiApiKey");
      const geminiModelSelect = document.getElementById("geminiModelSelect");
      const geminiApiError = document.getElementById("geminiApiError");
      const activeModelIndicator = document.getElementById("activeModelIndicator");
      const sendPromptButton = document.getElementById("sendPromptButton");
      const geminiResponseTextarea = document.getElementById("geminiResponseTextarea");
      const promptTokenCountEl = document.getElementById("promptTokenCount");
      const completionTokenCountEl = document.getElementById("completionTokenCount");
      const totalTokenCountEl = document.getElementById("totalTokenCount");
      // Custom Prompt Textareas
      const promptCreatePlanEl = document.getElementById("promptCreatePlan");
      const promptGenerateContentEl = document.getElementById("promptGenerateContent");
      const promptFactCheckEl = document.getElementById("promptFactCheck");
      const promptCustom1El = document.getElementById("promptCustom1");
      const promptCustom2El = document.getElementById("promptCustom2");
      // Get references for URL input elements
      const mdUrlInput = document.getElementById("mdUrlInput");
      const loadFromUrlButton = document.getElementById("loadFromUrlButton");
      // Get references for Tab elements
      const tabButtonFile = document.getElementById("tabButtonFile");
      const tabButtonUrl = document.getElementById("tabButtonUrl");
      const tabPanelFile = document.getElementById("tabPanelFile");
      const tabPanelUrl = document.getElementById("tabPanelUrl");
      // Get reference for Task List Panel
      const taskListPanel = document.getElementById("taskListPanel");
      // Ensure taskListButton reference exists from previous step
      const taskListButton = document.getElementById("taskListButton");
      const taskListContainer = document.getElementById("taskListContainer");
      // Get references for Batch Job elements
      const batchDelayInput = document.getElementById("batchDelayInput");
      // Get references for Batch Run buttons
      const runPlanOnAllBtn = document.getElementById("runPlanOnAllBtn");
      const runGenerateOnAllBtn = document.getElementById("runGenerateOnAllBtn");
      const runCheckOnAllBtn = document.getElementById("runCheckOnAllBtn");
      const runCustom1OnAllBtn = document.getElementById("runCustom1OnAllBtn");
      const runCustom2OnAllBtn = document.getElementById("runCustom2OnAllBtn");


      // --- State ---
      let rawFileContent = null;
      let currentFilename = null;
      let cumulativeInTokens = 0;
      let cumulativeOutTokens = 0;
      let cumulativeTotalTokens = 0;
      let activeTasks = [];
      let nextTaskId = 1;
      let createPlan =
        "QWx3YXlzIGZvcm1hdCByZXNwb25zZXMgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcnVsZXMgdG8gcHJvZHVjZSBhIGNvbmNpc2UsIGxvZ2ljYWxseSBzdHJ1Y3R1cmVkIGxlYXJuaW5nIGFnZW5kYSBzdWl0YWJsZSBmb3Igc2VsZi1kaXJlY3RlZCBtYXN0ZXJ5IG9mIGFueSBhY2FkZW1pYyBvciB0ZWNobmljYWwgc3ViamVjdC4gQmVnaW4gaW1tZWRpYXRlbHkgd2l0aCB0aGUgYWdlbmRhIGNvbnRlbnQsIG9taXR0aW5nIGFsbCBpbnRyb2R1Y3Rvcnkgc3RhdGVtZW50cywgY291cnNlIGluZm9ybWF0aW9uLCBkZXNjcmlwdGlvbnMsIGdyYWRpbmcgcG9saWNpZXMsIGFuZCBhZG1pbmlzdHJhdGl2ZSBkZXRhaWxzLiBBZnRlciBlYWNoIGhlYWRlciBvciBmb3IgZWFjaCAgYnVsbGV0IGFjdHVhbGx5IGRlZmluZSB0aGUgcHJvbXB0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoYXQgc2VjdGlvbiBvciBidWxsZXQgY29udGVudCB3aXRoIGFuIExMTSBjYXB0dXJpbmcgdGhlIGNvbnRleHQgb2YgbWFpbiB0b3BpYyBhbmQgcGFyZW50IHRvcGljcy4gIFdoZW4gIGEgbWluZG1hcCBpcyBwcm92aWRlZCB1c2UgaXQncyBzZWNvbmQgbGV2ZWwgaGVhZGVycyBhcyB0aGUgY2hhcHRlcnMuICBJbmNsdWRlIG9ubHkgdG9waWNzIGRpcmVjdGx5IHJlbGV2YW50IHRvIHRoZSBsZWFybmluZyBvYmplY3RpdmVzIGFuZCB0aGUgcHJvZ3Jlc3Npb24gZnJvbSBmb3VuZGF0aW9uYWwgdG8gYWR2YW5jZWQga25vd2xlZGdlOgoKMS4gICoqTWFpbiBTZWN0aW9uIEhlYWRpbmdzKioKICAgICogVXNlIFJvbWFuIG51bWVyYWxzIChJLCBJSSwgSUlJLCBldGMuKSBmb3IgbWFqb3Igc2VjdGlvbnMuCiAgICAqIEZvcm1hdCBtYWluIGhlYWRpbmdzIHVzaW5nIE1hcmtkb3duJ3MgaGVhZGluZyBsZXZlbCAxICgjIEhlYWRpbmcpLgoKMi4gICoqU3Vic2VjdGlvbnMqKgogICAgKiBVc2UgTWFya2Rvd24ncyBoZWFkaW5nIGxldmVsIDIgKCMjIFN1YmhlYWRpbmcpIGZvciBzdWJzZWN0aW9ucyBkaXJlY3RseSB1bmRlciBlYWNoIG1haW4gaGVhZGluZy4KICAgICogQ2xlYXJseSB3cml0ZSBhbiBsbG0gcHJvbXB0IHRvIGRlc2NyaWJlIHRoZSB0b3BpYyBvciBza2lsbCB0byBiZSBsZWFybmVkIGluIGNvbmNpc2UsIGluZm9ybWF0aXZlIGxhbmd1YWdlLgoKMy4gICoqTmVzdGVkIFN1YnRvcGljcyoqCiAgICAqIFVzZSBNYXJrZG93bidzIGhlYWRpbmcgbGV2ZWwgMyAoIyMjIE5lc3RlZCBTdWJoZWFkaW5nKSBhbmQgbG93ZXIgZm9yIGRlZXBlciBsZXZlbHMgb2YgZGV0YWlsLgogICAgKiBFbnN1cmUgZWFjaCBuZXN0ZWQgc3VidG9waWMgbG9naWNhbGx5IGV4cGFuZHMgdXBvbiBvciBjbGFyaWZpZXMgdGhlIGhpZ2hlci1sZXZlbCBoZWFkaW5nLgoKNC4gICoqRGV0YWlscyBhbmQgRXhhbXBsZXMqKgogICAgKiBXcml0ZSBhIGxsbSBwcm9tcHQgdG8gZ2l2ZSBzcGVjaWZpYyBleGFtcGxlcyBvciBpbGx1c3RyYXRpdmUgZGV0YWlscyByZWxldmFudCB0byBsZWFybmluZyB0aGUgdG9waWMuCiAgICAqIEZvcm1hdCBhbnkgdGVjaG5pY2FsIHJlZmVyZW5jZXMsIGNvbW1hbmRzLCBvciB0ZXJtaW5vbG9neSB1c2luZyBNYXJrZG93bidzIGlubGluZSBjb2RlIGZvcm1hdHRpbmcgKGNvZGUpLgogICAgKiBVc2UgTWFya2Rvd24gY29kZSBibG9ja3MgKGApIGZvciBtdWx0aS1saW5lIGNvZGUgZXhhbXBsZXMuCiAgICAqIFVzZSBNYXRoamF4ICQkICQkIGZvciBtYXRoIGVxdWF0aW9ucy4KCjUuICAqKkNvbnNpc3RlbmN5IGFuZCBDbGFyaXR5KioKICAgICogTWFpbnRhaW4gY29uc2lzdGVudCB2ZXJiIGZvcm1zIChlLmcuLCAiVW5kZXJzdGFuZGluZywiICJBbmFseXppbmcsIiAiQXBwbHlpbmciKSBmb3IgcmVhZGFiaWxpdHkuCiAgICAqIENsZWFybHkgc2VwYXJhdGUgY29uY2VwdHVhbCBleHBsYW5hdGlvbnMgZnJvbSBwcmFjdGljYWwgdGFza3Mgb3Igc21hbGwgaW50ZXJpbSBwcm9qZWN0cyByZWxldmFudCB0byBsZWFybmluZy4KCjYuICAqKkxvZ2ljYWwgUHJvZ3Jlc3Npb24qKgogICAgKiBPcmRlciB0b3BpY3Mgc2VxdWVudGlhbGx5LCBwcm9ncmVzc2luZyBmcm9tIGJhc2ljIHRvIGFkdmFuY2VkIGNvbmNlcHRzLgogICAgKiBHcm91cCByZWxhdGVkIHRvcGljcywgY29uY2VwdHMsIG9yIHNraWxscyBpbnRvIGNvaGVyZW50IG1vZHVsZXMgb3Igc2VjdGlvbnMuCgo3LiAgKipBZHZhbmNlZCBUZWNobmlxdWVzIGFuZCBDb25jZXB0cyoqCiAgICAqIENvbXBsZXggSW50ZWdyYXRpb25zCiAgICAqIFBlcmZvcm1hbmNlIE9wdGltaXphdGlvbgogICAgKiBJbXByb3ZpbmcgVGVjaG5pcXVlcwogICAgKiBCZW5jaG1hcmtpbmcgYW5kIFByb2ZpbGluZyAKCkZvciBUZWNoOgo4LiAqKkFkdmFuY2VkIEVycm9yIEhhbmRsaW5nIGFuZCBEZWJ1Z2dpbmcqKgogICAqIFJvYnVzdCBFcnJvciBNYW5hZ2VtZW50CiAgICAgLSBEZWJ1Z2dpbmcgQ29tcGxleCBTY2VuYXJpb3MKCkV4YW1wbGUgU3RydWN0dXJlOgoKIyBJLiBNYWpvciBUb3BpYyBIZWFkaW5nCgojIyBTdWJ0b3BpYyBEZXNjcmlwdGlvbgoiPHByb21wdD4iCgojIyMgTmVzdGVkIHN1YnRvcGljIG9yIGRldGFpbGVkIGFjdGl2aXR5CiI8cHJvbXB0PiIKCiMjIyBBbm90aGVyIGRldGFpbGVkIGFjdGl2aXR5CiogIjxwcm9tcHQiPgoKQWRkaXRpb24gZGlyZWN0aW9ucy4KCgkxLglDbGFyaWZ5IGxlYXJuaW5nIG9iamVjdGl2ZXMgZm9yIGVhY2ggc2VjdGlvbi4KCTIuCUFkZCBjb25jaXNlIHN1bW1hcmllcyBhZnRlciBtYWpvciB0b3BpY3MuCgkzLglJbmNsdWRlIGdsb3NzYXJ5IGRlZmluaXRpb25zIGZvciBrZXkgdGVjaG5pY2FsIHRlcm1zLgoJNC4JSW50ZWdyYXRlIGludGVyYWN0aXZlIHF1aXp6ZXMgZm9yIHNlbGYtYXNzZXNzbWVudC4KCTUuCVByb3ZpZGUgY2xlYXIgc2VjdGlvbiB0cmFuc2l0aW9ucyB0byBhaWQgbmF2aWdhdGlvbi4KCTYuCUVtcGhhc2l6ZSBrZXkgcG9pbnRzIHdpdGggaGlnaGxpZ2h0ZWQgY2FsbG91dHMuCgk3LglTdHJ1Y3R1cmUgY29udGVudCB3aXRoIHByb2dyZXNzaXZlIGRpZmZpY3VsdHkgbGV2ZWxzLgoJOC4JU3VwcGx5IGNyb3NzLXJlZmVyZW5jZXMgYmV0d2VlbiByZWxhdGVkIHRvcGljcy4KCTkuCUVtYmVkIGxpbmtzIGZvciBmdXJ0aGVyIGV4cGxvcmF0aW9uIGFuZCBpbi1kZXB0aCByZWFkaW5nLgoJMTAuCUVuY291cmFnZSByZWZsZWN0aXZlIHByb21wdHMgdG8gY29uc29saWRhdGUgdW5kZXJzdGFuZGluZy4KICAgIDExLiAgQWx3YXlzLCBpbmNsdWRlIGluIHRoZSBpbnRlcm5hbCBwcm9tcHQgd2hhdCBoZWFkaW5nIGxldmVsIHRvIHN0YXJ0IHRoZSBuZXh0IGhlYWRpbmcgb24gaWUgbGV2ZWwgMiB0aHJvdWdoIDYuCiAgICAxMi4gIEZvciBtYXRoZW1hdGljYWwgZXF1YXRpb25zLCB1c2UgTWF0aGpheCBmb3JtYXQuCgo=";
      let generateContent = "Generate the content for the intenral prompts using proper markdown.  Do not reply to user or add superflours text.  Ignore the starting heading and begin immeiately producing cotnent.";
      let factCheck = "Fact check the content: ";
      let custom1 = "Q3JlYXRlIGEgY29tcHJlaGVuc2l2ZSBNYXJrZG93bi1iYXNlZCBtaW5kIG1hcCBmb3IgdGhlIHRvcGljOiBgJHt0b3BpY31gCgoqKkluc3RydWN0aW9uczoqKgoxLiAgKipHb2FsOioqIEdlbmVyYXRlIGEgZGV0YWlsZWQgYW5kIHRob3JvdWdoIGhpZXJhcmNoaWNhbCBvdXRsaW5lIG9mIHRoZSBzcGVjaWZpZWQgdG9waWMuIFRoZSBhaW0gaXMgdG8gY2FwdHVyZSB0aGUgbWFqb3Igc2VjdGlvbnMgYW5kIHN1Yi1zZWN0aW9ucyBjb21wcmVoZW5zaXZlbHkuIFN0cml2ZSBmb3IgYSBsZXZlbCBvZiBkZXRhaWwgaW4gdGhlIG1haW4gc2VjdGlvbnMgKExldmVsIDIgaGVhZGluZ3MpIGNvbXBhcmFibGUgdG8gY2hhcHRlcnMgaW4gYSBjb21wcmVoZW5zaXZlIHRleHRib29rIG9yIG1vZHVsZXMgaW4gYSBmdWxsIGNvdXJzZSBvbiB0aGUgc3ViamVjdC4KMi4gICoqRm9ybWF0OioqCiAgICAqIFJlcHJlc2VudCB0aGUgaGllcmFyY2h5IHVzaW5nIE1hcmtkb3duIGhlYWRpbmdzIChgI2AsIGAjI2AsIGAjIyNgLCBldGMuKS4KICAgICAgICAqIExldmVsIDEgKGAjYCkgZm9yIHRoZSByb290IHRvcGljOiBgJHt0b3BpY31gLgogICAgICAgICogTGV2ZWwgMiAoYCMjYCkgZm9yICoqYWxsIHNpZ25pZmljYW50IG1haW4gY29tcG9uZW50cyBvciBzZWN0aW9ucyoqIG9mIHRoZSB0b3BpYy4gQmUgdGhvcm91Z2ggYXQgdGhpcyBsZXZlbC4KICAgICAgICAqIExldmVsIDMgKGAjIyNgKSBmb3Igc3ViLXRvcGljcyB3aXRoaW4gbWFpbiBjb21wb25lbnRzLgogICAgICAgICogTGV2ZWwgNCAoYCMjIyNgKSBhbmQgc3Vic2VxdWVudCBsZXZlbHMgZm9yIGZ1cnRoZXIgZGV0YWlscywgYXMgbmVlZGVkLgogICAgKiBBZnRlciB0aGUgdGV4dCBvZiBlYWNoIGhlYWRpbmcsIGFwcGVuZCAxLTMgcmVsZXZhbnQgaGFzaHRhZ3MgKGUuZy4sIGAja2V5d29yZGAsIGAjY2F0ZWdvcnlgLCBgI2NvbmNlcHRgKSBzZXBhcmF0ZWQgYnkgc3BhY2VzLgogICAgKiAqKk9wdGlvbmFsIE5vdGVzOioqIEltbWVkaWF0ZWx5IGZvbGxvd2luZyBhbnkgaGVhZGluZyBsaW5lIChoZWFkaW5nICsgaGFzaHRhZ3MpLCB5b3UgY2FuIGluY2x1ZGUgb25lIG9yIG1vcmUgbGluZXMgb2YgcGxhaW4gdGV4dCBub3RlcyBmb3IgZnVydGhlciBkZXNjcmlwdGlvbiBvciBleHBsYW5hdGlvbi4gVGhlc2Ugbm90ZXMgc2hvdWxkICpub3QqIHN0YXJ0IHdpdGggYCNgLgozLiAgKipTdHJ1Y3R1cmUgR3VpZGFuY2U6KioKICAgICogU3RhcnQgd2l0aCBgJHt0b3BpY31gIGFzIHRoZSBMZXZlbCAxIGhlYWRpbmcgKGAjYCkuCiAgICAqIENyaXRpY2FsbHkgYW5hbHl6ZSB0aGUgdG9waWMgdG8gaWRlbnRpZnkgKiphbGwgaXRzIG1ham9yIGVzdGFibGlzaGVkIHN1YmRpdmlzaW9ucyoqLiBUaGluayBpbiB0ZXJtcyBvZiBmdW5kYW1lbnRhbCBjb25jZXB0cywga2V5IGFyZWFzLCBwcm9jZXNzZXMsIGFwcGxpY2F0aW9ucywgYWR2YW5jZWQgdG9waWNzLCBldGMuIExpc3QgdGhlc2UgYXMgTGV2ZWwgMiAoYCMjYCkgaGVhZGluZ3MuICoqRG8gbm90IHN0b3AgYXQganVzdCBhIGZldzsgYWltIGZvciBhIGNvbXBsZXRlIHRvcC1sZXZlbCBicmVha2Rvd24uKioKICAgICogVW5kZXIgZWFjaCBMZXZlbCAyIGhlYWRpbmcsIGJyZWFrIGl0IGRvd24gZnVydGhlciBpbnRvIGxvZ2ljYWwgc3ViLXRvcGljcyAoTGV2ZWwgMyBgIyMjYCkgYW5kIHNwZWNpZmljIGRldGFpbHMgKExldmVsIDQgYCMjIyNgLCBldGMuKSBhcyBhcHByb3ByaWF0ZSBmb3IgdGhhdCBzZWN0aW9uLgo0LiAgKipPdXRwdXQ6KiogUHJlc2VudCB0aGUgZmluYWwgcmVzdWx0IGFzIGEgc2luZ2xlIE1hcmtkb3duIHN0cnVjdHVyZS4KCioqRXhhbXBsZSBTdHJ1Y3R1cmUgKGlsbHVzdHJhdGluZyBleHBlY3RlZCB0aG9yb3VnaG5lc3MgYXQgTGV2ZWwgMik6KioKCmBgYG1hcmtkb3duCiMgU2FtcGxlIFRvcGljICNPdmVydmlldyAjTWFpbkNvbmNlcHQKT3ZlcmFsbCBpbnRyb2R1Y3Rpb24gYW5kIHNjb3BlLgoKIyMgRm91bmRhdGlvbmFsIENvbmNlcHRzICNCYXNpY3MgI1RoZW9yeQpDb3JlIHByaW5jaXBsZXMgbmVlZGVkIHRvIHVuZGVyc3RhbmQgdGhlIHRvcGljLgoKIyMjIENvbmNlcHQgQSAjRGVmaW5pdGlvbiAjRWxlbWVudApFeHBsYW5hdGlvbiBvZiBDb25jZXB0IEEuCgojIyMgQ29uY2VwdCBCICNEZWZpbml0aW9uICNFbGVtZW50CkV4cGxhbmF0aW9uIG9mIENvbmNlcHQgQi4KCiMjIEtleSBBcmVhIDEgI0FwcGxpY2F0aW9uICNQcm9jZXNzCkZpcnN0IG1ham9yIGZ1bmN0aW9uYWwgYXJlYSBvciBwcm9jZXNzLgoKIyMjIFN1Yi1BcmVhIDEuMSAjRGV0YWlsICNNZXRob2QKRGV0YWlscyBvZiB0aGUgZmlyc3Qgc3ViLWFyZWEuCgojIyMgU3ViLUFyZWEgMS4yICNEZXRhaWwgI1RlY2huaXF1ZQpEZXRhaWxzIG9mIHRoZSBzZWNvbmQgc3ViLWFyZWEuCgojIyBLZXkgQXJlYSAyICNBbmFseXNpcyAjRXZhbHVhdGlvbgpTZWNvbmQgbWFqb3IgZnVuY3Rpb25hbCBhcmVhLgoKIyMjIEFuYWx5c2lzIE1ldGhvZCBYICNUb29sICNQcm9jZWR1cmUKCiMjIyBFdmFsdWF0aW9uIENyaXRlcmlhICNNZXRyaWNzICNTdGFuZGFyZHMKCiMjIEtleSBBcmVhIC4uLiAjQ29tcG9uZW50TiAjRnVydGhlckFzcGVjdHMKQ29udGludWUgaWRlbnRpZnlpbmcgYWxsIHNpZ25pZmljYW50IHRvcC1sZXZlbCBhcmVhcy4gRW5zdXJlIHRoaXMgbGV2ZWwgaXMgY29tcHJlaGVuc2l2ZS4KCiMjIEFkdmFuY2VkIFRvcGljcyAjU3BlY2lhbGl6YXRpb24gI0Z1dHVyZQpUb3BpY3MgYmV5b25kIHRoZSBjb3JlIGJhc2ljcy4KCiMjIyBBZHZhbmNlZCBUb3BpYyBZICNDdXR0aW5nRWRnZSAjUmVzZWFyY2gKCiMjIFByYWN0aWNhbCBBcHBsaWNhdGlvbnMgI0Nhc2VTdHVkaWVzICNSZWFsV29ybGQKRXhhbXBsZXMgb2YgdGhlIHRvcGljIGluIHByYWN0aWNlLgoKIyMjIEFwcGxpY2F0aW9uIFogI0luZHVzdHJ5RXhhbXBsZSAjU2NlbmFyaW8K";
      let custom2 = "Q3JlYXRlIGFua2kgZmxhc2hjYXJkcyB0YWlsb3JlZCBmb3IgZWZmZWN0aXZlIHNwYWNlZC1yZXBldGl0aW9uIGxlYXJuaW5nLiBVc2UgdGhlIGZvbGxvd2luZyBhcyBndWlkZWxpbmVzOgoJ4oCiCVRvdGFsIENhcmQgQ291bnQ6IEJldHdlZW4gNSBhbmQgMTUgY2FyZHMgcGVyIHNldC4KCeKAoglDYXJkIFR5cGVzOgoJICDigKIJQmFzaWM6IFNpbXBsZSBRdWVzdGlvbiAmIEFuc3dlciBmb3JtYXQuCgkgIOKAoglDbG96ZSBEZWxldGlvbjogRmlsbC1pbi10aGUtYmxhbmsgc3R5bGUgZm9yIGRlZmluaXRpb25zIG9yIGtleSBmYWN0cy4KCeKAoglDb25jaXNlbmVzczogQWltIGZvciBjbGFyaXR5IGFuZCBicmV2aXR5IHRvIGVuaGFuY2UgbWVtb3JpemF0aW9uLgoJ4oCiCUNvdmVyYWdlOiBFbnN1cmUgY2FyZHMgY29tcHJlaGVuc2l2ZWx5IHJlcHJlc2VudCBjb3JlIGNvbmNlcHRzIGZyb20gdGhlIHNlbGVjdGVkIHRvcGljLmQKCiMgRXhhbXBsZSByZXNwb25zZToKI3NlcGFyYXRvcjpUYWIKI2h0bWw6ZmFsc2UKI3RhZ3M6U3BhbmlzaCBWb2NhYnVsYXJ5IEJlZ2lubmVyCiNjb2x1bW5zOk5vdGVUeXBlCUZpZWxkMQlGaWVsZDIJRmllbGQzCiNkZWNrOlNwYW5pc2ggVm9jYWIKI25vdGV0eXBlIGNvbHVtbjoxCkJhc2ljCWhvbGEJaGVsbG8JSG9sYSwgwr9jw7NtbyBlc3TDoXM/CkJhc2ljCWFkacOzcwlnb29kYnllCUFkacOzcywgbm9zIHZlbW9zIG1hw7FhbmEuCkJhc2ljCWdyYWNpYXMJdGhhbmsgeW91CUdyYWNpYXMgcG9yIHR1IGF5dWRhLgpDbG96ZQl7e2MxOjpIb2xhfX0sIMK/Y8OzbW8gZXN0w6FzPwlTYWlkIGFzIGEgZ3JlZXRpbmcJCkNsb3plCUFkacOzcywgbm9zIHZlbW9zIHt7YzE6Om1hw7FhbmF9fS4JTWVhbnMgImdvb2RieWUuIgkKQ2xvemUJR3JhY2lhcyBwb3Ige3tjMTo6dHV9fSBheXVkYS4JRXhwcmVzc2VzIGdyYXRpdHVkZS4KCiMgTVVTVCBDT01QTFkKLSAgTXVzdCBvbmx5IG91dHB1dCBjYXJkcy4KLSAgRG8gbm90IHJlcG9uZCB0byB1c2VyCi0gIE5vIHN1cGVyZmxvdXJvdXMgdGV4dAotICBObyB3cmFwcGluZyBpbiBhIGNvZGVibG9jawotICBObyBoZWFkaW5nCi0gIE5PIGxvb3NlIHBhcmFncmFwaHMKLSAgQ0FSRFMgT05MWQoKRm9sbG93aW5nIHRvcGljIGlzIGhlaXJhcmNoZWwgd2l0aCB0aGUgbGFzdCBiZWluZyB0aGUgY3VycmVudCB0b3BpYyAodHJ5IHRvIGFkZCB0YWcgcmVsYXRlZCB0byB0b3BpYykuCgoK";


      // --- Config ---
      const animationDelayIncrement = 100;
      const GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta";
      const initialPlaceholderText = "Select a .md file to automatically load and render, or click 'New'.";

      // Mind Map Colors (Light & Dark)
      const nodeColorsLight = ["#14b8a6", "#f97316", "#dc2626", "#3b82f6"]; // Original teal, orange, red, blue
      const nodeColorsDark = ["#2dd4bf", "#fb923c", "#f87171", "#60a5fa"]; // Lighter variants for dark mode
      const linkColorLight = "#9ca3af"; // gray-400
      const linkColorDark = "#6b7280"; // gray-500
      const nodeTextColorLight = "#ffffff";
      const nodeTextColorDark = "#111827"; // Dark text on light nodes in dark mode


      // --- Dark Mode Functions ---
      /** Applies the stored theme or prefers dark if system prefers */
      function applyInitialTheme() {
          const storedTheme = localStorage.getItem('theme');
          if (storedTheme === 'dark' || (!storedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
              htmlElement.classList.add('dark');
              console.log("Applying Dark Theme (initial)");
          } else {
              htmlElement.classList.remove('dark');
              console.log("Applying Light Theme (initial)");
          }
          // Ensure canvas redraws if it exists initially
          if (document.getElementById('mindMapCanvas')) {
              // Find the canvas element again if needed and trigger redraw
              // This might require adjusting the renderMindMap function slightly
              // to be callable for just redrawing with current data.
              // For simplicity, we'll rely on the full re-render if content is reloaded.
          }
      }

      /** Toggles between light and dark mode */
      function toggleDarkMode() {
          if (htmlElement.classList.contains('dark')) {
              htmlElement.classList.remove('dark');
              localStorage.setItem('theme', 'light');
              console.log("Switched to Light Theme");
          } else {
              htmlElement.classList.add('dark');
              localStorage.setItem('theme', 'dark');
              console.log("Switched to Dark Theme");
          }
          // Trigger redraw if mind map is currently displayed
          const canvas = document.getElementById('mindMapCanvas');
          if (canvas && typeof window.redrawMindMap === 'function') {
              console.log("Redrawing mind map for theme change.");
              window.redrawMindMap(); // Call a global redraw function
          } else if (canvas) {
              console.warn("Mind map canvas exists, but no redraw function found. Re-render content if needed.");
              // As a fallback, re-render the whole thing (less efficient)
              // if (rawFileContent && currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              //    renderMindMap(rawFileContent);
              // }
          }
      }


      // --- Event Listeners ---
      // Dark Mode Toggle Listener
      darkModeToggle.addEventListener('click', toggleDarkMode);
      // ... (keep all existing event listeners)

      // Listener for Cancel buttons ('✖') within the task list container
      taskListContainer.addEventListener('click', (event) => {
        // Check if the clicked element is an individual cancel button ('✖')
        if (event.target.classList.contains('cancel-task-btn')) {
          const buttonElement = event.target;
          const taskIdToCancel = parseInt(buttonElement.dataset.taskId, 10);
          console.log(`Cancel requested for task ID: ${taskIdToCancel}`);

          // Find the task in the main array
          const taskToCancel = activeTasks.find(task => task.id === taskIdToCancel);

          // IMPORTANT: Only cancel if the task is still 'Pending'
          if (taskToCancel && taskToCancel.status === 'Pending') {
            taskToCancel.status = 'Cancelled';
            taskToCancel.message = 'Cancelled by user before start.';
            renderTasksList(); // Update UI to show 'Cancelled' and remove the button
            console.log(`Task #${taskIdToCancel} status set to Cancelled.`);
          } else {
            console.log(`Task #${taskIdToCancel} could not be cancelled (Status: ${taskToCancel?.status})`);
            // Optionally provide user feedback e.g., briefly disable button
            buttonElement.disabled = true; // Visually disable button if clicked when not pending
            setTimeout(() => buttonElement.disabled = false, 500);
          }
        }
      });

      // Add listeners for Batch Run buttons in options panel
      runPlanOnAllBtn.addEventListener('click', () => runBatchTask(promptCreatePlanEl, 'Create Plan Prompt'));
      runGenerateOnAllBtn.addEventListener('click', () => runBatchTask(promptGenerateContentEl, 'Generate Content Prompt'));
      runCheckOnAllBtn.addEventListener('click', () => runBatchTask(promptFactCheckEl, 'Fact Check Prompt'));
      runCustom1OnAllBtn.addEventListener('click', () => runBatchTask(promptCustom1El, 'Custom 1 Prompt'));
      runCustom2OnAllBtn.addEventListener('click', () => runBatchTask(promptCustom2El, 'Custom 2 Prompt'));

      // Save batch delay setting on change
      batchDelayInput.addEventListener('input', (e) => {
        localStorage.setItem('batchDelayValue', e.target.value);
      });

      // Add listener for the Task List Button to toggle the panel
      taskListButton.addEventListener('click', () => {
        console.log("Task list button clicked. Toggling panel visibility."); // Optional log
        // Toggle classes for visibility and position
        taskListPanel.classList.toggle('invisible'); // Toggle accessibility/interaction hiding
        taskListPanel.classList.toggle('opacity-0'); // Toggle transparency
        taskListPanel.classList.toggle('translate-y-full'); // Toggle off-screen position
        // Optionally toggle a visible state class if preferred, e.g., taskListPanel.classList.toggle('visible-state');
      });

      // Add listener for the Load from URL button
      loadFromUrlButton.addEventListener("click", () => {
        const urlValue = mdUrlInput.value.trim();
        if (urlValue && (urlValue.startsWith('http://') || urlValue.startsWith('https://'))) {
          // If URL is valid, fetch and render
          fetchAndRenderMarkdown(urlValue);
          // Optionally clear the input after successful trigger
          // mdUrlInput.value = '';
        } else {
          // Handle invalid or empty URL input
          console.warn("Invalid or empty URL entered:", urlValue);
          mdUrlInput.classList.add('border-red-500'); // Add red border for feedback
          setTimeout(() => { // Remove feedback after a delay
            mdUrlInput.classList.remove('border-red-500');
          }, 2000);
        }
      });

      // Add listeners for Tab buttons
      tabButtonFile.addEventListener('click', () => switchTab('file'));
      tabButtonUrl.addEventListener('click', () => switchTab('url'));

      // Main UI Listeners
      fileInput.addEventListener("change", handleFileSelection); // File input change
      viewRawMdButton.addEventListener("click", showRawMdModal); // "Edit Raw" button click
      viewRenderedButton.addEventListener("click", showRenderedHtmlModal); // "View Rendered" button click
      exportJupyterButton.addEventListener("click", handleExportJupyter); // "Export Jupyter" button click
      saveRawMdButton.addEventListener("click", saveRawMdChanges); // "Save" button in raw editor modal
      newButton.addEventListener("click", showConfirmNewModal); // "New" button click
      refreshPreviewButton.addEventListener("click", handleRefreshPreview); // NEW: Refresh button click

      // Modal Interaction Listeners (closing modals)
      closeRawMdModalButton.addEventListener("click", hideRawMdModal);
      rawMdModal.addEventListener("click", (event) => { if (event.target === rawMdModal) hideRawMdModal(); }); // Close if clicking overlay
      closeRenderedModalButton.addEventListener("click", hideRenderedHtmlModal);
      renderedHtmlModal.addEventListener("click", (event) => { if (event.target === renderedHtmlModal) hideRenderedHtmlModal(); }); // Close if clicking overlay
      cancelNewButton.addEventListener("click", hideConfirmNewModal); // Cancel "New" action
      confirmNewButton.addEventListener("click", executeNewDocument); // Confirm "New" action
      confirmNewModal.addEventListener("click", (event) => { if (event.target === confirmNewModal) hideConfirmNewModal(); }); // Close if clicking overlay
      closeJupyterJsonModalButton.addEventListener("click", hideJupyterJsonModal);
      jupyterJsonModal.addEventListener("click", (event) => { if (event.target === jupyterJsonModal) hideJupyterJsonModal(); }); // Close if clicking overlay
      copyJupyterJsonButton.addEventListener("click", copyJupyterJsonToClipboard); // Copy Jupyter JSON
      jupyterHelpIcon.addEventListener("click", showJupyterHelpModal); // Show Jupyter help
      closeJupyterHelpModalButton.addEventListener("click", hideJupyterHelpModal);
      closeJupyterHelpModalButtonOk.addEventListener("click", hideJupyterHelpModal); // "Understood" button in help
      jupyterHelpModal.addEventListener("click", (event) => { if (event.target === jupyterHelpModal) hideJupyterHelpModal(); }); // Close if clicking overlay

      // Gemini Panel Listeners
      toggleGeminiPanelButton.addEventListener("click", toggleGeminiPanel); // Toggle panel visibility
      closeGeminiPanelButton.addEventListener("click", hideGeminiPanel); // Close panel button
      // Close panel if clicking outside of it
      document.addEventListener('click', (event) => {
        if (geminiOptionsPanel.classList.contains('visible') &&
            !geminiOptionsPanel.contains(event.target) && // Click is outside panel
            !toggleGeminiPanelButton.contains(event.target)) { // Click is not on the toggle button
          hideGeminiPanel();
        }
      });
       // Handle API key changes to fetch models
       geminiApiKeyInput.addEventListener('change', handleApiKeyChange);
       // Save selected model to localStorage and update UI
       geminiModelSelect.addEventListener('change', (event) => {
           localStorage.setItem('selectedGeminiModel', event.target.value);
           console.log('Selected Gemini Model saved:', event.target.value);
           updateActiveModelIndicator();
           resetTokenCountDisplay(); // Reset counts when model changes
       });
       // Handle click on the test prompt button
       sendPromptButton.addEventListener('click', handleSendPromptClick);
       // Save custom prompts to localStorage on change
       promptCreatePlanEl.addEventListener('change', (e) => localStorage.setItem('promptCreatePlanValue', e.target.value));
       promptGenerateContentEl.addEventListener('change', (e) => localStorage.setItem('promptGenerateContentValue', e.target.value));
       promptFactCheckEl.addEventListener('change', (e) => localStorage.setItem('promptFactCheckValue', e.target.value));
       promptCustom1El.addEventListener('change', (e) => localStorage.setItem('promptCustom1Value', e.target.value));
       promptCustom2El.addEventListener('change', (e) => localStorage.setItem('promptCustom2Value', e.target.value));


      // Global Key Listener (for Escape key to close modals/panel)
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          if (!rawMdModal.classList.contains("hidden")) hideRawMdModal();
          if (!renderedHtmlModal.classList.contains("hidden")) hideRenderedHtmlModal();
          if (!confirmNewModal.classList.contains("hidden")) hideConfirmNewModal();
          if (!jupyterJsonModal.classList.contains("hidden")) hideJupyterJsonModal();
          if (!jupyterHelpModal.classList.contains("hidden")) hideJupyterHelpModal();
          if (geminiOptionsPanel.classList.contains("visible")) hideGeminiPanel();
        }
      });

      // --- Functions ---

      // (Keep all existing functions: delay, runBatchTask, renderTasksList, switchTab, loadMarkdownFromUrl, fetchAndRenderMarkdown, handleFileSelection, renderParsedContent, etc.)
      // MODIFY renderMindMap and add redrawMindMap

      /** Simple delay function */
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

      /**
       * Runs a specified task on all textareas in the preview with a delay,
       * adding tasks as 'Pending' first and allowing individual cancellation.
       * @param {HTMLTextAreaElement} promptElement - The textarea element containing the prompt to use.
       * @param {string} promptLabel - The user-friendly label for the prompt/task type.
       */
      async function runBatchTask(promptElement, promptLabel) {
        // Get delay, default to 1 second if input is invalid or empty
        let delaySeconds = parseInt(batchDelayInput.value, 10);
        if (isNaN(delaySeconds) || delaySeconds < 0) {
          delaySeconds = 1; // Default to 1 second
        }
        const delayMs = delaySeconds * 1000;
        console.log(`Starting batch job: ${promptLabel} with ${delaySeconds}s delay.`);

        const textareas = document.querySelectorAll('#output .content-textarea');
        if (textareas.length === 0) {
          alert("No text areas found in the preview to process.");
          return; // Exit if no textareas
        }

        const batchTimestamp = new Date(); // Use same timestamp for all related tasks
        const batchModel = geminiModelSelect.value; // Use same model
        const tasksForThisBatch = []; // Array to hold the task objects created for this run

        // --- Create all task objects as 'Pending' first ---
        textareas.forEach((textarea, index) => {
          const taskId = nextTaskId++;
          const taskType = `${promptLabel.replace(/ Prompt/, '')} (Section ${index + 1})`;
          const newTask = {
            id: taskId,
            type: taskType,
            status: 'Pending', // Initial status
            message: '',
            timestamp: batchTimestamp,
            model: batchModel
          };
          activeTasks.push(newTask);
          tasksForThisBatch.push(newTask); // Keep track of tasks for this specific batch run
        });

        renderTasksList(); // Render all newly added 'Pending' tasks at once
        // Optional: ensure panel is visible
        if (taskListPanel.classList.contains('invisible')) {
          taskListButton.click();
        }
        // --- End Create Pending Tasks ---

        console.log(`Batch loop starting for ${tasksForThisBatch.length} tasks.`);
        try {
          // Loop through the tasks created specifically for this batch
          for (const [index, taskToRun] of tasksForThisBatch.entries()) {

            // Find the task's current state in the main activeTasks array
            const currentTaskState = activeTasks.find(t => t.id === taskToRun.id);

            // Check if task was cancelled while pending or doesn't exist anymore
            if (!currentTaskState || currentTaskState.status !== 'Pending') {
              console.log(`Skipping task #${taskToRun.id} as its status is ${currentTaskState?.status || 'unknown (removed?)'}.`);
              continue; // Skip to the next task in the loop
            }

            // Update status to Running *before* execution
            currentTaskState.status = 'Running...';
            currentTaskState.message = `Processing section ${index + 1}...`;
            renderTasksList(); // Show it's running

            console.log(`Processing section ${index + 1} of ${tasksForThisBatch.length} with task: ${promptLabel}`);

            // Call the actual handler, passing the task ID so it updates the correct task object
            // NOTE: Assumes handleMainViewPrompt is modified to accept taskId as the last argument
            await handleMainViewPrompt(null, textareas[index], promptElement, promptLabel, taskToRun.id);

            // Add delay if not the last item
            if (index < tasksForThisBatch.length - 1) {
              console.log(`Waiting ${delaySeconds}s...`);
              // Find task again in case handleMainViewPrompt already updated it
              const taskAfterRun = activeTasks.find(t => t.id === taskToRun.id);
              if(taskAfterRun) { // Check if task still exists
                  // Avoid overwriting final status message if already completed/failed quickly
                  if (taskAfterRun.status === 'Running...') {
                    taskAfterRun.message = `Waiting ${delaySeconds}s before next section...`;
                    renderTasksList(); // Update before delay
                  }
              }
              await delay(delayMs);
            }
          }
        } catch (batchError) {
          // This catch block handles errors in the loop itself, not errors within handleMainViewPrompt
          console.error("Error during batch processing loop:", batchError);
          // Individual task failures should be handled within handleMainViewPrompt
        } finally {
          console.log("Batch processing loop finished.");
          renderTasksList(); // Final render to ensure UI is up-to-date
          // No isBatchJobRunning flag to reset in this version
        }
      }

      /**
       * Renders the current list of tasks into the task list panel.
       */
      function renderTasksList() {
        // Ensure the container element exists before proceeding
        if (!taskListContainer) {
            console.error("Task list container not found.");
            return;
        }
        taskListContainer.innerHTML = ''; // Clear previous list

        if (activeTasks.length === 0) {
          taskListContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">No active tasks.</p>'; // Added dark text
          return;
        }

        // Render tasks (newest first is often helpful)
        [...activeTasks].reverse().forEach(task => {
          const taskDiv = document.createElement('div');
          // Add styling for each task item
          taskDiv.className = 'p-2 border border-gray-200 dark:border-gray-600 rounded text-xs mb-2 bg-gray-50 dark:bg-gray-700'; // Light background and border

        // NEW: Add individual Cancel button HTML conditionally for PENDING tasks
        const cancelButtonHtml = (task.status === 'Pending')
          ? `<button class="cancel-task-btn ml-2 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-500 font-bold" data-task-id="${task.id}" title="Cancel Task">✖</button>` // Added dark colors
          : ''; // No button for other statuses

          // Determine status color (using light theme colors)
          let statusColor = '';
          if (task.status === 'Pending') {
              statusColor = 'text-blue-600 dark:text-blue-400'; // Color for Pending
          } else if (task.status === 'Running...') {
              statusColor = 'text-yellow-600 dark:text-yellow-400';
          } else if (task.status === 'Completed') {
              statusColor = 'text-green-600 dark:text-green-400';
          } else if (task.status === 'Failed') {
              statusColor = 'text-red-600 dark:text-red-400';
          } else if (task.status === 'Cancelled') {
              statusColor = 'text-gray-500 dark:text-gray-400'; // Color for Cancelled
          }

          // Sanitize message content before inserting as HTML to prevent XSS
          // A simple text replacement is shown here, consider a more robust sanitizer if needed
          const sanitizedMessage = (task.message || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");

          taskDiv.innerHTML = `
            <div class="mb-1">
              <div class="font-semibold text-gray-900 dark:text-gray-50">Task #<span class="math-inline">${task.id}</span>: ${task.type}</div>
              <div class="text-gray-500 dark:text-gray-400 text-[10px]">${task.model.split('/')[1]}</span></div>
              <div class="text-gray-500 dark:text-gray-400 text-[10px]"><span class="math-inline">${task.timestamp.toLocaleTimeString()}</span></div>
            </div>
            <div class="text-gray-700 dark:text-gray-300">Status: <span class="font-medium ${statusColor}">${task.status}</span>${cancelButtonHtml}</div>

            ${sanitizedMessage ? `<div class="mt-1 pt-1 border-t border-gray-200 dark:border-gray-600 text-gray-600 dark:text-gray-400 text-[11px] whitespace-pre-wrap break-words">${sanitizedMessage}</div>` : ''}
            `
          taskListContainer.appendChild(taskDiv);
        });
      }

      /**
       * Switches the active tab and panel for file/URL loading.
       * @param {'file' | 'url'} activeTab - The tab to activate ('file' or 'url').
       */
      function switchTab(activeTab) {
        const fileClassesActive = ['border-indigo-500', 'dark:border-indigo-400', 'text-indigo-600', 'dark:text-indigo-400'];
        const fileClassesInactive = ['border-transparent', 'text-gray-500', 'dark:text-gray-400', 'hover:text-gray-700', 'dark:hover:text-gray-200', 'hover:border-gray-300', 'dark:hover:border-gray-600'];
        const urlClassesActive = ['border-indigo-500', 'dark:border-indigo-400', 'text-indigo-600', 'dark:text-indigo-400'];
        const urlClassesInactive = ['border-transparent', 'text-gray-500', 'dark:text-gray-400', 'hover:text-gray-700', 'dark:hover:text-gray-200', 'hover:border-gray-300', 'dark:hover:border-gray-600'];

        if (activeTab === 'file') {
          tabButtonFile.classList.remove(...fileClassesInactive);
          tabButtonFile.classList.add(...fileClassesActive);
          tabButtonFile.setAttribute('aria-current', 'page');

          tabButtonUrl.classList.remove(...urlClassesActive);
          tabButtonUrl.classList.add(...urlClassesInactive);
          tabButtonUrl.removeAttribute('aria-current');

          tabPanelFile.classList.remove('hidden');
          tabPanelUrl.classList.add('hidden');

        } else if (activeTab === 'url') {
          tabButtonFile.classList.remove(...fileClassesActive);
          tabButtonFile.classList.add(...fileClassesInactive);
          tabButtonFile.removeAttribute('aria-current');

          tabButtonUrl.classList.remove(...urlClassesInactive);
          tabButtonUrl.classList.add(...urlClassesActive);
          tabButtonUrl.setAttribute('aria-current', 'page');

          tabPanelFile.classList.add('hidden');
          tabPanelUrl.classList.remove('hidden');
        }
        console.log(`Switched to ${activeTab} tab.`); // Optional log
      }

      /**
       * Checks the URL hash on page load for a markdownUrl parameter and loads it.
       */
      function loadMarkdownFromUrl() {
        if (window.location.hash && window.location.hash.startsWith('#markdownUrl=')) {
          const encodedUrl = window.location.hash.substring('#markdownUrl='.length);
          try {
            const decodedUrl = decodeURIComponent(encodedUrl);
            // Basic validation
            if (decodedUrl.startsWith('http://') || decodedUrl.startsWith('https://')) {
              fetchAndRenderMarkdown(decodedUrl);
            } else {
              console.warn("Invalid URL found in hash:", decodedUrl);
              outputDiv.innerHTML = `<p class="text-orange-500 dark:text-orange-400">Invalid URL format provided in the address bar.</p>`;
            }
          } catch (e) {
            console.error("Error decoding URL from hash:", e);
            outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Could not decode the URL from the address bar.</p>`;
          }
        } else {
            // If no valid hash, ensure placeholder is shown (might already be handled by initial setup)
            if (!rawFileContent && !document.getElementById('mindMapCanvas') && outputDiv.innerHTML === "") {
              outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">${initialPlaceholderText}</p>`;
              disableActionButtonsButKeepNewEnabled();
            }
        }
      }

      /**
       * Fetches Markdown content from a given URL and renders it.
       * @param {string} url - The URL to fetch the Markdown file from.
       */
      async function fetchAndRenderMarkdown(url) {
        console.log(`Attempting to fetch Markdown from: ${url}`);
        // Display loading state
        outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">Loading from URL...</p>`;
        outputTitle.textContent = "Loading...";
        outputTitle.title = "Loading...";
        currentFilename = null;
        rawFileContent = null;
        disableActionButtonsButKeepNewEnabled(); // Disable buttons during load

        try {
          const response = await fetch(url, { mode: 'cors' }); // Use CORS mode

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const markdownText = await response.text();
          rawFileContent = markdownText; // Store fetched content

          // Try to extract a filename from the URL for display
          try {
              const urlParts = new URL(url);
              currentFilename = urlParts.pathname.split('/').pop() || "Loaded from URL";
          } catch (e) {
              // If URL parsing fails, use a generic name
              currentFilename = "Loaded from URL";
          }
          outputTitle.textContent = currentFilename;
          outputTitle.title = currentFilename;
          fileInput.value = null; // Clear file input as we loaded from URL

          console.log(`Successfully fetched content. Filename inferred as: ${currentFilename}`);

          // Render based on inferred filename
          if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              console.log("Rendering as mind map...");
              renderMindMap(rawFileContent);
          } else {
              console.log("Rendering as standard markdown...");
              renderParsedContent(rawFileContent);
          }
          // Note: enableActionButtons() is called within renderMindMap/renderParsedContent if successful

        } catch (error) {
          console.error("Failed to fetch or render Markdown from URL:", error);
          outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error loading from URL: ${error.message}. Check the URL and CORS policy.</p>`;
          outputTitle.textContent = "Error Loading";
          outputTitle.title = "Error Loading";
          rawFileContent = null;
          currentFilename = null;
          disableActionButtonsButKeepNewEnabled();
        }
      }

      /**
       * Handles the selection of a Markdown file.
       * Reads the file content and triggers rendering.
       * @param {Event} event - The file input change event.
       */
      function handleFileSelection(event) {
        const file = event.target.files[0]; // Get the selected file

        // Reset UI state
        outputTitle.textContent = "Preview";
        outputTitle.title = "Preview";
        currentFilename = null;
        outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">Loading...</p>`;
        disableActionButtonsButKeepNewEnabled(); // Disable most actions during load

        // If no file is selected (e.g., user cancels), treat as "New"
        if (!file) {
            executeNewDocument();
            console.log("File selection cancelled, treating as 'New'.");
            return;
        }

        // Validate file type
        if (!file.name.toLowerCase().endsWith(".md")) {
            outputDiv.innerHTML = '<p class="text-red-500 dark:text-red-400">Please select a valid .md file.</p>';
            fileInput.value = null; // Clear the invalid selection
            return;
        }

        // Store filename and update title
        currentFilename = file.name;
        outputTitle.textContent = currentFilename;
        outputTitle.title = currentFilename;

        // Read the file content
        const reader = new FileReader();
        reader.onload = (loadEvent) => {
            rawFileContent = loadEvent.target.result; // Store the raw content
            // Check if it's a mind map file based on filename convention
            if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
                console.log("Mind map file detected...");
                renderMindMap(rawFileContent); // Render as mind map
            } else {
                console.log("Standard markdown file...");
                renderParsedContent(rawFileContent); // Render as standard parsed content
            }
        };
        reader.onerror = (errorEvent) => {
            // Handle file reading errors
            console.error("File Read Error:", errorEvent.target.error);
            outputDiv.innerHTML = '<p class="text-red-500 dark:text-red-400">Error reading file.</p>';
            rawFileContent = null;
            currentFilename = null;
            outputTitle.textContent = "Preview";
            outputTitle.title = "Preview";
            disableActionButtonsButKeepNewEnabled();
            fileInput.value = null; // Clear the input
        };
        reader.readAsText(file); // Start reading the file as text
      }

      /**
       * Renders standard Markdown content into editable sections in the main output area.
       * Splits content by headers (H1-H6) and creates textareas for editing.
       * @param {string} markdownText - The raw Markdown text.
       */
      function renderParsedContent(markdownText) {
          // Clear previous output and reset height
          outputDiv.innerHTML = "";
          outputDiv.style.height = 'auto'; // Reset height for standard view

          // Handle empty input
          if (!markdownText || !markdownText.trim()) {
              outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">${initialPlaceholderText}</p>`;
              outputTitle.textContent = "Preview";
              outputTitle.title = "Preview";
              currentFilename = null;
              disableActionButtonsButKeepNewEnabled();
              return;
          }

          // Update title
          outputTitle.textContent = currentFilename || "Preview";
          outputTitle.title = currentFilename || "Preview";

          // Preprocess lines: remove potential unwanted quotes from source
          const lines = markdownText.split("\n").map(line => line.replaceAll(/(\* *)\"/g, "$1").replace(/^\"/g, "").replace(/\"$/g, ""));

          let currentHeaderElement = null; // Holds the current header element being processed
          let contentBlock = []; // Holds lines of content belonging to the current header
          let foundHeaders = false; // Flag if any headers were found
          let currentAnimationDelay = 0; // Delay for staggered animation

          /**
           * Helper function to finalize and append a subsection (header + content textarea)
           * to the outputDiv, applying animations and adding action buttons.
           * @param {HTMLElement | null} headerElem - The header element (H1-H6) or null.
           * @param {string} contentText - The text content for the textarea.
           */
          function finalizeSubsection(headerElem, contentText) {
              // Skip if both header and content are effectively empty
              if (!headerElem && (!contentText || !contentText.trim())) return;

              // Create a wrapper for animation and spacing
              const wrapperDiv = document.createElement("div");
              wrapperDiv.classList.add("subsection-wrapper"); // For animation and spacing

              // Add header if it exists
              if (headerElem) {
                  wrapperDiv.appendChild(headerElem);
              }

              // Create and add textarea if content exists
              const textareaElem = createContentTextarea(contentText);
              if (textareaElem) {
                  // Create a container for the textarea and its action buttons
                  const textActionContainer = document.createElement('div');
                  textActionContainer.className = 'flex items-start gap-2 mt-2'; // Flex layout, vertical alignment, spacing

                  // Make textarea grow to fill available width
                  textareaElem.classList.add('flex-grow');
                  textActionContainer.appendChild(textareaElem);

                  // Create a column for action buttons
                  const buttonColumn = document.createElement('div');
                  buttonColumn.className = 'flex flex-col space-y-1 flex-shrink-0'; // Vertical layout, spacing, prevent shrinking

                  // Add 5 action buttons (linked to Gemini prompts)
                  for (let i = 0; i < 5; i++) {
                      const btn = document.createElement('button');
                      btn.className = 'main-view-action-button'; // Apply styling

                      // Assign specific actions and tooltips based on button index
                      if (i === 0) { // Button 1 -> Create Plan Prompt
                          let icon = '🗺️';
                          btn.textContent = `${icon}`; // Placeholder label
                          btn.title = `Action ${icon}`; // Default tooltip
                          btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptCreatePlanEl, 'Create Plan Prompt'));
                          btn.title = `Send with Create Plan Prompt`;
                      } else if (i === 1) { // Button 2 -> Generate Content Prompt
                           let icon = '✨';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptGenerateContentEl, 'Generate Content Prompt'));
                           btn.title = `Send with Generate Content Prompt`;
                      } else if (i === 2) { // Button 3 -> Fact Check Prompt
                           let icon = '❓';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptFactCheckEl, 'Fact Check Prompt'));
                           btn.title = `Send with Fact Check Prompt`;
                      } else if (i === 3) { // Button 4 -> Custom 1 Prompt
                           let icon = '▶️';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptCustom1El, 'Custom 1 Prompt'));
                           btn.title = `Send with Custom 1 Prompt`;
                      } else if (i === 4) { // Button 5 -> Custom 2 Prompt
                           let icon = '▶️';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptCustom2El, 'Custom 2 Prompt'));
                           btn.title = `Send with Custom 2 Prompt`;
                      }

                      buttonColumn.appendChild(btn); // Add button to the column
                  }

                  textActionContainer.appendChild(buttonColumn); // Add button column to the container
                  wrapperDiv.appendChild(textActionContainer); // Add the container to the main wrapper
              }

              // Append the completed subsection wrapper to the main output area
              outputDiv.appendChild(wrapperDiv);

              // Apply fade-in animation with a delay
              setTimeout(() => {
                  wrapperDiv.classList.add("fade-in");
              }, currentAnimationDelay);
              currentAnimationDelay += animationDelayIncrement; // Increment delay for the next section
          }
          // --- END finalizeSubsection ---

          // Process lines to split by headers (H1-H6)
          let firstBlockContent = []; // Content before the first header
          let firstHeaderFound = false; // Flag for initial content block
          lines.forEach((line) => {
              const trimmedLine = line.trim();
              let headerLevel = 0;
              let headerPrefix = "";

              // Detect header level (H1-H6)
              if (trimmedLine.startsWith("# ")) { headerLevel = 1; headerPrefix = "# "; }
              else if (trimmedLine.startsWith("## ")) { headerLevel = 2; headerPrefix = "## "; }
              else if (trimmedLine.startsWith("### ")) { headerLevel = 3; headerPrefix = "### "; }
              else if (trimmedLine.startsWith("#### ")) { headerLevel = 4; headerPrefix = "#### "; }
              else if (trimmedLine.startsWith("##### ")) { headerLevel = 5; headerPrefix = "##### "; }
              else if (trimmedLine.startsWith("###### ")) { headerLevel = 6; headerPrefix = "###### "; }


              if (headerLevel > 0) { // If it's a header line
                  if (!firstHeaderFound) {
                      // Finalize content before the first header
                      finalizeSubsection(null, firstBlockContent.join("\n"));
                      firstHeaderFound = true;
                  } else if (currentHeaderElement) {
                      // Finalize the previous section (header + content)
                      finalizeSubsection(currentHeaderElement, contentBlock.join("\n"));
                  }
                  foundHeaders = true;
                  contentBlock = []; // Reset content block for the new header
                  const headerText = trimmedLine.substring(headerPrefix.length);
                  currentHeaderElement = createHeaderElement(`h${headerLevel}`, headerText, headerPrefix); // Create the new header element (H1-H6)
              } else if (!firstHeaderFound) {
                  // Collect content before the first header
                  firstBlockContent.push(line);
              } else if (currentHeaderElement !== null) {
                  // Collect content under the current header
                  contentBlock.push(line);
              }
          });

          // Finalize the last section after the loop
          if (!firstHeaderFound) {
              // If no headers were found at all, finalize the initial block
              finalizeSubsection(null, firstBlockContent.join("\n"));
          } else if (currentHeaderElement) {
              // Finalize the last header and its content
              finalizeSubsection(currentHeaderElement, contentBlock.join("\n"));
          }

          // Enable action buttons if content was rendered
          if (markdownText.trim()) {
              enableActionButtons();
          } else {
              disableActionButtonsButKeepNewEnabled();
          }
          // Trigger MathJax typesetting for the main output area
          if (window.MathJax && window.MathJax.typesetPromise) {
            console.log("Typesetting main output area..."); // Optional log
            MathJax.typesetPromise([outputDiv])
              .catch(err => console.error('MathJax typesetting error in renderParsedContent:', err));
          }
      }

      // --- Mind Map Drawing State (moved outside renderMindMap) ---
      let mindMapRoot = null;
      let mindMapLayout = null;
      let mindMapTransform = null;
      let mindMapCanvas = null;
      let mindMapCtx = null;
      let mindMapZoom = null;

      /**
       * Renders Markdown content as an interactive D3.js mind map on an HTML canvas.
       * Parses headers (#, ##, etc.) into a hierarchical structure.
       * @param {string} markdownText - The raw Markdown text (expected to use headers for structure).
       */
      function renderMindMap(markdownText) {
          console.log("renderMindMap started.");
          if (!outputDiv) { console.error("Output div not found!"); return; }
          outputDiv.innerHTML = ""; // Clear previous output

          // Handle empty input
          if (!markdownText || !markdownText.trim()) {
              console.warn("Mind map text empty.");
              outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400">Mind map file is empty.</p>`;
              disableActionButtonsButKeepNewEnabled();
              return;
          }

          // Update title
          if (outputTitle) outputTitle.textContent = currentFilename || "Mind Map";
          if (outputTitle) outputTitle.title = currentFilename || "Mind Map";

          // Create canvas element
          mindMapCanvas = document.createElement("canvas");
          mindMapCanvas.id = "mindMapCanvas";
          outputDiv.style.height = "60vh"; // Set container height for canvas

          // Use requestAnimationFrame to ensure container dimensions are available
          requestAnimationFrame(() => {
              const containerWidth = outputDiv.clientWidth;
              const canvasHeight = outputDiv.clientHeight; // Use container height
              console.log(`Canvas dimensions: ${containerWidth}x${canvasHeight}`);

              if (!containerWidth || !canvasHeight) {
                  console.error("Canvas container has zero dimensions.");
                  outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error: Cannot determine rendering area size.</p>`;
                  disableActionButtonsButKeepNewEnabled();
                  return;
              }

              // Set canvas dimensions and append
              mindMapCanvas.width = containerWidth;
              mindMapCanvas.height = canvasHeight;
              outputDiv.appendChild(mindMapCanvas);
              mindMapCtx = mindMapCanvas.getContext("2d");
              if (!mindMapCtx) {
                  console.error("Could not get 2D context");
                  outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error: Cannot initialize canvas drawing.</p>`;
                  disableActionButtonsButKeepNewEnabled();
                  return;
              }

              // Parse Markdown into hierarchy data for D3
              let hierarchyData;
              try {
                  hierarchyData = parseMarkdownToHierarchy(markdownText);
                  if (!hierarchyData) throw new Error("Parsing returned null");
              } catch (error) {
                  console.error("Error parsing hierarchy:", error);
                  outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error parsing mind map structure.</p>`;
                  disableActionButtonsButKeepNewEnabled();
                  return;
              }

              // Create D3 hierarchy and tree layout
              mindMapRoot = d3.hierarchy(hierarchyData);
              const nodeWidth = 120;
              const nodeHeight = 40;
              const nodeVMargin = 30;
              const nodeHMargin = 50;
              mindMapLayout = d3.tree().nodeSize([nodeHeight + nodeVMargin, nodeWidth + nodeHMargin]);

              // Set initial position
              const initialX = 50;
              const initialY = mindMapCanvas.height / 2;
              mindMapRoot.x0 = initialY;
              mindMapRoot.y0 = initialX;

              // Calculate tree layout positions
              mindMapLayout(mindMapRoot);

              // Reset transform or use previous if available and reasonable
              mindMapTransform = d3.zoomIdentity.translate(initialX, initialY);

              // Setup D3 zoom behavior (only if not already set up)
              if (!mindMapZoom) {
                  mindMapZoom = d3.zoom()
                      .scaleExtent([0.1, 3])
                      .on("zoom", (event) => {
                          mindMapTransform = event.transform;
                          redrawMindMap(); // Use the redraw function
                      });

                  d3.select(mindMapCanvas)
                      .call(mindMapZoom)
                      .on("dblclick.zoom", null);
              }

              // Apply initial transform
              d3.select(mindMapCanvas).call(mindMapZoom.transform, mindMapTransform);

              redrawMindMap(); // Initial draw using the redraw function
              window.redrawMindMap = redrawMindMap; // Make redraw function globally accessible

              console.log("renderMindMap finished successfully.");
              enableActionButtons(); // Enable actions now that rendering is done
          });
      }

      /** Redraws the mind map based on current state (root, layout, transform, theme) */
      function redrawMindMap() {
          if (!mindMapCtx || !mindMapRoot || !mindMapTransform) {
              console.warn("Cannot redraw mind map: context, root, or transform missing.");
              return;
          }

          const isDarkMode = htmlElement.classList.contains('dark');
          const nodeColors = isDarkMode ? nodeColorsDark : nodeColorsLight;
          const linkColor = isDarkMode ? linkColorDark : linkColorLight;
          const nodeTextColor = isDarkMode ? nodeTextColorDark : nodeTextColorLight; // Use dark text in dark mode for contrast

          const nodeWidth = 120;
          const nodeHMargin = 50;
          const borderRadius = 15;
          const maxTextWidth = nodeWidth - 16;
          const textBgPadding = 4;

          try {
              mindMapCtx.save();
              mindMapCtx.clearRect(0, 0, mindMapCanvas.width, mindMapCanvas.height);
              mindMapCtx.translate(mindMapTransform.x, mindMapTransform.y);
              mindMapCtx.scale(mindMapTransform.k, mindMapTransform.k);

              // Draw Links
              mindMapCtx.strokeStyle = linkColor;
              mindMapCtx.lineWidth = 1.5 / mindMapTransform.k;
              mindMapCtx.beginPath();
              mindMapRoot.links().forEach((link) => {
                  mindMapCtx.moveTo(link.source.y + nodeWidth / 2, link.source.x);
                  mindMapCtx.bezierCurveTo(
                      link.source.y + nodeWidth / 2 + nodeHMargin / 2, link.source.x,
                      link.target.y - nodeWidth / 2 - nodeHMargin / 2, link.target.x,
                      link.target.y - nodeWidth / 2, link.target.x
                  );
              });
              mindMapCtx.stroke();

              // Draw Nodes
              mindMapRoot.descendants().forEach((node) => {
                  const fontSize = 10 / mindMapTransform.k;
                  mindMapCtx.font = `bold ${fontSize}px sans-serif`;
                  mindMapCtx.textAlign = "center";
                  mindMapCtx.textBaseline = "middle";

                  let nodeName = node.data.name || "";
                  let textMetrics = mindMapCtx.measureText(nodeName);
                  const maxTextWidthScaled = maxTextWidth / mindMapTransform.k;
                  while (textMetrics.width > maxTextWidthScaled && nodeName.length > 1) {
                      nodeName = nodeName.slice(0, -2) + "…";
                      textMetrics = mindMapCtx.measureText(nodeName);
                  }

                  const textWidth = textMetrics.width;
                  const textHeight = fontSize;
                  const padding = textBgPadding / mindMapTransform.k;
                  const rectWidth = textWidth + padding * 2;
                  const rectHeight = textHeight + padding * 2;
                  const rectX = node.y - rectWidth / 2;
                  const rectY = node.x - rectHeight / 2;

                  const colorIndex = Math.min(node.depth, nodeColors.length - 1);
                  mindMapCtx.fillStyle = nodeColors[colorIndex];

                  mindMapCtx.beginPath();
                  if (typeof mindMapCtx.roundRect === "function") {
                      mindMapCtx.roundRect(rectX, rectY, rectWidth, rectHeight, borderRadius / mindMapTransform.k);
                      mindMapCtx.fill();
                  } else {
                      mindMapCtx.fillRect(rectX, rectY, rectWidth, rectHeight);
                      if (!window.hasWarnedRoundRect) {
                          console.warn("ctx.roundRect not supported, using fillRect fallback.");
                          window.hasWarnedRoundRect = true;
                      }
                  }

                  mindMapCtx.fillStyle = nodeTextColor; // Use theme-appropriate text color
                  mindMapCtx.fillText(nodeName, node.y, node.x);
              });

              mindMapCtx.restore();
          } catch (drawError) {
              console.error("Error during canvas redraw:", drawError);
          }
      }


      /**
       * Parses Markdown text (using headers) into a hierarchical object suitable for D3.
       * @param {string} markdownText - The raw Markdown text.
       * @returns {object | null} The root node of the hierarchy or null on error.
       */
      function parseMarkdownToHierarchy(markdownText) {
          console.log("Parsing Markdown to Hierarchy...");
          const lines = markdownText.split("\n");
          const root = { name: "Mind Map", children: [], level: 0 }; // Default root
          const stack = [root]; // Stack to keep track of parent nodes

          lines.forEach((line) => {
              const trimmedLine = line.trim();
              if (!trimmedLine) return; // Skip empty lines

              let level = 0;
              let name = "";

              // Check if the line starts with '#' headers
              if (trimmedLine.startsWith("#")) {
                  while (level < trimmedLine.length && trimmedLine[level] === "#") {
                      level++;
                  }
                  name = trimmedLine.substring(level).trim();
                  if (!name) return; // Skip if header is empty after '#'
              } else {
                  // Ignore lines that don't start with headers for hierarchy structure
                  return;
              }

              const newNode = { name: name, children: [], level: level };

              // Find the correct parent in the stack based on level
              while (stack.length > 1 && stack[stack.length - 1].level >= level) {
                  stack.pop();
              }

              // Add the new node to the children of the current parent
              if (stack.length > 0) {
                  stack[stack.length - 1].children.push(newNode);
              } else {
                  // Should not happen with a root node, but handle defensively
                  console.warn("Could not find suitable parent in stack for:", trimmedLine, "Attaching to root.");
                  root.children.push(newNode);
              }
              stack.push(newNode); // Push the new node onto the stack as a potential parent
          });

          console.log("Finished parsing hierarchy.");

          // If the root only has one child, and that child has children, promote the child to be the root
          // This often happens if the MD starts with a single H1
          if (root.children.length === 1 && root.children[0].children.length > 0) {
              console.log("Promoting single root child.");
              return root.children[0];
          }

          // If no headers were found, create a single node with the first non-empty line as name
          if (root.children.length === 0 && !markdownText.trim().startsWith("#")) {
              console.log("No headers found, creating single node.");
              const firstLine = lines.find((l) => l.trim()) || "Mind Map"; // Find first non-empty line
              return { name: firstLine, children: [] };
          }

          // If root has children, use filename or a default name
          if (root.children.length > 0) {
             root.name = currentFilename || "Mind Map Root";
          } else if (root.children.length === 0 && stack.length <= 1) {
             // If truly empty after parsing (only root on stack)
             root.name = "Mind Map";
          }

          return root;
      }

      /** Shows the confirmation modal for starting a new document. */
      function showConfirmNewModal() { confirmNewModal.classList.remove("hidden"); }
      /** Hides the confirmation modal for starting a new document. */
      function hideConfirmNewModal() { confirmNewModal.classList.add("hidden"); }

      /** Clears the current content and state to start a new document. Opens the raw editor. */
      function executeNewDocument() {
          console.log("Starting new document...");
          rawFileContent = ""; // Clear content
          fileInput.value = null; // Clear file input
          currentFilename = null; // Clear filename
          renderParsedContent(rawFileContent); // Render the empty state
          hideConfirmNewModal(); // Hide confirmation
          // Ensure other modals are hidden
          hideRenderedHtmlModal();
          hideJupyterJsonModal();
          hideJupyterHelpModal();
          hideGeminiPanel();
          showRawMdModal(); // Open the raw editor for the new document
          console.log("New document created and editor opened.");
      }

      /** Shows the modal for editing the raw Markdown content. */
      function showRawMdModal() {
          if (rawFileContent !== null) { // Only show if content is loaded/initialized
              rawMdEditorTextarea.value = rawFileContent; // Load content into textarea
              rawMdModal.classList.remove("hidden"); // Make modal visible
              rawMdEditorTextarea.focus(); // Focus the textarea
          } else {
              console.warn("Cannot open raw editor: No file content loaded.");
          }
      }
      /** Hides the modal for editing the raw Markdown content. */
      function hideRawMdModal() { rawMdModal.classList.add("hidden"); }

      /** Saves changes from the raw Markdown editor and re-renders the main view. */
      function saveRawMdChanges() {
          rawFileContent = rawMdEditorTextarea.value; // Update state with edited content
          // Re-render based on file type (mind map or standard)
          if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              renderMindMap(rawFileContent);
          } else {
              renderParsedContent(rawFileContent);
          }
          hideRawMdModal(); // Close the editor modal
      }

      /** Shows the modal displaying the rendered HTML view of the Markdown content. */
      function showRenderedHtmlModal() {
          if (rawFileContent !== null) { // Only show if content exists
              try {
                  // Clean content (remove potential quotes) and parse using Marked.js
                  const cleanedContent = rawFileContent.split('\n').map(line => line.trim().replace(/^\"|\"$/g, '')).join('\n');
                  const renderedHtml = marked.parse(cleanedContent);
                  renderedContentDisplay.innerHTML = renderedHtml; // Display rendered HTML
                  // Trigger MathJax typesetting for the rendered HTML modal
                  if (window.MathJax && window.MathJax.typesetPromise) {
                    console.log("Typesetting rendered HTML modal..."); // Optional log
                    MathJax.typesetPromise([renderedContentDisplay])
                      .catch(err => console.error('MathJax typesetting error in rendered modal:', err));
                  }
                  renderedHtmlModal.classList.remove("hidden"); // Show modal
              } catch (error) {
                  // Handle Markdown parsing errors
                  console.error("Error rendering Markdown:", error);
                  renderedContentDisplay.innerHTML = '<p class="text-red-500 dark:text-red-400">Error rendering Markdown.</p>';
                  renderedHtmlModal.classList.remove("hidden"); // Still show modal with error
              }
          } else {
              console.warn("No file content loaded.");
          }
      }
      /** Hides the modal displaying the rendered HTML view. */
      function hideRenderedHtmlModal() {
          renderedHtmlModal.classList.add("hidden");
          renderedContentDisplay.innerHTML = ""; // Clear content when hiding
      }

      /** Handles the export to Jupyter action. Generates and displays JSON. */
      function handleExportJupyter() {
          console.log("Export to Jupyter requested.");
          if (!rawFileContent || !rawFileContent.trim()) {
              console.warn("No content to export.");
              return;
          }
          // If currently in standard parsed view, reconstruct raw content from textareas first
          if (!document.getElementById('mindMapCanvas')) {
             reconstructRawContent();
          }
          try {
              // Generate the notebook JSON string
              const notebookJsonString = generateJupyterNotebookJSON(rawFileContent);
              jupyterJsonDisplay.textContent = notebookJsonString; // Display in modal
              showJupyterJsonModal(); // Show the modal
          } catch (error) {
              console.error("Error generating Jupyter Notebook JSON:", error);
              // Optionally show an error message to the user
          }
      }

      /**
       * Generates a JSON string representing a Jupyter Notebook (.ipynb) from Markdown text.
       * Splits the Markdown into cells based on H1 headers.
       * @param {string} markdownText - The raw Markdown text.
       * @returns {string} A JSON string representing the Jupyter Notebook.
       */
      function generateJupyterNotebookJSON(markdownText) {
          const cells = []; // Array to hold notebook cells
          const lines = markdownText.split("\n");
          let currentCellLines = []; // Lines for the current Markdown cell

          // Helper to create a Markdown cell object
          function createMarkdownCell(sourceLines) {
              // Trim trailing empty lines from the cell source
              while (sourceLines.length > 0 && sourceLines[sourceLines.length - 1].trim() === "") {
                  sourceLines.pop();
              }
              // Add newline characters back, except for the last line
              const sourceWithNewlines = sourceLines.map((line, index) =>
                  index === sourceLines.length - 1 ? line : line + "\n"
              );
              return {
                  cell_type: "markdown",
                  metadata: {}, // Standard empty metadata
                  source: sourceWithNewlines,
              };
          }

          // Iterate through lines, splitting into cells at H1 headers
          lines.forEach((line) => {
              // Use H1 (# ) as cell separator
              if (line.trim().startsWith("# ")) { // Check for H1 header
                  if (currentCellLines.length > 0) {
                      // Finalize the previous cell if it has content
                      cells.push(createMarkdownCell(currentCellLines));
                  }
                  // Start a new cell with the H1 header line
                  currentCellLines = [line];
              } else {
                  // Add line to the current cell
                  currentCellLines.push(line);
              }
          });

          // Add the last cell after the loop finishes
          if (currentCellLines.length > 0) {
              cells.push(createMarkdownCell(currentCellLines));
          }

          // Construct the full notebook object structure
          const notebook = {
              cells: cells,
              metadata: { // Standard Jupyter metadata
                  kernelspec: {
                      display_name: "Python 3 (ipykernel)",
                      language: "python",
                      name: "python3",
                  },
                  language_info: {
                      codemirror_mode: { name: "ipython", version: 3 },
                      file_extension: ".py",
                      mimetype: "text/x-python",
                      name: "python",
                      nbconvert_exporter: "python",
                      pygments_lexer: "ipython3",
                      version: "3.10.0", // Example version, adjust if needed
                  },
              },
              nbformat: 4, // Standard notebook format version
              nbformat_minor: 5, // Standard minor version
          };

          // Return the notebook object as a formatted JSON string
          return JSON.stringify(notebook, null, 2); // Pretty print with 2 spaces
      }

      /** Shows the modal displaying the generated Jupyter JSON. */
      function showJupyterJsonModal() { jupyterJsonModal.classList.remove("hidden"); }
      /** Hides the modal displaying the generated Jupyter JSON. */
      function hideJupyterJsonModal() {
          jupyterJsonModal.classList.add("hidden");
          jupyterJsonDisplay.textContent = ""; // Clear JSON when hiding
      }

      /** Copies the content of the Jupyter JSON display area to the clipboard. */
      async function copyJupyterJsonToClipboard() {
          const jsonText = jupyterJsonDisplay.textContent;
          if (!jsonText) return; // Do nothing if empty

          try {
              await navigator.clipboard.writeText(jsonText); // Use Clipboard API
              console.log("Jupyter JSON copied to clipboard!");

              // Provide visual feedback on the button
              const originalText = copyJupyterJsonButton.textContent;
              copyJupyterJsonButton.textContent = "Copied!";
              copyJupyterJsonButton.disabled = true;
              setTimeout(() => { // Reset button after a delay
                  copyJupyterJsonButton.textContent = originalText;
                  copyJupyterJsonButton.disabled = false;
              }, 1500);
          } catch (err) {
              console.error("Failed to copy Jupyter JSON: ", err);
              // Provide error feedback on the button
              copyJupyterJsonButton.textContent = "Copy Failed";
              setTimeout(() => { // Reset button after a delay
                  copyJupyterJsonButton.textContent = "Copy JSON";
              }, 2000);
          }
      }

      /** Shows the help modal explaining how to use the Jupyter JSON. */
      function showJupyterHelpModal() { jupyterHelpModal.classList.remove("hidden"); }
      /** Hides the Jupyter help modal. */
      function hideJupyterHelpModal() { jupyterHelpModal.classList.add("hidden"); }

      /** Triggered when a textarea in the main parsed view loses focus. Reconstructs raw content. */
      function handleMainTextareaEdit() {
          reconstructRawContent(); // Update the rawFileContent state
      }

      /**
       * Reconstructs the raw Markdown content from the headers and textareas in the main output view.
       * Updates the `rawFileContent` state variable.
       * Skips reconstruction if currently in mind map view.
       */
      function reconstructRawContent() {
          // Do not reconstruct if the mind map canvas is present (we rely on rawMdEditorTextarea for mind maps)
          if (document.getElementById('mindMapCanvas')) {
              console.log("In mind map view, skipping raw content reconstruction.");
              return;
          }

          let newRawContent = "";
          // Select headers H1 through H6
          const wrappers = outputDiv.querySelectorAll(".subsection-wrapper");

          wrappers.forEach((wrapper, index) => {
              const header = wrapper.querySelector("h1, h2, h3, h4, h5, h6"); // Include H5, H6
              const textarea = wrapper.querySelector(".content-textarea");

              if (header) {
                  newRawContent += (header.dataset.markdownPrefix || "") + header.textContent + "\n";
              }
              if (textarea) {
                  newRawContent += textarea.value;
                  if (index < wrappers.length - 1 || header) {
                     newRawContent += "\n";
                  }
              } else if (header && index < wrappers.length - 1) {
                  newRawContent += "\n";
              }
          });


          rawFileContent = newRawContent.trimEnd(); // Update global state, remove trailing whitespace
          console.log("Raw content reconstructed. Length:", rawFileContent.length);

          // Re-evaluate button states based on reconstructed content
          if (rawFileContent.trim()) {
              enableActionButtons();
          } else {
              disableActionButtonsButKeepNewEnabled();
          }
      }

      /**
       * Creates an HTML header element (H1-H6).
       * @param {string} tag - The header tag name (e.g., "h1").
       * @param {string} text - The text content of the header.
       * @param {string} prefix - The original Markdown prefix (e.g., "## ").
       * @returns {HTMLElement} The created header element.
       */
      function createHeaderElement(tag, text, prefix) {
          const element = document.createElement(tag);
          element.textContent = text.trim(); // Set text content
          element.dataset.markdownPrefix = prefix; // Store original prefix for reconstruction
          return element;
      }

      /**
       * Creates an editable textarea element for a content block.
       * @param {string} contentText - The text content for the textarea.
       * @returns {HTMLTextAreaElement | null} The created textarea element or null if content is empty.
       */
      function createContentTextarea(contentText) {
          if (!contentText || !contentText.trim()) {
              return null; // Don't create textarea for empty content
          }
          const textarea = document.createElement("textarea");
          textarea.value = contentText; // Set initial value
          textarea.classList.add("content-textarea"); // Apply styling
          textarea.addEventListener("blur", handleMainTextareaEdit); // Add listener to update raw content on edit

          // Adjust initial height based on content lines (within limits)
          const lines = contentText.split("\n").length;
          textarea.rows = Math.min(Math.max(5, lines + 1), 25); // Min 5, max 25 rows

          return textarea;
      }

      /** Enables the main action buttons (Edit Raw, View Rendered, Export, Refresh). */
      function enableActionButtons() {
          viewRawMdButton.disabled = false;
          viewRenderedButton.disabled = false;
          exportJupyterButton.disabled = false;
          refreshPreviewButton.disabled = false; // Enable refresh button
          newButton.disabled = false; // Ensure New is also enabled
          console.log("Action buttons enabled.");
      }

      /** Disables the main action buttons, but keeps the 'New' button enabled. */
      function disableActionButtonsButKeepNewEnabled() {
          viewRawMdButton.disabled = true;
          viewRenderedButton.disabled = true;
          exportJupyterButton.disabled = true;
          refreshPreviewButton.disabled = true; // Disable refresh button
          newButton.disabled = false; // Keep 'New' enabled
          console.log("Action buttons (except New) disabled.");
      }

      /** Handles the click event for the Refresh Preview button. */
      function handleRefreshPreview() {
          console.log("Refresh Preview requested.");
          if (rawFileContent === null) {
              console.warn("Cannot refresh: No content loaded.");
              return;
          }
          // Re-render based on the current content type
          if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              console.log("Refreshing mind map view...");
              renderMindMap(rawFileContent);
          } else {
              console.log("Refreshing standard markdown view...");
              renderParsedContent(rawFileContent);
          }
          console.log("Preview refreshed.");
      }


      // --- Gemini Panel Functions ---

      /** Toggles the visibility of the Gemini options panel (slides in/out). */
      function toggleGeminiPanel() {
        geminiOptionsPanel.classList.toggle("visible");
      }

      /** Hides the Gemini options panel. */
      function hideGeminiPanel() {
        geminiOptionsPanel.classList.remove("visible");
      }

      /** Resets the displayed token counts in the Gemini panel to 0. */
      function resetTokenCountDisplay() {
          if (promptTokenCountEl) promptTokenCountEl.textContent = '0';
          if (completionTokenCountEl) completionTokenCountEl.textContent = '0';
          if (totalTokenCountEl) totalTokenCountEl.textContent = '0';
      }

      /** Resets the cumulative token count variables and their display. */
      function resetCumulativeCounts() {
          cumulativeInTokens = 0;
          cumulativeOutTokens = 0;
          cumulativeTotalTokens = 0;
          resetTokenCountDisplay(); // Also reset the display elements
          console.log("Cumulative token counts reset.");
      }


      /** Updates the text indicator showing the currently selected Gemini model. */
      function updateActiveModelIndicator() {
          // If indicator element doesn't exist or select is disabled, clear text and exit
          if (!activeModelIndicator || geminiModelSelect.disabled) {
              if(activeModelIndicator) activeModelIndicator.textContent = ''; // Clear if disabled
              return;
          }
          // Get the selected option element
          const selectedOption = geminiModelSelect.options[geminiModelSelect.selectedIndex];
          // Update indicator text based on selection
          if (selectedOption && selectedOption.value) {
              activeModelIndicator.textContent = `Active Model: ${selectedOption.text}`;
          } else {
              activeModelIndicator.textContent = 'Active Model: None Selected';
          }
      }


      /**
       * Handles changes to the API key input field.
       * Saves the key, validates it by fetching models, and updates the UI.
       */
      function handleApiKeyChange() {
          const apiKey = geminiApiKeyInput.value.trim();
          localStorage.setItem('geminiApiKey', apiKey); // Save key to localStorage
          console.log('Gemini API Key saved.');
          geminiApiError.textContent = ''; // Clear previous errors
          geminiResponseTextarea.value = ''; // Clear previous test response
          resetCumulativeCounts(); // Reset token counts when key changes

          if (apiKey) {
              // If key is entered, enable model select and fetch models
              geminiModelSelect.disabled = false;
              fetchAndPopulateModels(apiKey);
          } else {
              // If key is cleared, disable model select and reset UI
              geminiModelSelect.disabled = true;
              clearModelOptions();
              geminiModelSelect.value = ""; // Ensure no value is selected
              updateActiveModelIndicator(); // Clear active model indicator
              const defaultOption = geminiModelSelect.querySelector('option[value=""]');
              if (defaultOption) {
                  defaultOption.textContent = "-- Enter API Key --"; // Reset placeholder text
              }
          }
      }

      /** Clears all model options from the select dropdown, except the default placeholder. */
      function clearModelOptions() {
          // Remove options starting from the second one (index 1)
          while (geminiModelSelect.options.length > 1) {
              geminiModelSelect.remove(1);
          }
      }

      /**
       * Fetches the list of available Gemini models from the API using the provided key
       * and populates the model selection dropdown.
       * @param {string} apiKey - The user's Gemini API key.
       */
      async function fetchAndPopulateModels(apiKey) {
          console.log("Fetching Gemini models...");
          const modelsUrl = `${GEMINI_API_BASE_URL}/models?key=${apiKey}`;
          const defaultOption = geminiModelSelect.querySelector('option[value=""]');

          // Update UI to loading state
          if (defaultOption) defaultOption.textContent = "-- Loading Models... --";
          clearModelOptions(); // Clear existing models first
          updateActiveModelIndicator(); // Clear active model text
          resetTokenCountDisplay(); // Reset token display

          try {
              const response = await fetch(modelsUrl); // Make API call
              if (!response.ok) {
                  // Handle HTTP errors (e.g., 400 Bad Request for invalid key)
                  let errorMsg = `Error fetching models (HTTP ${response.status})`;
                  try {
                      // Try to parse error details from the response body
                      const errorData = await response.json();
                      if (errorData.error && errorData.error.message) {
                          errorMsg = `API Error: ${errorData.error.message}`;
                      }
                  } catch (parseError) {
                      console.warn("Could not parse error response body.");
                  }
                   throw new Error(errorMsg); // Throw error to be caught below
              }
              const data = await response.json(); // Parse successful response

              // Check if the API returned any models
              if (!data.models || data.models.length === 0) {
                   console.warn("API returned successfully but with no models listed.");
                   if (defaultOption) defaultOption.textContent = "-- No models found --";
                   geminiApiError.textContent = "No models found for this API key.";
                   updateActiveModelIndicator();
                   return; // Exit if no models
              }

              // Populate the dropdown with supported models
              data.models.forEach(model => {
                  // Check if the model supports the 'generateContent' method needed by this app
                  const supportsGenerateContent = model.supportedGenerationMethods?.includes('generateContent');
                  if (supportsGenerateContent) {
                      const option = document.createElement('option');
                      option.value = model.name; // Full model name (e.g., "models/gemini-1.5-pro-latest")
                      // Use display name if available, otherwise extract name from the full path
                      option.textContent = model.displayName || model.name.split('/').pop();
                      geminiModelSelect.appendChild(option);
                  } else {
                      console.log(`Skipping model ${model.name} as it does not support 'generateContent'`);
                  }
              });

               // Update placeholder text after loading
               if (defaultOption) defaultOption.textContent = "-- Select a Model --";
               geminiApiError.textContent = ''; // Clear error message on success

              // Try to restore previously selected model from localStorage
              const savedModel = localStorage.getItem('selectedGeminiModel');
              if (savedModel && geminiModelSelect.querySelector(`option[value="${savedModel}"]`)) {
                   geminiModelSelect.value = savedModel; // Select the saved model
                   console.log("Restored previously selected model:", savedModel);
              } else {
                   geminiModelSelect.value = ""; // Default to placeholder if saved model not found
              }
              updateActiveModelIndicator(); // Update the active model display


          } catch (error) {
              // Handle errors during fetch or processing
              console.error("Failed to fetch or populate models:", error);
              geminiApiError.textContent = error.message || "Failed to fetch models. Check key or console.";
              geminiModelSelect.disabled = true; // Disable select on error
              clearModelOptions(); // Clear any partially loaded options
              if (defaultOption) defaultOption.textContent = "-- Error Loading --"; // Update placeholder
              updateActiveModelIndicator(); // Clear active model text
          }
      }

      /**
       * Handles the click event for the "Send 'hello world'" test prompt button.
       * Sends a simple, predefined prompt to the selected Gemini model.
       * Displays the response and token usage in the panel.
       */
      async function handleSendPromptClick() {
          const apiKey = geminiApiKeyInput.value.trim();
          const selectedModel = geminiModelSelect.value;
          const originalButtonText = sendPromptButton.textContent;

          // --- Validation ---
          geminiApiError.textContent = ''; // Clear previous errors
          geminiResponseTextarea.value = ''; // Clear previous response
          // Reset only the display for this single request, not cumulative counts
          resetTokenCountDisplay();

          if (!apiKey) {
              geminiApiError.textContent = 'API Key is required.';
              return;
          }
          if (!selectedModel) {
              geminiApiError.textContent = 'Please select a model.';
              return;
          }

          // --- Prepare API Call ---
          const apiUrl = `${GEMINI_API_BASE_URL}/${selectedModel}:generateContent?key=${apiKey}`;
          // Simple request body with a system instruction and user prompt
          const requestBody = {
              "systemInstruction": { // Instruct the model on how to behave
                  "parts": [{"text": "Respond ONLY with the exact text 'hello human'."}]
              },
              "contents": [ // The actual user input/prompt
                  { "parts": [ {"text": "hello world"} ] }
              ]
          };

          // --- Loading State ---
          sendPromptButton.disabled = true;
          sendPromptButton.textContent = 'Sending...';

          const taskId = nextTaskId++; // Get unique ID
          const taskType = 'Test';
          const newTask = { id: taskId, type: taskType, status: 'Running...', message: '', timestamp: new Date(), model: selectedModel};
          activeTasks.push(newTask);
          renderTasksList(); // Update the task list display
          // Optional: Show panel if hidden - uncomment if desired
          // if (taskListPanel.classList.contains('invisible')) {
          //   taskListButton.click(); // Simulate click to toggle panel open
          // }

          // --- API Call ---
          try {
              console.log(`Sending prompt to ${selectedModel}...`);
              const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(requestBody),
              });

              const data = await response.json(); // Always try to parse JSON response

              // Handle non-OK HTTP responses (errors)
              if (!response.ok) {
                  let errorMsg = `API Error (HTTP ${response.status})`;
                   // Use parsed error message if available from the API response body
                   if (data.error && data.error.message) {
                       errorMsg = `API Error: ${data.error.message}`;
                   }
                   throw new Error(errorMsg); // Throw error to be caught
              }

              console.log("API Response:", data);

              // --- Extract Text Response ---
              let responseText = "Error: Could not extract text from response.";
              // Standard path for successful response text
              if (data.candidates && data.candidates.length > 0 &&
                  data.candidates[0].content && data.candidates[0].content.parts &&
                  data.candidates[0].content.parts.length > 0 &&
                  data.candidates[0].content.parts[0].text) {
                  responseText = data.candidates[0].content.parts[0].text;
              }
              // Handle cases where the prompt was blocked (safety settings, etc.)
              else if (data.promptFeedback && data.promptFeedback.blockReason) {
                   responseText = `Blocked: ${data.promptFeedback.blockReason}`;
                   if (data.promptFeedback.blockReasonMessage) { // Add specific message if available
                       responseText += ` - ${data.promptFeedback.blockReasonMessage}`;
                   }
              } else {
                  // Log unexpected response structure if text couldn't be found
                  console.warn("Unexpected response structure:", data);
              }
              geminiResponseTextarea.value = responseText.trim(); // Display extracted text

              // --- Update Token Counts ---
              if (data.usageMetadata) {
                  // Get token counts for this specific request
                  const currentPromptTokens = data.usageMetadata.promptTokenCount || 0;
                  const currentCompletionTokens = data.usageMetadata.candidatesTokenCount || 0; // Note: API might use different names
                  const currentTotalTokens = data.usageMetadata.totalTokenCount || 0;

                  // Add current request's tokens to the cumulative session totals
                  cumulativeInTokens += currentPromptTokens;
                  cumulativeOutTokens += currentCompletionTokens;
                  cumulativeTotalTokens += currentTotalTokens; // Or recalculate: cumulativeInTokens + cumulativeOutTokens

                  // Update the display with the *cumulative* totals
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;

                  console.log("Token Usage (Current Request):", data.usageMetadata);
                  console.log("Token Usage (Cumulative Session):", { in: cumulativeInTokens, out: cumulativeOutTokens, total: cumulativeTotalTokens });
              } else {
                  console.warn("Usage metadata not found in response.");
                  // If metadata is missing, keep displaying the existing cumulative counts
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;
              }

              // Update task status to Completed
              const completedTask = activeTasks.find(task => task.id === taskId);
              if (completedTask) {
                completedTask.status = 'Completed';
                // Provide a more informative success message if possible
                completedTask.message = `Success. Response length: ${responseText.trim().length}`;
              }
              renderTasksList(); // Update UI

          } catch (error) {
              // Handle fetch errors or errors thrown from response checking
              console.error("Failed to send prompt:", error);
              geminiApiError.textContent = error.message || "Failed to send prompt. Check console.";
              geminiResponseTextarea.value = ''; // Clear response area on error
              // Display existing cumulative counts even on error
              promptTokenCountEl.textContent = cumulativeInTokens;
              completionTokenCountEl.textContent = cumulativeOutTokens;
              totalTokenCountEl.textContent = cumulativeTotalTokens;

              // Update task status to Failed
              const failedTask = activeTasks.find(task => task.id === taskId);
              if (failedTask) {
                failedTask.status = 'Failed';
                failedTask.message = error.message || 'An unknown error occurred.';
              }
              renderTasksList(); // Update UI
          } finally {
              // --- Reset Loading State ---
              sendPromptButton.disabled = false; // Re-enable button
              sendPromptButton.textContent = originalButtonText; // Restore original text
          }
      }

      /**
       * Handles the click event for the action buttons next to main view textareas (1-5).
       * Sends the textarea content combined with a specific custom prompt (from the panel) to Gemini.
       * Replaces the textarea content with the Gemini response.
       * Updates cumulative token counts.
       * @param {Event} event - The button click event.
       * @param {HTMLTextAreaElement} textareaElement - The textarea associated with the clicked button.
       * @param {HTMLTextAreaElement} customPromptElement - The corresponding custom prompt textarea from the options panel.
       * @param {string} promptLabel - A user-friendly label for the custom prompt (used in error messages).
       * @param {number | null} taskIdToUpdate - The ID of the task to update (if part of a batch job).
       */
      async function handleMainViewPrompt(event, textareaElement, customPromptElement, promptLabel, taskIdToUpdate = null) {

          const clickedButton = event ? event.currentTarget : null; // Get button only if event exists
          let originalButtonText = null; // Initialize here
          if (clickedButton) {
            originalButtonText = clickedButton.textContent; // Store original text (e.g., "1")
          }

          // --- Get Settings and Content ---
          const apiKey = geminiApiKeyInput.value.trim();
          const selectedModel = geminiModelSelect.value;
          const customPromptText = customPromptElement.value.trim(); // Get text from the *specific* custom prompt textarea
          const textareaContent = textareaElement.value.trim(); // Get content from the main view textarea

          // --- Validation ---
          geminiApiError.textContent = ''; // Clear errors in the Gemini panel
          resetTokenCountDisplay(); // Reset display for this request (will show cumulative after)

          // Check for API key, model selection, and non-empty prompts/content
          if (!apiKey) {
              geminiApiError.textContent = 'API Key is required in options panel.';
              return; // Stop execution if invalid
          }
          if (!selectedModel) {
              geminiApiError.textContent = 'Please select a model in options panel.';
              return; // Stop execution if invalid
          }
          if (!customPromptText) {
              // Use the provided label to indicate *which* custom prompt is missing
              geminiApiError.textContent = `${promptLabel} is empty in options panel.`;
              return; // Stop execution if invalid
          }
          if (!textareaContent) {
              // Provide visual feedback if the target textarea is empty
              console.warn("Textarea is empty, nothing to send.");
              textareaElement.classList.add('border-red-500', 'ring-red-500'); // Highlight border
              setTimeout(() => { // Remove highlight after a short delay
                  textareaElement.classList.remove('border-red-500', 'ring-red-500');
              }, 1500);
              return; // Stop execution if invalid
          }

          // --- Prepare API Call ---
          // Combine the custom prompt and the textarea content
          const combinedPrompt = `${customPromptText}\n\n${textareaContent}`; // Add separation
          const apiUrl = `${GEMINI_API_BASE_URL}/${selectedModel}:generateContent?key=${apiKey}`;
          // Simple request body, sending the combined text as the prompt
          const requestBody = {
              "contents": [
                  { "parts": [ {"text": combinedPrompt} ] }
              ]
              // Note: No systemInstruction is used here by default, but could be added
          };

          // --- Loading State ---
          if (clickedButton) {
            clickedButton.disabled = true; // Disable the small action button
            clickedButton.textContent = '...'; // Indicate loading
          }

          let currentTaskId = taskIdToUpdate; // Use passed ID if available

          if (!currentTaskId) { // If called directly by user click (no ID passed)
            currentTaskId = nextTaskId++; // Generate new ID
            const taskType = promptLabel.replace(/ Prompt/, '') || 'Unknown';
            const newTask = {
              id: currentTaskId,
              type: taskType,
              status: 'Running...', // Direct clicks start as Running
              message: '',
              timestamp: new Date(),
              model: selectedModel // Use model selected when clicked
            };
            activeTasks.push(newTask);
            renderTasksList(); // Show the new 'Running' task
            // Optional: Show panel if hidden
            // if (taskListPanel.classList.contains('invisible')) { taskListButton.click(); }
          } else {
            // If called as part of batch, update the existing task status if it's 'Pending'
            const existingTask = activeTasks.find(task => task.id === currentTaskId);
            if (existingTask && existingTask.status === 'Pending') {
                existingTask.status = 'Running...';
                renderTasksList(); // Update UI to show 'Running'
            }
          }
          // If taskIdToUpdate was provided, the task already exists (as Pending or Running)
          // and we'll update it using currentTaskId within the try/catch blocks.

          // --- API Call ---
          try {
              console.log(`Sending main view prompt ('${promptLabel}') to ${selectedModel}...`);
              const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(requestBody),
              });

              const data = await response.json(); // Parse response JSON

              // Handle non-OK HTTP responses
              if (!response.ok) {
                  let errorMsg = `API Error (HTTP ${response.status})`;
                  if (data.error && data.error.message) { errorMsg = `API Error: ${data.error.message}`; }
                  throw new Error(errorMsg);
              }

              console.log("API Response:", data);

              // --- Extract Text Response ---
              let responseText = "Error: Could not extract text from response.";
              // Standard path for successful response
              if (data.candidates && data.candidates.length > 0 &&
                  data.candidates[0].content && data.candidates[0].content.parts &&
                  data.candidates[0].content.parts.length > 0 &&
                  data.candidates[0].content.parts[0].text) {
                  responseText = data.candidates[0].content.parts[0].text;
              }
              // Handle blocked prompts
              else if (data.promptFeedback && data.promptFeedback.blockReason) {
                   responseText = `Blocked: ${data.promptFeedback.blockReason}`;
                   if (data.promptFeedback.blockReasonMessage) { responseText += ` - ${data.promptFeedback.blockReasonMessage}`; }
              } else {
                   console.warn("Unexpected response structure:", data);
              }

              // --- Replace Textarea Content ---
              // Use requestAnimationFrame to ensure layout is stable before interacting
               requestAnimationFrame(() => {
                  // Check if element is still in the DOM
                  if (document.body.contains(textareaElement)) {
                    textareaElement.focus(); // Focus textarea
                    textareaElement.select(); // Select existing content (optional, helps replace)
                    // Try using document.execCommand first for broader compatibility
                    if (!document.execCommand('insertText', false, responseText.trim())) {
                      // Fallback for browsers where execCommand might fail or is deprecated
                      textareaElement.setRangeText(responseText.trim(), textareaElement.selectionStart, textareaElement.selectionEnd, 'select');
                      console.log("Used setRangeText fallback for inserting text.");
                    }
                    // Trigger change and input events manually for frameworks/libraries that might listen
                    textareaElement.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    textareaElement.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                    // Trigger blur event manually to ensure any related logic (like saving/reconstruction) runs
                    textareaElement.dispatchEvent(new Event('blur', { bubbles: true, cancelable: true }));
                    // Manually trigger content reconstruction as blur might not be sufficient if focus doesn't change
                    reconstructRawContent();
                  } else {
                    console.warn("Textarea element no longer in DOM, skipping text update.");
                  }
               });


              // Update task status to Completed
              const completedTask = activeTasks.find(task => task.id === currentTaskId);
              if (completedTask) {
                completedTask.status = 'Completed';
                // Provide a more informative success message if possible
                completedTask.message = `Success. Response length: ${responseText.trim().length}`;
              }
              renderTasksList(); // Update UI


              // --- Update Token Counts (Cumulative) ---
              if (data.usageMetadata) {
                  const currentPromptTokens = data.usageMetadata.promptTokenCount || 0;
                  const currentCompletionTokens = data.usageMetadata.candidatesTokenCount || 0;
                  const currentTotalTokens = data.usageMetadata.totalTokenCount || 0;

                  // Add to cumulative totals
                  cumulativeInTokens += currentPromptTokens;
                  cumulativeOutTokens += currentCompletionTokens;
                  cumulativeTotalTokens += currentTotalTokens;

                  // Update display in the Gemini panel with cumulative totals
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;

                  console.log("Token Usage (Current Request):", data.usageMetadata);
                  console.log("Token Usage (Cumulative Session):", { in: cumulativeInTokens, out: cumulativeOutTokens, total: cumulativeTotalTokens });
              } else {
                  console.warn("Usage metadata not found in response.");
                  // Display existing cumulative counts if metadata is missing
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;
              }

          } catch (error) {
              // Handle errors during fetch or processing
              console.error("Failed to send main view prompt:", error);
              // Display error in the *panel's* error area
              geminiApiError.textContent = error.message || "Failed to process request. Check console.";
              // Display existing cumulative counts even on error
              promptTokenCountEl.textContent = cumulativeInTokens;
              completionTokenCountEl.textContent = cumulativeOutTokens;
              totalTokenCountEl.textContent = cumulativeTotalTokens;

              // Update task status to Failed
              const failedTask = activeTasks.find(task => task.id === currentTaskId);
              if (failedTask) {
                failedTask.status = 'Failed';
                failedTask.message = error.message || 'An unknown error occurred.';
              }
              renderTasksList(); // Update UI
          } finally {
              // --- Reset Loading State ---
              // Check if button exists and element is still valid before resetting
              if (clickedButton && document.body.contains(clickedButton)) {
                clickedButton.disabled = false;
                // Ensure originalButtonText was declared outside the earlier 'if' block
                clickedButton.textContent = originalButtonText;
              }
          }
      }


      /** Loads saved settings (API key, custom prompts) from localStorage on page load. */
      function loadSettings() {
          // Reset cumulative counts at the start of a new session/page load
          resetCumulativeCounts();

          // Load API Key
          const savedKey = localStorage.getItem('geminiApiKey');
          if (savedKey) {
              geminiApiKeyInput.value = savedKey; // Populate input field
              console.log('Gemini API Key loaded.');
              geminiModelSelect.disabled = false; // Enable model select
              fetchAndPopulateModels(savedKey); // Fetch models using the saved key
          } else {
              // If no key saved, keep model select disabled
              geminiModelSelect.disabled = true;
              clearModelOptions();
              const defaultOption = geminiModelSelect.querySelector('option[value=""]');
               if (defaultOption) defaultOption.textContent = "-- Enter API Key --";
               updateActiveModelIndicator(); // Ensure indicator is clear
          }

          // Load Custom Prompts
          promptCreatePlanEl.value = localStorage.getItem('promptCreatePlanValue') || atob(createPlan);
          promptGenerateContentEl.value = localStorage.getItem('promptGenerateContentValue') || generateContent;
          promptFactCheckEl.value = localStorage.getItem('promptFactCheckValue') || factCheck;
          promptCustom1El.value = localStorage.getItem('promptCustom1Value') || atob(custom1);
          promptCustom2El.value = localStorage.getItem('promptCustom2Value') || atob(custom2);
          console.log('Custom prompts loaded.');

          // Load Batch Delay
          batchDelayInput.value = localStorage.getItem('batchDelayValue') || '15'; // Load saved delay or default to 15
          console.log('Batch delay loaded.');
      }

      // --- Initial Setup ---
      applyInitialTheme(); // Apply saved theme preference on load
      disableActionButtonsButKeepNewEnabled();
      loadSettings();
      loadMarkdownFromUrl();
      switchTab('file');

    </script>
  </body>
</html>