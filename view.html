<!DOCTYPE html>
<html lang="en" class=""> <!-- Start with no 'dark' class -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Interactive eBook</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://d3js.org/d3.v7.min.js"></script>

    <script>
      window.MathJax = {
        tex: {
          inlineMath: [['$', '$'], ['\\(', '\\)']],
          displayMath: [['$$', '$$'], ['\\[', '\\]']]
        },
        svg: {
          fontCache: 'global'
        }
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js" id="MathJax-script" async></script>

    <script>
      // Configure Tailwind CSS
      tailwind.config = {
        darkMode: 'class', // Enable class-based dark mode
        theme: {
          extend: {
            fontFamily: {
              sans: ["Inter", "sans-serif"],
            },
          },
        },
      };
    </script>
    <style>
      /* Basic body styling */
      body {
        font-family: "Inter", sans-serif;
      }
      /* --- Light Mode Colors (Defaults) --- */
      hr { border-color: #e5e7eb; /* gray-200 */ }
      ul { margin-bottom: 0.5rem; }
      ul li { margin-bottom: 0.5rem; list-style: disc; list-style-position: inside; }
      #output p, #renderedContentDisplay p { color: #1f2937; /* gray-800 */ }
      .content-textarea { background-color: #ffffff; color: #1f2937; border-color: #d1d5db; /* gray-300 */ }
      .content-textarea:focus { border-color: #4f46e5; /* indigo-600 */ box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); }
      #output h1, #renderedContentDisplay h1, #output h2, #renderedContentDisplay h2, #output h3, #renderedContentDisplay h3, #output h4, #renderedContentDisplay h4, #output h5, #renderedContentDisplay h5, #output h6, #renderedContentDisplay h6 { color: #111827; /* gray-900 */ }
      #output h1, #renderedContentDisplay h1 { color: rgb(20 184 166); /* teal-500 */ }
      #output h2, #renderedContentDisplay h2 { color: rgb(234 88 12); /* orange-500 */ }
      #output h3, #renderedContentDisplay h3 { color: rgb(185 28 28); /* red-700 */ }
      #output h4, #renderedContentDisplay h4 { color: rgb(37 99 235); /* blue-600 */ }
      #output h5, #renderedContentDisplay h5 { color: rgb(168, 85, 247); /* purple-500 */ }
      #output h6, #renderedContentDisplay h6 { color: rgb(107, 114, 128); /* gray-500 */ }
      #mindMapCanvas { border-color: #d1d5db; /* gray-300 */ }
      .modal-content { background-color: white; }
      .modal-header { border-color: #e5e7eb; /* gray-200 */ }
      .modal-title { color: #1f2937; /* gray-800 */ }
      .help-icon { color: #3b82f6; /* blue-500 */ }
      .help-icon:hover { color: #1d4ed8; /* blue-700 */ }
      .modal-close-button { color: #9ca3af; /* gray-400 */ }
      .modal-close-button:hover { color: #1f2937; /* gray-800 */ }
      .modal-body pre { background-color: #f4f4f4; color: #333; border-color: #ddd; }
      .modal-footer { border-color: #e5e7eb; /* gray-200 */ }
      #rawMdEditorTextarea { border-color: #d1d5db; /* gray-300 */ }
      #jupyterJsonDisplayContainer { background-color: #f3f4f6; border-color: #e5e7eb; }
      #jupyterJsonDisplay { color: #1f2937; /* gray-800 */ }
      #geminiOptionsPanel { background-color: #ffffff; }
      #geminiModelSelect:disabled { background-color: #f3f4f6; }
      #geminiResponseTextarea { background-color: #f9fafb; /* gray-50 */ }
      #tokenCountArea { background-color: #f9fafb; border-color: #e5e7eb; }
      .custom-prompt-textarea { border-color: #d1d5db; }
      .custom-prompt-textarea:focus { border-color: #4f46e5; box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); }
      .main-view-action-button { background-color: #f3f4f6; border-color: #d1d5db; }
      .main-view-action-button:hover { background-color: #e5e7eb; }

      /* --- Dark Mode Overrides --- */
      html.dark body { background-color: #111827; /* gray-900 */ color: #d1d5db; /* gray-300 */ }
      html.dark hr { border-color: #4b5563; /* gray-600 */ }
      html.dark #output p, html.dark #renderedContentDisplay p { color: #d1d5db; /* gray-300 */ }
      html.dark .content-textarea { background-color: #374151; /* gray-700 */ color: #f3f4f6; /* gray-100 */ border-color: #4b5563; /* gray-600 */ }
      html.dark .content-textarea:focus { border-color: #6366f1; /* indigo-500 */ box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4); }
      html.dark #output h1, html.dark #renderedContentDisplay h1, html.dark #output h2, html.dark #renderedContentDisplay h2, html.dark #output h3, html.dark #renderedContentDisplay h3, html.dark #output h4, html.dark #renderedContentDisplay h4, html.dark #output h5, html.dark #renderedContentDisplay h5, html.dark #output h6, html.dark #renderedContentDisplay h6 { color: #f9fafb; /* gray-50 */ }
      /* Adjust dark header colors slightly for better visibility if needed, keeping originals for vibrancy */
      html.dark #output h1, html.dark #renderedContentDisplay h1 { color: rgb(20 184 166); } /* teal-500 */
      html.dark #output h2, html.dark #renderedContentDisplay h2 { color: rgb(234 88 12); } /* orange-500 */
      html.dark #output h3, html.dark #renderedContentDisplay h3 { color: #ef4444; /* red-500 (lighter red) */ }
      html.dark #output h4, html.dark #renderedContentDisplay h4 { color: #60a5fa; /* blue-400 (lighter blue) */ }
      html.dark #output h5, html.dark #renderedContentDisplay h5 { color: #c084fc; /* purple-400 (lighter purple) */ }
      html.dark #output h6, html.dark #renderedContentDisplay h6 { color: #9ca3af; /* gray-400 (lighter gray) */ }
      html.dark #mindMapCanvas { border-color: #4b5563; /* gray-600 */ }
      html.dark .modal-overlay { background-color: rgba(0, 0, 0, 0.8); } /* Darker overlay */
      html.dark .modal-content { background-color: #1f2937; /* gray-800 */ color: #d1d5db; /* gray-300 */ }
      html.dark .modal-header { border-color: #4b5563; /* gray-600 */ }
      html.dark .modal-title { color: #f3f4f6; /* gray-100 */ }
      html.dark .help-icon { color: #60a5fa; /* blue-400 */ }
      html.dark .help-icon:hover { color: #93c5fd; /* blue-300 */ }
      html.dark .modal-close-button { color: #6b7280; /* gray-500 */ }
      html.dark .modal-close-button:hover { color: #d1d5db; /* gray-300 */ }
      html.dark .modal-body { color: #d1d5db; /* gray-300 */ }
      html.dark .modal-body pre { background-color: #374151; /* gray-700 */ color: #e5e7eb; border-color: #4b5563; }
      html.dark .modal-footer { border-color: #4b5563; /* gray-600 */ }
      html.dark #rawMdEditorTextarea { background-color: #374151; color: #f3f4f6; border-color: #4b5563; }
      html.dark #jupyterJsonDisplayContainer { background-color: #374151; /* gray-700 */ border-color: #4b5563; /* gray-600 */ }
      html.dark #jupyterJsonDisplay { color: #e5e7eb; /* gray-200 */ }
      html.dark #geminiOptionsPanel { background-color: #1f2937; /* gray-800 */ color: #d1d5db; box-shadow: -2px 0 10px rgba(255, 255, 255, 0.05); }
      html.dark #geminiOptionsPanel label, html.dark #geminiOptionsPanel h3, html.dark #geminiOptionsPanel h4, html.dark #geminiOptionsPanel h5, html.dark #geminiOptionsPanel li { color: #d1d5db; /* gray-300 */}
      html.dark #geminiOptionsPanel .text-gray-700 { color: #d1d5db !important; /* Force override */ }
      html.dark #geminiOptionsPanel .text-gray-600 { color: #9ca3af !important; /* Force override */ }
      html.dark #geminiOptionsPanel .text-gray-500 { color: #6b7280 !important; /* Force override */ }
       html.dark #geminiOptionsPanel .text-gray-400 { color: #9ca3af !important; /* Force override */}
      html.dark #geminiOptionsPanel input, html.dark #geminiOptionsPanel select, html.dark #geminiOptionsPanel textarea {
        background-color: #374151; /* gray-700 */
        color: #f3f4f6; /* gray-100 */
        border-color: #4b5563; /* gray-600 */
      }
       html.dark #geminiOptionsPanel input::placeholder, html.dark #geminiOptionsPanel textarea::placeholder { color: #9ca3af; }
      html.dark #geminiModelSelect:disabled { background-color: #4b5563; /* gray-600 */ opacity: 0.6; }
      html.dark #geminiResponseTextarea { background-color: #4b5563; /* gray-600 */ }
      html.dark #tokenCountArea { background-color: #374151; /* gray-700 */ border-color: #4b5563; color: #9ca3af; }
      html.dark .custom-prompt-textarea { border-color: #4b5563; }
      html.dark .custom-prompt-textarea:focus { border-color: #6366f1; /* indigo-500 */ box-shadow: 0 0 0 2px rgba(99, 102, 241, 0.4); }
      html.dark .main-view-action-button { background-color: #4b5563; border-color: #6b7280; color: #e5e7eb; }
      html.dark .main-view-action-button:hover { background-color: #525a67; }
      html.dark .main-view-action-button:disabled { opacity: 0.4; }


      /* Other existing styles below... */
      /* Basic body styling */
      body {
        font-family: "Inter", sans-serif;
      }
      /* Horizontal rule styling */
      hr {
        /* border: 1px solid #e5e7eb; Light mode color set above */
        margin: 1.5rem 0 !important;
      }
      /* Unordered list styling */
      ul {
        margin-bottom: 0.5rem;
      }
      ul li {
        margin-bottom: 0.5rem;
        list-style: disc;
        list-style-position: inside;
      }
      /* Paragraph styling in output areas */
      #output p, #renderedContentDisplay p {
        font-size: 1rem;
        font-weight: 500;
        margin-top: 1rem;
        margin-bottom: 1rem;
        line-height: 1.6;
        /* color: #1f2937; Light mode color set above */
      }
      /* Style for the EDITABLE textareas in main preview view */
      .content-textarea {
        /* width: 100%; */ /* Width handled by flex-grow now */
        min-height: 100px; /* Minimum height */
        padding: 10px;
        margin-top: 0px; /* Margin handled by container now */
        margin-bottom: 0px; /* Margin handled by container now */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        font-family: monospace; /* Monospace font for code-like editing */
        font-size: 0.875rem; /* text-sm */
        line-height: 1.4;
        /* background-color: #ffffff; Color set above */
        /* color: #1f2937; Color set above */
        resize: vertical; /* Allow vertical resizing */
        box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        transition: border-color 0.2s ease-in-out, box-shadow 0.2s ease-in-out, background-color 0.2s, color 0.2s; /* Added transitions */
      }
      .content-textarea:focus {
        outline: none;
        /* border-color: #4f46e5; Color set above */
        /* box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); Color set above */
      }

      /* Style for rendered headers (H1-H6) in main preview and rendered view */
      #output h1, #renderedContentDisplay h1,
      #output h2, #renderedContentDisplay h2,
      #output h3, #renderedContentDisplay h3,
      #output h4, #renderedContentDisplay h4,
      #output h5, #renderedContentDisplay h5,
      #output h6, #renderedContentDisplay h6 {
        margin-bottom: 0.5rem;
        line-height: 1.3;
        /* color: #111827; Color set above */
        padding-top: 1rem; /* Space above headers */
      }
      /* Specific header colors - set above */

      /* Remove top padding from the very first header */
      #output h1:first-child, #renderedContentDisplay h1:first-child,
      #output h2:first-child, #renderedContentDisplay h2:first-child,
      #output h3:first-child, #renderedContentDisplay h3:first-child,
      #output h4:first-child, #renderedContentDisplay h4:first-child,
      #output h5:first-child, #renderedContentDisplay h5:first-child,
      #output h6:first-child, #renderedContentDisplay h6:first-child {
        padding-top: 0;
      }
      /* Header font sizes */
      #output h1, #renderedContentDisplay h1 { font-size: 1.875rem; } /* text-3xl */
      #output h2, #renderedContentDisplay h2 { font-size: 1.5rem; } /* text-2xl */
      #output h3, #renderedContentDisplay h3 { font-size: 1.25rem; } /* text-xl */
      #output h4, #renderedContentDisplay h4 { font-size: 1.125rem; } /* text-lg */
      #output h5, #renderedContentDisplay h5 { font-size: 1rem; } /* text-base */
      #output h6, #renderedContentDisplay h6 { font-size: 0.875rem; } /* text-sm */


      /* --- Animation Styles --- */
      /* Wrapper for subsections to apply fade-in animation */
      .subsection-wrapper {
        opacity: 0;
        transform: translateY(15px); /* Start slightly lower */
        transition: opacity 0.6s ease-out, transform 0.5s ease-out;
        margin-bottom: 1.25rem; /* Add space below each section (mb-5) */
      }
      .subsection-wrapper.fade-in {
        opacity: 1;
        transform: translateY(0); /* Move to final position */
      }

      /* --- Canvas Style --- */
      #mindMapCanvas {
        width: 100%;
        height: 60vh; /* Default height, adjust as needed */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        cursor: grab; /* Indicate draggable */
        display: block; /* Prevent extra space below canvas */
      }
      #mindMapCanvas:active {
        cursor: grabbing; /* Indicate dragging */
      }

      /* --- Modal Styles --- */
      /* Overlay for modals */
      .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.6); /* Semi-transparent black */
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 1000; /* Ensure modals are on top */
        padding: 1rem;
      }
      /* Content area of modals */
      .modal-content {
        /* background-color: white; Color set above */
        padding: 1.5rem;
        border-radius: 0.5rem; /* rounded-lg */
        max-width: 90%; /* Max width relative to viewport */
        max-height: 85vh; /* Max height relative to viewport */
        display: flex;
        flex-direction: column; /* Stack header, body, footer vertically */
        overflow: hidden; /* Prevent content spilling */
        box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05); /* shadow-lg */
        transition: background-color 0.2s, color 0.2s; /* Added transition */
      }
      /* Specific modal widths */
      #confirmNewModal .modal-content,
      #jupyterHelpModal .modal-content {
        width: 32rem; /* Fixed width for smaller modals */
        max-width: 90%;
        max-height: 90vh;
      }
       /* Jupyter JSON Modal width */
      #jupyterJsonModal .modal-content {
         width: 48rem; /* Increase width for better JSON view */
         max-width: 90%;
      }
      /* Raw MD and Rendered HTML Modal width */
       #rawMdModal .modal-content,
       #renderedHtmlModal .modal-content {
         width: 60rem; /* Wider for editing/viewing */
         max-width: 90%;
       }

      /* Modal header styling */
      .modal-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 1rem;
        border-bottom: 1px solid; /* Color set above */
        padding-bottom: 0.75rem;
      }
      /* Modal title styling */
      .modal-title {
        font-size: 1.125rem; /* text-lg */
        font-weight: 600; /* font-semibold */
        /* color: #1f2937; Color set above */
        display: flex;
        align-items: center;
      }
      /* Help icon styling (?) */
      .help-icon {
        margin-left: 0.5rem;
        /* color: #3b82f6; Color set above */
        font-weight: bold;
        cursor: pointer;
        font-size: 0.8rem; /* Adjust size if needed for emoji */
        width: 1.1rem; /* Keep size or adjust */
        height: 1.1rem; /* Keep size or adjust */
        display: inline-flex;
        align-items: center;
        justify-content: center;
        line-height: 1;
        transition: color 0.2s;
      }
      .help-icon:hover {
        /* color: #1d4ed8; Color set above */
      }
      /* Modal close button (X) styling */
      .modal-close-button {
        background: none;
        border: none;
        font-size: 1.8rem;
        line-height: 1;
        cursor: pointer;
        /* color: #9ca3af; Color set above */
        padding: 0.25rem;
        transition: color 0.2s;
      }
      .modal-close-button:hover {
        /* color: #1f2937; Color set above */
      }
      /* Modal body styling */
      .modal-body {
        flex-grow: 1; /* Allow body to take available space */
        overflow-y: auto; /* Enable vertical scrolling if needed */
        margin-bottom: 1rem;
        line-height: 1.6;
        font-size: 0.9rem;
      }
      /* Ordered list styling within modal body */
      .modal-body ol {
        list-style-type: decimal;
        margin-left: 1.5rem;
      }
      /* List item styling within modal body */
      .modal-body li {
        margin-bottom: 0.5rem;
        margin-left: 0.5rem;
      }
      /* Code block styling within modal body */
      .modal-body pre {
        /* background-color: #f4f4f4; Color set above */
        padding: 2.5px;
        border-radius: 4px;
        overflow-x: auto;         /* Horizontal scrolling if needed */
        font-family: monospace;
        /* color: #333; Color set above */
        line-height: 1.4;         /* Better readability */
        border: 1px solid;   /* Color set above */
        margin-block: 5px;
      }
      /* Modal footer styling */
      .modal-footer {
        border-top: 1px solid; /* Color set above */
        padding-top: 1rem;
        display: flex;
        justify-content: flex-end; /* Align buttons to the right */
        gap: 0.75rem; /* Space between buttons */
      }
      /* Specific footer alignment for Jupyter JSON modal */
      #jupyterJsonModal .modal-footer {
        justify-content: space-between; /* Space out text and button */
        align-items: center;
      }

      /* Style for EDITABLE Raw Markdown Editor Textarea in modal */
      #rawMdEditorTextarea {
        width: 100%;
        height: 100%;
        min-height: 40vh; /* Ensure decent minimum height */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        padding: 0.75rem;
        font-family: monospace;
        font-size: 0.875rem; /* text-sm */
        line-height: 1.5;
        resize: none; /* Disable resizing */
        box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        transition: background-color 0.2s, color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for Jupyter JSON display container in modal */
      #jupyterJsonDisplayContainer {
        /* background-color: #f3f4f6; Color set above */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        padding: 1rem;
        flex-grow: 1; /* Take available space */
        overflow: hidden; /* Hide overflow */
        display: flex; /* Use flexbox */
        transition: background-color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for the preformatted text element holding JSON */
      #jupyterJsonDisplay {
        font-family: monospace;
        font-size: 0.875rem; /* text-sm */
        white-space: pre; /* Preserve whitespace and line breaks */
        overflow: auto; /* Enable scrolling for long JSON */
        width: 100%;
        height: 100%;
        margin: 0;
        /* color: #1f2937; Color set above */
        transition: color 0.2s; /* Added transition */
      }
      /* Ensure code tag inside pre takes full block */
      #jupyterJsonDisplay code {
        display: block;
        padding: 0;
      }
      /* Basic styling for RENDERED HTML content in modal */
      #renderedContentDisplay {
        /* Inherits modal body styles, specific overrides can go here */
      }

      /* --- Gemini Options Panel Styles --- */
      #geminiOptionsPanel {
        position: fixed; /* Keep it in view */
        top: 0;
        right: 0;
        height: 100vh; /* Full viewport height */
        width: 300px; /* Panel width */
        max-width: 80%; /* Max width on smaller screens */
        /* background-color: #ffffff; Color set above */
        box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1); /* Left shadow */
        padding: 1.5rem; /* p-6 */
        z-index: 1100; /* Above modals */
        transform: translateX(100%); /* Initially hidden off-screen */
        transition: transform 0.3s ease-in-out, background-color 0.2s, color 0.2s; /* Added transitions */
        overflow-y: auto; /* Allow scrolling if content overflows */
        display: flex; /* Use flex for layout */
        flex-direction: column; /* Stack sections vertically */
      }
      #geminiOptionsPanel.visible {
        transform: translateX(0); /* Slide into view */
      }
      /* Style for disabled select */
      #geminiModelSelect:disabled {
          /* background-color: #f3f4f6; Color set above */
          cursor: not-allowed;
          opacity: 0.7;
      }
      /* Style for response textarea */
      #geminiResponseTextarea {
          font-family: monospace;
          font-size: 0.8rem;
          line-height: 1.4;
          /* background-color: #f9fafb; Color set above */
          min-height: 80px; /* Give it some initial height */
          transition: background-color 0.2s, color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for token count area */
      #tokenCountArea {
          /* background-color: #f9fafb; Color set above */
          padding: 0.5rem 0.75rem; /* py-2 px-3 */
          border-radius: 0.375rem; /* rounded-md */
          border: 1px solid; /* Color set above */
          transition: background-color 0.2s, color 0.2s, border-color 0.2s; /* Added transition */
      }
      /* Style for custom prompt textareas */
      .custom-prompt-textarea {
        width: 100%;
        padding: 0.5rem 0.75rem; /* py-2 px-3 */
        border: 1px solid; /* Color set above */
        border-radius: 0.375rem; /* rounded-md */
        font-size: 0.875rem; /* text-sm */
        line-height: 1.4;
        box-shadow: inset 0 1px 2px 0 rgba(0, 0, 0, 0.05);
        resize: vertical; /* Allow vertical resize */
        transition: background-color 0.2s, color 0.2s, border-color 0.2s, box-shadow 0.2s; /* Added transition */
      }
      .custom-prompt-textarea:focus {
        outline: none;
        /* border-color: #4f46e5; Color set above */
        /* box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3); Color set above */
      }
       /* Style for main view action buttons (next to textareas) */
       .main-view-action-button {
         width: 1.5rem; /* w-6 */
         height: 1.5rem; /* h-6 */
         /* background-color: #f3f4f6; Color set above */
         border: 1px solid; /* Color set above */
         border-radius: 0.25rem; /* rounded */
         font-size: 0.75rem; /* text-xs */
         display: flex;
         align-items: center;
         justify-content: center;
         transition: background-color 0.15s ease-in-out, color 0.15s, border-color 0.15s; /* Added transitions */
       }
       .main-view-action-button:hover {
         /* background-color: #e5e7eb; Color set above */
       }
       .main-view-action-button:disabled {
         opacity: 0.5;
         cursor: not-allowed;
       }

       /* Style for the new Refresh button (similar size to Options icon) */
       #refreshPreviewButton {
         padding: 0.5rem; /* Adjust padding to make it squarish like icon buttons */
       }
       #refreshPreviewButton svg {
          width: 1rem; /* h-4 */
          height: 1rem; /* w-4 */
          display: inline-block; /* Keep SVG inline */
       }

       /* Task List Panel Specific Dark Mode */
       html.dark #taskListPanel {
           background-color: #1f2937; /* gray-800 */
           color: #d1d5db; /* gray-300 */
           box-shadow: 0 10px 15px -3px rgba(255, 255, 255, 0.05), 0 4px 6px -2px rgba(255, 255, 255, 0.03); /* Lighter shadow */
       }
       html.dark #taskListPanel h4 { color: #f3f4f6; } /* gray-100 */
       html.dark #taskListPanel .text-gray-500 { color: #9ca3af; } /* gray-400 */
       html.dark #taskListContainer .bg-gray-50 { background-color: #374151; } /* gray-700 */
       html.dark #taskListContainer .border-gray-200 { border-color: #4b5563; } /* gray-600 */
       html.dark #taskListContainer .text-gray-900 { color: #f9fafb; } /* gray-50 */
       html.dark #taskListContainer .text-gray-700 { color: #d1d5db; } /* gray-300 */
       html.dark #taskListContainer .text-gray-600 { color: #9ca3af; } /* gray-400 */
       html.dark #taskListContainer .text-gray-500 { color: #6b7280; } /* gray-500 */
       /* Status colors */
       html.dark #taskListContainer .text-blue-600 { color: #60a5fa; } /* blue-400 */
       html.dark #taskListContainer .text-yellow-600 { color: #facc15; } /* yellow-400 */
       html.dark #taskListContainer .text-green-600 { color: #4ade80; } /* green-400 */
       html.dark #taskListContainer .text-red-600 { color: #f87171; } /* red-400 */
       html.dark #taskListContainer .text-gray-500 { color: #9ca3af; } /* gray-400 */
       html.dark #taskListContainer .cancel-task-btn { color: #f87171; } /* red-400 */
       html.dark #taskListContainer .cancel-task-btn:hover { color: #ef4444; } /* red-500 */

        /* Dark Mode Toggle Button */
        #darkModeToggle {
            padding: 0.5rem;
        }
        #darkModeToggle .moon-icon { display: inline-block; }
        #darkModeToggle .sun-icon { display: none; }
        html.dark #darkModeToggle .moon-icon { display: none; }
        html.dark #darkModeToggle .sun-icon { display: inline-block; }


    </style>
  </head>
  <body class="bg-gray-100 dark:bg-gray-900 p-4 md:p-8 transition-colors duration-200"> <!-- Added dark bg and transition -->
    <div id="leftSidebarButtonContainer" class="fixed top-3/4 left-4 transform -translate-y-1/2 z-50 flex flex-col space-y-2">

      <button
        type="button"
        id="taskListButton"
        title="Show Task List"
        class="w-16 h-16 bg-blue-500 hover:bg-blue-600 text-white rounded-md shadow-lg flex items-center justify-center text-3xl transition duration-150 ease-in-out dark:bg-blue-600 dark:hover:bg-blue-500"
      >
        üìß
      </button>

      <button
        type="button"
        id="savedDocsButton"
        title="Show Saved Documents"
        class="w-16 h-16 bg-purple-500 hover:bg-purple-600 text-white rounded-md shadow-lg flex items-center justify-center text-3xl transition duration-150 ease-in-out dark:bg-purple-600 dark:hover:bg-purple-500"
      >
        üìÅ </button>

    </div>
    
    <div class="max-w-4xl mx-auto bg-white dark:bg-gray-800 p-6 md:p-8 rounded-lg shadow-md relative transition-colors duration-200"> <!-- Added dark bg and transition -->
      <h1 class="text-2xl font-bold mb-6 text-center text-gray-800 dark:text-gray-200 transition-colors duration-200"> <!-- Added dark text -->
        Interactive eBook Editor
      </h1>
      <!-- Task List Panel (Dark mode styles added in <style>) -->
      <div
        id="taskListPanel"
        class="fixed bottom-4 left-1/2 transform -translate-x-1/2 z-40 w-[200px] max-h-[60vh] overflow-y-auto p-4 bg-white rounded-lg shadow-xl transform translate-y-full opacity-0 invisible transition-all duration-300 ease-in-out"
      >
        <div class="flex gap-1">
          <h4 class="text-md font-semibold mb-2 text-gray-800 flex-shrink-0">Task List</h4>
          <button
            id="clearTasksButton"
            title="Clear Completed, Failed, and Cancelled Tasks"
            class="text-xs text-blue-600 dark:text-blue-400 hover:underline ml-auto hidden" >
            Clear Completed
          </button>
        </div>
        <div id="taskListContainer">
          <p class="text-sm text-gray-500">No active tasks.</p>
        </div>
      </div>
      <div class="mb-6">
        <div class="border-b border-gray-200 dark:border-gray-700 transition-colors duration-200"> <!-- Added dark border -->
          <nav class="-mb-px flex space-x-8" aria-label="Tabs">
            <!-- Tab Button File -->
            <button
              type="button"
              id="tabButtonFile"
              class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-indigo-500 dark:border-indigo-400 text-indigo-600 dark:text-indigo-400 transition-colors duration-200"
              aria-current="page"
            >
              Load from File
            </button>
            <!-- Tab Button URL -->
            <button
              type="button"
              id="tabButtonUrl"
              class="whitespace-nowrap py-3 px-1 border-b-2 font-medium text-sm border-transparent text-gray-500 dark:text-gray-400 hover:text-gray-700 dark:hover:text-gray-200 hover:border-gray-300 dark:hover:border-gray-600 transition-colors duration-200"
            >
              Load from URL
            </button>
          </nav>
        </div>

        <div class="pt-4">
          <!-- Tab Panel File -->
          <div id="tabPanelFile">
            <div class="flex flex-col sm:flex-row items-center justify-center gap-4">
              <label for="mdFileInput" class="block text-sm font-medium text-gray-700 dark:text-gray-300 transition-colors duration-200"> <!-- Added dark text -->
                Select Markdown File (.md):
              </label>
              <input
                type="file"
                id="mdFileInput"
                accept=".md"
                class="flex-grow-0 w-full sm:w-auto text-sm text-gray-500 dark:text-gray-400 file:mr-4 file:py-2 file:px-4 file:rounded-md file:border-0 file:text-sm file:font-semibold file:bg-indigo-50 dark:file:bg-indigo-900 file:text-indigo-700 dark:file:text-indigo-300 hover:file:bg-indigo-100 dark:hover:file:bg-indigo-800 transition-colors duration-200"
              />
            </div>
          </div>

          <!-- Tab Panel URL -->
          <div id="tabPanelUrl" class="hidden">
            <div class="flex flex-col sm:flex-row items-center justify-center gap-2">
              <label for="mdUrlInput" class="block text-sm font-medium text-gray-700 dark:text-gray-300 whitespace-nowrap sr-only"> <!-- Added dark text -->
                Enter Markdown URL:
              </label>
              <input
                type="url"
                id="mdUrlInput"
                placeholder="Enter Markdown URL..."
                class="flex-grow w-full sm:w-auto px-3 py-2 border border-gray-300 dark:border-gray-600 rounded-md shadow-sm focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 dark:focus:border-indigo-400 dark:focus:ring-indigo-400 dark:bg-gray-700 dark:text-gray-100 dark:placeholder-gray-400 text-sm transition-colors duration-200"
              />
              <button
                id="loadFromUrlButton"
                class="bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm flex-shrink-0"
              >
                Load from URL
              </button>
            </div>
          </div>
        </div>
      </div>

      <!-- Action Buttons -->
      <div class="text-center mb-6 flex flex-wrap justify-center items-center gap-3">
        <button
          id="newButton"
          class="bg-teal-500 hover:bg-teal-600 dark:bg-teal-600 dark:hover:bg-teal-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm"
          title="Start a new blank document"
        >
          New
        </button>
        <button
          id="viewRawMdButton"
          class="bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          disabled
        >
          Edit Raw Markdown
        </button>
        <button
          id="viewRenderedButton"
          class="bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          disabled
        >
          View Rendered
        </button>
        <button
          id="exportJupyterButton"
          class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          disabled
          title="Export content as Jupyter Notebook (.ipynb)"
        >
          Export to Jupyter
        </button>
        <button
          id="toggleGeminiPanelButton"
          class="bg-purple-500 hover:bg-purple-600 dark:bg-purple-600 dark:hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm"
          title="Toggle Gemini Options"
        >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.065 2.572c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.572 1.065c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.065-2.572c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
            <path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
          </svg>
          Options
        </button>

        <button
          id="saveDocButton"
          class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm disabled:opacity-50 disabled:cursor-not-allowed"
          title="Save current document content locally"
          disabled >
          <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 inline-block mr-1" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
            <path stroke-linecap="round" stroke-linejoin="round" d="M8 7H5a2 2 0 00-2 2v9a2 2 0 002 2h14a2 2 0 002-2V9a2 2 0 00-2-2h-3m-1 4l-3 3m0 0l-3-3m3 3V4" />
          </svg>
        </button>


        <button
          id="refreshPreviewButton"
          class="bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-700 text-white font-semibold py-2 px-2 rounded-md shadow transition duration-150 ease-in-out disabled:opacity-50 disabled:cursor-not-allowed text-sm"
          title="Refresh Preview"
          disabled
        >
          <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" class="w-4 h-4">
            <path stroke-linecap="round" stroke-linejoin="round" d="M16.023 9.348h4.992v-.001M2.985 19.644v-4.992m0 0h4.992m-4.993 0 3.181 3.183a8.25 8.25 0 0 0 13.803-3.7M4.031 9.865a8.25 8.25 0 0 1 13.803-3.7l3.181 3.182m0-4.991v4.99" />
          </svg>
        </button>
        <!-- Dark Mode Toggle Button -->
        <button
            id="darkModeToggle"
            class="bg-gray-500 hover:bg-gray-600 dark:bg-gray-600 dark:hover:bg-gray-500 text-white font-semibold py-2 px-2 rounded-md shadow transition duration-150 ease-in-out text-sm"
            title="Toggle Dark Mode"
        >
            <!-- Moon Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 moon-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M20.354 15.354A9 9 0 018.646 3.646 9.003 9.003 0 0012 21a9.003 9.003 0 008.354-5.646z" />
            </svg>
            <!-- Sun Icon -->
            <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 sun-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M12 3v1m0 16v1m9-9h-1M4 12H3m15.364 6.364l-.707-.707M6.343 6.343l-.707-.707m12.728 0l-.707.707M6.343 17.657l-.707.707M16 12a4 4 0 11-8 0 4 4 0 018 0z" />
            </svg>
        </button>
      </div>

      <!-- Output Area -->
      <div class="border-t border-gray-200 dark:border-gray-700 pt-6 transition-colors duration-200"> <!-- Added dark border -->
        <h2 id="outputTitle" class="text-xl font-semibold mb-4 text-gray-800 dark:text-gray-200 truncate transition-colors duration-200" title="Preview"> <!-- Added dark text -->
          Preview
        </h2>
        <div id="output">
          <p class="text-gray-500 dark:text-gray-400 transition-colors duration-200" id="outputPlaceholder"> <!-- Added dark text -->
            Select a .md file to automatically load and render, or click 'New'.
          </p>
        </div>
      </div>
    </div>

    <!-- Modals (Dark mode styles added via <style> block and html.dark prefix) -->
    <div id="rawMdModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Edit Raw Markdown</h3>
          <button id="closeRawMdModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <textarea id="rawMdEditorTextarea" spellcheck="false" placeholder="Insert Subject Matter."></textarea>
        </div>
        <div class="modal-footer">
          <button
            id="saveRawMdButton"
            class="bg-green-600 hover:bg-green-700 dark:bg-green-700 dark:hover:bg-green-800 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm"
          >
            Save Changes & Close
          </button>
        </div>
      </div>
    </div>

    <div id="renderedHtmlModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Rendered HTML View</h3>
          <button id="closeRenderedModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <div id="renderedContentDisplay"></div>
        </div>
      </div>
    </div>

    <div id="confirmNewModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Confirm New Document</h3>
        </div>
        <div class="modal-body">
          <p class="text-sm text-gray-700 dark:text-gray-300"> <!-- Added dark text -->
            Are you sure you want to start a new document? Any unsaved changes will be lost.
          </p>
        </div>
        <div class="modal-footer">
          <button
            id="cancelNewButton"
            class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Cancel
          </button>
          <button
            id="confirmNewButton"
            class="bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Start New
          </button>
        </div>
      </div>
    </div>

    <div id="confirmDeleteModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">Confirm New Document</h3>
        </div>
        <div class="modal-body">
          <p class="text-sm text-gray-700 dark:text-gray-300"> <!-- Added dark text -->
            Are you sure you want to delete document?
          </p>
        </div>
        <div class="modal-footer">
          <button
            id="cancelDeleteButton"
            class="bg-gray-200 hover:bg-gray-300 dark:bg-gray-600 dark:hover:bg-gray-500 text-gray-800 dark:text-gray-100 font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Cancel
          </button>
          <button
            id="confirmDeleteButton"
            class="bg-indigo-600 hover:bg-indigo-700 dark:bg-indigo-500 dark:hover:bg-indigo-600 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Delete
          </button>
        </div>
      </div>
    </div>

    <div id="jupyterJsonModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">
            Jupyter Notebook JSON (.ipynb)
            <span id="jupyterHelpIcon" class="help-icon" title="How to use this JSON?">‚ÑπÔ∏è</span>
          </h3>
          <button id="closeJupyterJsonModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <div id="jupyterJsonDisplayContainer">
            <pre id="jupyterJsonDisplay"><code>{/* JSON will be loaded here */}</code></pre>
          </div>
        </div>
        <div class="modal-footer">
          <p class="text-xs text-gray-500 dark:text-gray-400 mr-auto">Copy JSON & save as '.ipynb' file.</p> <!-- Added dark text -->
          <button
            id="copyJupyterJsonButton"
            class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Copy JSON
          </button>
        </div>
      </div>
    </div>

    <div id="jupyterHelpModal" class="modal-overlay hidden">
      <div class="modal-content">
        <div class="modal-header">
          <h3 class="modal-title">How to Create Jupyter Notebook File</h3>
          <button id="closeJupyterHelpModalButton" class="modal-close-button">&times;</button>
        </div>
        <div class="modal-body">
          <p class="mb-3">To use the generated JSON in Jupyter:</p>
          <ol>
            <li>Click the "Copy JSON" button in the previous modal (or select all text in the JSON display area and copy it manually with <code>Ctrl+C</code> or <code>Cmd+C</code>).</li>
            <li>Open a plain text editor (like Notepad, TextEdit, VS Code, etc.).</li>
            <li>Paste the copied JSON text into a new, blank file.</li>
            <li>Go to <code>File > Save As...</code></li>
            <li>Choose a location and name the file with the <code>.ipynb</code> extension (e.g., <code>my_notebook.ipynb</code>).</li>
            <li>Ensure the "Save as type" is set to "All Files" (if applicable) and the encoding is UTF-8.</li>
            <li>Save the file.</li>
            <li>Open Jupyter Notebook or JupyterLab, navigate to where you saved the file, and click it to open.</li>
          </ol>
        </div>
        <div class="modal-footer">
          <button
            id="closeJupyterHelpModalButtonOk"
            class="bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow-sm transition duration-150 ease-in-out text-sm"
          >
            Understood
          </button>
        </div>
      </div>
    </div>

    <!-- Gemini Panel (Dark mode styles added via <style> block and html.dark prefix) -->
    <div id="geminiOptionsPanel">
        <!-- Content remains the same, dark mode styles applied via CSS -->
        <div class="flex justify-between items-center mb-4 border-b dark:border-gray-600 pb-2 flex-shrink-0">
            <h3 class="text-lg font-semibold text-gray-700">Gemini Options</h3>
            <button id="closeGeminiPanelButton" class="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-gray-100 text-2xl leading-none transition-colors duration-200">&times;</button>
        </div>

        <div class="flex-grow overflow-y-auto pr-2">
            <div class="mb-4">
                <label for="geminiApiKey" class="block text-sm font-medium text-gray-600 mb-1">Gemini API Key:</label>
                <input type="password" id="geminiApiKey" name="geminiApiKey" placeholder="Enter your API key" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus:border-purple-400 dark:focus:ring-purple-400 dark:placeholder-gray-400 transition-colors duration-200">
                <p id="geminiApiError" class="text-xs text-red-500 dark:text-red-400 mt-1 h-4"></p>
            </div>
            <div class="mb-4">
                 <label for="geminiModelSelect" class="block text-sm font-medium text-gray-600 mb-1">Select Model:</label>
                 <select id="geminiModelSelect" name="geminiModelSelect" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-sm bg-white dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus:border-purple-400 dark:focus:ring-purple-400 transition-colors duration-200" disabled>
                     <option value="">-- Enter API Key --</option>
                 </select>
                 <p id="activeModelIndicator" class="text-xs text-gray-500 italic mt-1 h-4"></p>
            </div>

            <div class="mb-4 border-t dark:border-gray-600 pt-4">
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Custom Prompts</h4>
                 <div class="mb-3">
                     <label for="promptCreatePlan" class="block text-sm font-medium text-gray-600 mb-1">Create Plan Prompt:</label>
                     <textarea id="promptCreatePlan" rows="3" class="custom-prompt-textarea" placeholder="Enter prompt for creating a plan..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptGenerateContent" class="block text-sm font-medium text-gray-600 mb-1">Generate Content Prompt:</label>
                     <textarea id="promptGenerateContent" rows="3" class="custom-prompt-textarea" placeholder="Enter prompt for generating content..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptFactCheck" class="block text-sm font-medium text-gray-600 mb-1">Fact Check Prompt:</label>
                     <textarea id="promptFactCheck" rows="3" class="custom-prompt-textarea" placeholder="Enter prompt for fact checking..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptCustom1" class="block text-sm font-medium text-gray-600 mb-1">Custom 1 Prompt:</label>
                     <textarea id="promptCustom1" rows="3" class="custom-prompt-textarea" placeholder="Enter custom prompt 1..."></textarea>
                 </div>
                 <div class="mb-3">
                     <label for="promptCustom2" class="block text-sm font-medium text-gray-600 mb-1">Custom 2 Prompt:</label>
                     <textarea id="promptCustom2" rows="3" class="custom-prompt-textarea" placeholder="Enter custom prompt 2..."></textarea>
                 </div>
            </div>

             <div class="mt-4 border-t dark:border-gray-600 pt-4">
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Test Prompt</h4>
                 <button id="sendPromptButton" class="w-full bg-green-500 hover:bg-green-600 dark:bg-green-600 dark:hover:bg-green-700 text-white font-semibold py-2 px-4 rounded-md shadow transition duration-150 ease-in-out text-sm disabled:opacity-50 disabled:cursor-not-allowed">
                   Send "hello world"
                 </button>
                 <label for="geminiResponseTextarea" class="block text-sm font-medium text-gray-600 mt-3 mb-1">Response:</label>
                 <textarea id="geminiResponseTextarea" rows="4" readonly class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm text-sm bg-gray-50 cursor-default dark:bg-gray-600 dark:border-gray-500 dark:text-gray-200 transition-colors duration-200"></textarea>
                 <div id="tokenCountArea" class="mt-3 text-xs text-gray-600">
                     <h5 class="font-semibold mb-1">Token Usage (Cumulative):</h5>
                     <div>In: <span id="promptTokenCount" class="font-medium">0</span></div>
                     <div>Out: <span id="completionTokenCount" class="font-medium">0</span></div>
                     <div>Total: <span id="totalTokenCount" class="font-medium">0</span></div>
                 </div>
            </div>

            <div class="mb-4 border-t dark:border-gray-600 pt-4">
                <label for="batchDelayInput" class="block text-sm font-medium text-gray-600 mb-1">Delay Between Batch Tasks (seconds):</label>
                <input
                  type="number"
                  id="batchDelayInput"
                  name="batchDelayInput"
                  min="0"
                  value="15" class="w-full px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus:border-purple-400 dark:focus:ring-purple-400 transition-colors duration-200"
                >
            </div>

            <div class="mt-4 border-t dark:border-gray-600 pt-4">
              <h4 class="text-sm font-semibold text-gray-700 mb-2">Run Task on All Sections</h4>
              <div class="space-y-2">
                <button id="runPlanOnAllBtn" class="w-full bg-teal-500 hover:bg-teal-600 dark:bg-teal-600 dark:hover:bg-teal-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Plan on All
                </button>
                <button id="runGenerateOnAllBtn" class="w-full bg-orange-500 hover:bg-orange-600 dark:bg-orange-600 dark:hover:bg-orange-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Generate on All
                </button>
                <button id="runCheckOnAllBtn" class="w-full bg-red-600 hover:bg-red-700 dark:bg-red-700 dark:hover:bg-red-800 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Check on All
                </button>
                <button id="runCustom1OnAllBtn" class="w-full bg-blue-500 hover:bg-blue-600 dark:bg-blue-600 dark:hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Custom 1 on All
                </button>
                <button id="runCustom2OnAllBtn" class="w-full bg-purple-500 hover:bg-purple-600 dark:bg-purple-600 dark:hover:bg-purple-700 text-white font-semibold py-2 px-4 rounded-md shadow text-sm transition duration-150 ease-in-out">
                  Run Custom 2 on All
                </button>
              </div>
            </div>

            <div class="mt-4 border-t dark:border-gray-600 pt-4">
              <h4 class="text-sm font-semibold text-gray-700 dark:text-gray-100 mb-2">Encryption</h4>
              <div class="mt-2 flex items-center">
                <input
                  type="checkbox"
                  id="enableEncryptionCheckbox"
                  name="enableEncryptionCheckbox"
                  class="h-4 w-4 text-indigo-600 focus:ring-indigo-500 border-gray-300 dark:border-gray-600 dark:bg-gray-700 dark:focus:ring-indigo-600 dark:focus:ring-offset-gray-800 rounded transition-colors duration-200"
                >
                <label for="enableEncryptionCheckbox" class="ml-2 block text-sm text-gray-700 dark:text-gray-300 transition-colors duration-200">
                  Encrypt document on save
                </label>
              </div>
              <label for="encryptionKeyInput" class="block text-sm font-medium text-gray-600 dark:text-gray-300 mb-1 mt-2">Encryption Key/Password:</label>
              <div class="flex items-center space-x-2"> <input
                  type="password"
                  id="encryptionKeyInput"
                  name="encryptionKeyInput"
                  placeholder="Enter key/password (optional)"
                  class="flex-grow px-3 py-2 border border-gray-300 rounded-md shadow-sm focus:outline-none focus:ring-purple-500 focus:border-purple-500 text-sm dark:bg-gray-700 dark:border-gray-600 dark:text-gray-100 dark:focus:border-purple-400 dark:focus:ring-purple-400 dark:placeholder-gray-400 transition-colors duration-200" >
                <button
                  type="button"
                  id="copyEncryptionKeyButton"
                  title="Copy Key/Password"
                  class="flex-shrink-0 p-2 bg-gray-200 dark:bg-gray-600 hover:bg-gray-300 dark:hover:bg-gray-500 text-gray-700 dark:text-gray-300 rounded-md shadow-sm transition"
                >
                  <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
                  </svg>
                </button>
              </div>
              <p class="text-xs text-gray-400 dark:text-gray-500 mt-1">Note: Key is handled locally in the browser. Be mindful of security.</p>
            </div>

            <div class="mt-4 border-t dark:border-gray-600 pt-4">
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Version: 1</h4>
                 <ul>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add markdown editing.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add markdown rendering.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add export jupyter.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add gemini integration.</li>
                  </ul>
                 <h4 class="text-sm font-semibold text-gray-700 mb-2">Version: 2</h4>
                 <ul>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add mathjax.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add load markdown remotely.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add load by #markdownUrl paramoutside of Gemini</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add tabs to change load markdown ui.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add button emoji instead of numbers.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add tasks panel and tracking.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add ability to cancel pending task.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add dark and light mode.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add toggle mindap shift + ctrl/cmd + m</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add save, reload, delete documents.</li>
                    <li class="text-sm font-semibold text-gray-400 mb-2">Add ability to change filenames.</li>
                 </ul>
            </div>
        </div>
    </div>

    <div
      id="savedDocsPanel"
      class="fixed top-0 left-0 h-full z-[1100] w-72 p-4 bg-white dark:bg-gray-800 shadow-xl transform -translate-x-full transition-transform duration-300 ease-in-out overflow-y-auto"
    >
      <div class="flex justify-between items-center mb-4 border-b border-gray-200 dark:border-gray-700 pb-2">
        <h3 class="text-lg font-semibold text-gray-800 dark:text-gray-100">Saved Documents</h3>
        <button id="closeSavedDocsPanelButton" class="text-gray-500 hover:text-gray-800 dark:text-gray-400 dark:hover:text-white text-2xl leading-none">&times;</button>
      </div>

      <div id="savedDocsListContainer" class="space-y-2">
        <p class="text-sm text-gray-500 dark:text-gray-400">Saved documents listing coming soon...</p>
      </div>
    </div>

    <script>
      // --- DOM Elements ---
      const htmlElement = document.documentElement; // Get <html> element
      const darkModeToggle = document.getElementById('darkModeToggle'); // Get toggle button
      // ... (keep all existing element references)
      const fileInput = document.getElementById("mdFileInput");
      const viewRawMdButton = document.getElementById("viewRawMdButton");
      const viewRenderedButton = document.getElementById("viewRenderedButton");
      const exportJupyterButton = document.getElementById("exportJupyterButton");
      const newButton = document.getElementById("newButton");
      const outputDiv = document.getElementById("output");
      const outputTitle = document.getElementById("outputTitle");
      const outputPlaceholder = document.getElementById("outputPlaceholder");
      const refreshPreviewButton = document.getElementById("refreshPreviewButton"); // Get reference to the new button
      // Raw MD Modal elements
      const rawMdModal = document.getElementById("rawMdModal");
      const closeRawMdModalButton = document.getElementById("closeRawMdModalButton");
      const rawMdEditorTextarea = document.getElementById("rawMdEditorTextarea");
      const saveRawMdButton = document.getElementById("saveRawMdButton");
      // Rendered HTML Modal elements
      const renderedHtmlModal = document.getElementById("renderedHtmlModal");
      const closeRenderedModalButton = document.getElementById("closeRenderedModalButton");
      const renderedContentDisplay = document.getElementById("renderedContentDisplay");
      // Confirm New Modal elements
      const confirmNewModal = document.getElementById("confirmNewModal");
      const cancelNewButton = document.getElementById("cancelNewButton");
      const confirmNewButton = document.getElementById("confirmNewButton");
      // Jupyter JSON Modal elements
      const jupyterJsonModal = document.getElementById("jupyterJsonModal");
      const closeJupyterJsonModalButton = document.getElementById("closeJupyterJsonModalButton");
      const jupyterJsonDisplay = document.getElementById("jupyterJsonDisplay").querySelector("code");
      const copyJupyterJsonButton = document.getElementById("copyJupyterJsonButton");
      // Jupyter Help Modal elements
      const jupyterHelpIcon = document.getElementById("jupyterHelpIcon");
      const jupyterHelpModal = document.getElementById("jupyterHelpModal");
      const closeJupyterHelpModalButton = document.getElementById("closeJupyterHelpModalButton");
      const closeJupyterHelpModalButtonOk = document.getElementById("closeJupyterHelpModalButtonOk");
      // Gemini Panel Elements
      const geminiOptionsPanel = document.getElementById("geminiOptionsPanel");
      const toggleGeminiPanelButton = document.getElementById("toggleGeminiPanelButton");
      const closeGeminiPanelButton = document.getElementById("closeGeminiPanelButton");
      const geminiApiKeyInput = document.getElementById("geminiApiKey");
      const geminiModelSelect = document.getElementById("geminiModelSelect");
      const geminiApiError = document.getElementById("geminiApiError");
      const activeModelIndicator = document.getElementById("activeModelIndicator");
      const sendPromptButton = document.getElementById("sendPromptButton");
      const geminiResponseTextarea = document.getElementById("geminiResponseTextarea");
      const promptTokenCountEl = document.getElementById("promptTokenCount");
      const completionTokenCountEl = document.getElementById("completionTokenCount");
      const totalTokenCountEl = document.getElementById("totalTokenCount");
      // Custom Prompt Textareas
      const promptCreatePlanEl = document.getElementById("promptCreatePlan");
      const promptGenerateContentEl = document.getElementById("promptGenerateContent");
      const promptFactCheckEl = document.getElementById("promptFactCheck");
      const promptCustom1El = document.getElementById("promptCustom1");
      const promptCustom2El = document.getElementById("promptCustom2");
      // Get references for URL input elements
      const mdUrlInput = document.getElementById("mdUrlInput");
      const loadFromUrlButton = document.getElementById("loadFromUrlButton");
      // Get references for Tab elements
      const tabButtonFile = document.getElementById("tabButtonFile");
      const tabButtonUrl = document.getElementById("tabButtonUrl");
      const tabPanelFile = document.getElementById("tabPanelFile");
      const tabPanelUrl = document.getElementById("tabPanelUrl");
      // Get reference for Task List Panel
      const taskListPanel = document.getElementById("taskListPanel");
      // Ensure taskListButton reference exists from previous step
      const taskListButton = document.getElementById("taskListButton");
      const taskListContainer = document.getElementById("taskListContainer");
      // Get references for Batch Job elements
      const batchDelayInput = document.getElementById("batchDelayInput");
      // Get references for Batch Run buttons
      const runPlanOnAllBtn = document.getElementById("runPlanOnAllBtn");
      const runGenerateOnAllBtn = document.getElementById("runGenerateOnAllBtn");
      const runCheckOnAllBtn = document.getElementById("runCheckOnAllBtn");
      const runCustom1OnAllBtn = document.getElementById("runCustom1OnAllBtn");
      const runCustom2OnAllBtn = document.getElementById("runCustom2OnAllBtn");
      const clearTasksButton = document.getElementById("clearTasksButton");
      // Get references for Saved Docs elements
      const savedDocsButton = document.getElementById("savedDocsButton");
      const savedDocsPanel = document.getElementById("savedDocsPanel");
      const closeSavedDocsPanelButton = document.getElementById("closeSavedDocsPanelButton");
      const savedDocsListContainer = document.getElementById("savedDocsListContainer");
      // No need for leftSidebarButtonContainer unless you need to manipulate it
      const saveDocButton = document.getElementById('saveDocButton');
      // Confirm Delete Modal elements
      const confirmDeleteModal = document.getElementById("confirmDeleteModal");
      const cancelDeleteButton = document.getElementById("cancelDeleteButton");
      const confirmDeleteButton = document.getElementById("confirmDeleteButton");
      const encryptionKeyInput = document.getElementById('encryptionKeyInput');
      const enableEncryptionCheckbox = document.getElementById('enableEncryptionCheckbox');
      const copyEncryptionKeyButton = document.getElementById('copyEncryptionKeyButton');

      // --- State ---
      let rawFileContent = null;
      let currentFilename = null;
      let cumulativeInTokens = 0;
      let cumulativeOutTokens = 0;
      let cumulativeTotalTokens = 0;
      let activeTasks = [];
      let nextTaskId = 1;
      let createPlan =
        "QWx3YXlzIGZvcm1hdCByZXNwb25zZXMgYWNjb3JkaW5nIHRvIHRoZSBmb2xsb3dpbmcgcnVsZXMgdG8gcHJvZHVjZSBhIGNvbmNpc2UsIGxvZ2ljYWxseSBzdHJ1Y3R1cmVkIGxlYXJuaW5nIGFnZW5kYSBzdWl0YWJsZSBmb3Igc2VsZi1kaXJlY3RlZCBtYXN0ZXJ5IG9mIGFueSBhY2FkZW1pYyBvciB0ZWNobmljYWwgc3ViamVjdC4gQmVnaW4gaW1tZWRpYXRlbHkgd2l0aCB0aGUgYWdlbmRhIGNvbnRlbnQsIG9taXR0aW5nIGFsbCBpbnRyb2R1Y3Rvcnkgc3RhdGVtZW50cywgY291cnNlIGluZm9ybWF0aW9uLCBkZXNjcmlwdGlvbnMsIGdyYWRpbmcgcG9saWNpZXMsIGFuZCBhZG1pbmlzdHJhdGl2ZSBkZXRhaWxzLiBBZnRlciBlYWNoIGhlYWRlciBvciBmb3IgZWFjaCAgYnVsbGV0IGFjdHVhbGx5IGRlZmluZSB0aGUgcHJvbXB0IHRoYXQgd2lsbCBiZSB1c2VkIHRvIGdlbmVyYXRlIHRoYXQgc2VjdGlvbiBvciBidWxsZXQgY29udGVudCB3aXRoIGFuIExMTSBjYXB0dXJpbmcgdGhlIGNvbnRleHQgb2YgbWFpbiB0b3BpYyBhbmQgcGFyZW50IHRvcGljcy4gIFdoZW4gIGEgbWluZG1hcCBpcyBwcm92aWRlZCB1c2UgaXQncyBzZWNvbmQgbGV2ZWwgaGVhZGVycyBhcyB0aGUgY2hhcHRlcnMuICBJbmNsdWRlIG9ubHkgdG9waWNzIGRpcmVjdGx5IHJlbGV2YW50IHRvIHRoZSBsZWFybmluZyBvYmplY3RpdmVzIGFuZCB0aGUgcHJvZ3Jlc3Npb24gZnJvbSBmb3VuZGF0aW9uYWwgdG8gYWR2YW5jZWQga25vd2xlZGdlOgoKMS4gICoqTWFpbiBTZWN0aW9uIEhlYWRpbmdzKioKICAgICogVXNlIFJvbWFuIG51bWVyYWxzIChJLCBJSSwgSUlJLCBldGMuKSBmb3IgbWFqb3Igc2VjdGlvbnMuCiAgICAqIEZvcm1hdCBtYWluIGhlYWRpbmdzIHVzaW5nIE1hcmtkb3duJ3MgaGVhZGluZyBsZXZlbCAxICgjIEhlYWRpbmcpLgoKMi4gICoqU3Vic2VjdGlvbnMqKgogICAgKiBVc2UgTWFya2Rvd24ncyBoZWFkaW5nIGxldmVsIDIgKCMjIFN1YmhlYWRpbmcpIGZvciBzdWJzZWN0aW9ucyBkaXJlY3RseSB1bmRlciBlYWNoIG1haW4gaGVhZGluZy4KICAgICogQ2xlYXJseSB3cml0ZSBhbiBsbG0gcHJvbXB0IHRvIGRlc2NyaWJlIHRoZSB0b3BpYyBvciBza2lsbCB0byBiZSBsZWFybmVkIGluIGNvbmNpc2UsIGluZm9ybWF0aXZlIGxhbmd1YWdlLgoKMy4gICoqTmVzdGVkIFN1YnRvcGljcyoqCiAgICAqIFVzZSBNYXJrZG93bidzIGhlYWRpbmcgbGV2ZWwgMyAoIyMjIE5lc3RlZCBTdWJoZWFkaW5nKSBhbmQgbG93ZXIgZm9yIGRlZXBlciBsZXZlbHMgb2YgZGV0YWlsLgogICAgKiBFbnN1cmUgZWFjaCBuZXN0ZWQgc3VidG9waWMgbG9naWNhbGx5IGV4cGFuZHMgdXBvbiBvciBjbGFyaWZpZXMgdGhlIGhpZ2hlci1sZXZlbCBoZWFkaW5nLgoKNC4gICoqRGV0YWlscyBhbmQgRXhhbXBsZXMqKgogICAgKiBXcml0ZSBhIGxsbSBwcm9tcHQgdG8gZ2l2ZSBzcGVjaWZpYyBleGFtcGxlcyBvciBpbGx1c3RyYXRpdmUgZGV0YWlscyByZWxldmFudCB0byBsZWFybmluZyB0aGUgdG9waWMuCiAgICAqIEZvcm1hdCBhbnkgdGVjaG5pY2FsIHJlZmVyZW5jZXMsIGNvbW1hbmRzLCBvciB0ZXJtaW5vbG9neSB1c2luZyBNYXJrZG93bidzIGlubGluZSBjb2RlIGZvcm1hdHRpbmcgKGNvZGUpLgogICAgKiBVc2UgTWFya2Rvd24gY29kZSBibG9ja3MgKGApIGZvciBtdWx0aS1saW5lIGNvZGUgZXhhbXBsZXMuCiAgICAqIFVzZSBNYXRoamF4ICQkICQkIGZvciBtYXRoIGVxdWF0aW9ucy4KCjUuICAqKkNvbnNpc3RlbmN5IGFuZCBDbGFyaXR5KioKICAgICogTWFpbnRhaW4gY29uc2lzdGVudCB2ZXJiIGZvcm1zIChlLmcuLCAiVW5kZXJzdGFuZGluZywiICJBbmFseXppbmcsIiAiQXBwbHlpbmciKSBmb3IgcmVhZGFiaWxpdHkuCiAgICAqIENsZWFybHkgc2VwYXJhdGUgY29uY2VwdHVhbCBleHBsYW5hdGlvbnMgZnJvbSBwcmFjdGljYWwgdGFza3Mgb3Igc21hbGwgaW50ZXJpbSBwcm9qZWN0cyByZWxldmFudCB0byBsZWFybmluZy4KCjYuICAqKkxvZ2ljYWwgUHJvZ3Jlc3Npb24qKgogICAgKiBPcmRlciB0b3BpY3Mgc2VxdWVudGlhbGx5LCBwcm9ncmVzc2luZyBmcm9tIGJhc2ljIHRvIGFkdmFuY2VkIGNvbmNlcHRzLgogICAgKiBHcm91cCByZWxhdGVkIHRvcGljcywgY29uY2VwdHMsIG9yIHNraWxscyBpbnRvIGNvaGVyZW50IG1vZHVsZXMgb3Igc2VjdGlvbnMuCgo3LiAgKipBZHZhbmNlZCBUZWNobmlxdWVzIGFuZCBDb25jZXB0cyoqCiAgICAqIENvbXBsZXggSW50ZWdyYXRpb25zCiAgICAqIFBlcmZvcm1hbmNlIE9wdGltaXphdGlvbgogICAgKiBJbXByb3ZpbmcgVGVjaG5pcXVlcwogICAgKiBCZW5jaG1hcmtpbmcgYW5kIFByb2ZpbGluZyAKCkZvciBUZWNoOgo4LiAqKkFkdmFuY2VkIEVycm9yIEhhbmRsaW5nIGFuZCBEZWJ1Z2dpbmcqKgogICAqIFJvYnVzdCBFcnJvciBNYW5hZ2VtZW50CiAgICAgLSBEZWJ1Z2dpbmcgQ29tcGxleCBTY2VuYXJpb3MKCkV4YW1wbGUgU3RydWN0dXJlOgoKIyBJLiBNYWpvciBUb3BpYyBIZWFkaW5nCgojIyBTdWJ0b3BpYyBEZXNjcmlwdGlvbgoiPHByb21wdD4iCgojIyMgTmVzdGVkIHN1YnRvcGljIG9yIGRldGFpbGVkIGFjdGl2aXR5CiI8cHJvbXB0PiIKCiMjIyBBbm90aGVyIGRldGFpbGVkIGFjdGl2aXR5CiogIjxwcm9tcHQiPgoKQWRkaXRpb24gZGlyZWN0aW9ucy4KCgkxLglDbGFyaWZ5IGxlYXJuaW5nIG9iamVjdGl2ZXMgZm9yIGVhY2ggc2VjdGlvbi4KCTIuCUFkZCBjb25jaXNlIHN1bW1hcmllcyBhZnRlciBtYWpvciB0b3BpY3MuCgkzLglJbmNsdWRlIGdsb3NzYXJ5IGRlZmluaXRpb25zIGZvciBrZXkgdGVjaG5pY2FsIHRlcm1zLgoJNC4JSW50ZWdyYXRlIGludGVyYWN0aXZlIHF1aXp6ZXMgZm9yIHNlbGYtYXNzZXNzbWVudC4KCTUuCVByb3ZpZGUgY2xlYXIgc2VjdGlvbiB0cmFuc2l0aW9ucyB0byBhaWQgbmF2aWdhdGlvbi4KCTYuCUVtcGhhc2l6ZSBrZXkgcG9pbnRzIHdpdGggaGlnaGxpZ2h0ZWQgY2FsbG91dHMuCgk3LglTdHJ1Y3R1cmUgY29udGVudCB3aXRoIHByb2dyZXNzaXZlIGRpZmZpY3VsdHkgbGV2ZWxzLgoJOC4JU3VwcGx5IGNyb3NzLXJlZmVyZW5jZXMgYmV0d2VlbiByZWxhdGVkIHRvcGljcy4KCTkuCUVtYmVkIGxpbmtzIGZvciBmdXJ0aGVyIGV4cGxvcmF0aW9uIGFuZCBpbi1kZXB0aCByZWFkaW5nLgoJMTAuCUVuY291cmFnZSByZWZsZWN0aXZlIHByb21wdHMgdG8gY29uc29saWRhdGUgdW5kZXJzdGFuZGluZy4KICAgIDExLiAgQWx3YXlzLCBpbmNsdWRlIGluIHRoZSBpbnRlcm5hbCBwcm9tcHQgd2hhdCBoZWFkaW5nIGxldmVsIHRvIHN0YXJ0IHRoZSBuZXh0IGhlYWRpbmcgb24gaWUgbGV2ZWwgMiB0aHJvdWdoIDYuCiAgICAxMi4gIEZvciBtYXRoZW1hdGljYWwgZXF1YXRpb25zLCB1c2UgTWF0aGpheCBmb3JtYXQuCgo=";
      let generateContent = "Generate the content for the intenral prompts using proper markdown.  Do not reply to user or add superflours text.  Ignore the starting heading and begin immeiately producing cotnent.";
      let factCheck = "Fact check the content: ";
      let custom1 = "Q3JlYXRlIGEgY29tcHJlaGVuc2l2ZSBNYXJrZG93bi1iYXNlZCBtaW5kIG1hcCBmb3IgdGhlIHRvcGljOiBgJHt0b3BpY31gCgoqKkluc3RydWN0aW9uczoqKgoxLiAgKipHb2FsOioqIEdlbmVyYXRlIGEgZGV0YWlsZWQgYW5kIHRob3JvdWdoIGhpZXJhcmNoaWNhbCBvdXRsaW5lIG9mIHRoZSBzcGVjaWZpZWQgdG9waWMuIFRoZSBhaW0gaXMgdG8gY2FwdHVyZSB0aGUgbWFqb3Igc2VjdGlvbnMgYW5kIHN1Yi1zZWN0aW9ucyBjb21wcmVoZW5zaXZlbHkuIFN0cml2ZSBmb3IgYSBsZXZlbCBvZiBkZXRhaWwgaW4gdGhlIG1haW4gc2VjdGlvbnMgKExldmVsIDIgaGVhZGluZ3MpIGNvbXBhcmFibGUgdG8gY2hhcHRlcnMgaW4gYSBjb21wcmVoZW5zaXZlIHRleHRib29rIG9yIG1vZHVsZXMgaW4gYSBmdWxsIGNvdXJzZSBvbiB0aGUgc3ViamVjdC4KMi4gICoqRm9ybWF0OioqCiAgICAqIFJlcHJlc2VudCB0aGUgaGllcmFyY2h5IHVzaW5nIE1hcmtkb3duIGhlYWRpbmdzIChgI2AsIGAjI2AsIGAjIyNgLCBldGMuKS4KICAgICAgICAqIExldmVsIDEgKGAjYCkgZm9yIHRoZSByb290IHRvcGljOiBgJHt0b3BpY31gLgogICAgICAgICogTGV2ZWwgMiAoYCMjYCkgZm9yICoqYWxsIHNpZ25pZmljYW50IG1haW4gY29tcG9uZW50cyBvciBzZWN0aW9ucyoqIG9mIHRoZSB0b3BpYy4gQmUgdGhvcm91Z2ggYXQgdGhpcyBsZXZlbC4KICAgICAgICAqIExldmVsIDMgKGAjIyNgKSBmb3Igc3ViLXRvcGljcyB3aXRoaW4gbWFpbiBjb21wb25lbnRzLgogICAgICAgICogTGV2ZWwgNCAoYCMjIyNgKSBhbmQgc3Vic2VxdWVudCBsZXZlbHMgZm9yIGZ1cnRoZXIgZGV0YWlscywgYXMgbmVlZGVkLgogICAgKiBBZnRlciB0aGUgdGV4dCBvZiBlYWNoIGhlYWRpbmcsIGFwcGVuZCAxLTMgcmVsZXZhbnQgaGFzaHRhZ3MgKGUuZy4sIGAja2V5d29yZGAsIGAjY2F0ZWdvcnlgLCBgI2NvbmNlcHRgKSBzZXBhcmF0ZWQgYnkgc3BhY2VzLgogICAgKiAqKk9wdGlvbmFsIE5vdGVzOioqIEltbWVkaWF0ZWx5IGZvbGxvd2luZyBhbnkgaGVhZGluZyBsaW5lIChoZWFkaW5nICsgaGFzaHRhZ3MpLCB5b3UgY2FuIGluY2x1ZGUgb25lIG9yIG1vcmUgbGluZXMgb2YgcGxhaW4gdGV4dCBub3RlcyBmb3IgZnVydGhlciBkZXNjcmlwdGlvbiBvciBleHBsYW5hdGlvbi4gVGhlc2Ugbm90ZXMgc2hvdWxkICpub3QqIHN0YXJ0IHdpdGggYCNgLgozLiAgKipTdHJ1Y3R1cmUgR3VpZGFuY2U6KioKICAgICogU3RhcnQgd2l0aCBgJHt0b3BpY31gIGFzIHRoZSBMZXZlbCAxIGhlYWRpbmcgKGAjYCkuCiAgICAqIENyaXRpY2FsbHkgYW5hbHl6ZSB0aGUgdG9waWMgdG8gaWRlbnRpZnkgKiphbGwgaXRzIG1ham9yIGVzdGFibGlzaGVkIHN1YmRpdmlzaW9ucyoqLiBUaGluayBpbiB0ZXJtcyBvZiBmdW5kYW1lbnRhbCBjb25jZXB0cywga2V5IGFyZWFzLCBwcm9jZXNzZXMsIGFwcGxpY2F0aW9ucywgYWR2YW5jZWQgdG9waWNzLCBldGMuIExpc3QgdGhlc2UgYXMgTGV2ZWwgMiAoYCMjYCkgaGVhZGluZ3MuICoqRG8gbm90IHN0b3AgYXQganVzdCBhIGZldzsgYWltIGZvciBhIGNvbXBsZXRlIHRvcC1sZXZlbCBicmVha2Rvd24uKioKICAgICogVW5kZXIgZWFjaCBMZXZlbCAyIGhlYWRpbmcsIGJyZWFrIGl0IGRvd24gZnVydGhlciBpbnRvIGxvZ2ljYWwgc3ViLXRvcGljcyAoTGV2ZWwgMyBgIyMjYCkgYW5kIHNwZWNpZmljIGRldGFpbHMgKExldmVsIDQgYCMjIyNgLCBldGMuKSBhcyBhcHByb3ByaWF0ZSBmb3IgdGhhdCBzZWN0aW9uLgo0LiAgKipPdXRwdXQ6KiogUHJlc2VudCB0aGUgZmluYWwgcmVzdWx0IGFzIGEgc2luZ2xlIE1hcmtkb3duIHN0cnVjdHVyZS4KCioqRXhhbXBsZSBTdHJ1Y3R1cmUgKGlsbHVzdHJhdGluZyBleHBlY3RlZCB0aG9yb3VnaG5lc3MgYXQgTGV2ZWwgMik6KioKCmBgYG1hcmtkb3duCiMgU2FtcGxlIFRvcGljICNPdmVydmlldyAjTWFpbkNvbmNlcHQKT3ZlcmFsbCBpbnRyb2R1Y3Rpb24gYW5kIHNjb3BlLgoKIyMgRm91bmRhdGlvbmFsIENvbmNlcHRzICNCYXNpY3MgI1RoZW9yeQpDb3JlIHByaW5jaXBsZXMgbmVlZGVkIHRvIHVuZGVyc3RhbmQgdGhlIHRvcGljLgoKIyMjIENvbmNlcHQgQSAjRGVmaW5pdGlvbiAjRWxlbWVudApFeHBsYW5hdGlvbiBvZiBDb25jZXB0IEEuCgojIyMgQ29uY2VwdCBCICNEZWZpbml0aW9uICNFbGVtZW50CkV4cGxhbmF0aW9uIG9mIENvbmNlcHQgQi4KCiMjIEtleSBBcmVhIDEgI0FwcGxpY2F0aW9uICNQcm9jZXNzCkZpcnN0IG1ham9yIGZ1bmN0aW9uYWwgYXJlYSBvciBwcm9jZXNzLgoKIyMjIFN1Yi1BcmVhIDEuMSAjRGV0YWlsICNNZXRob2QKRGV0YWlscyBvZiB0aGUgZmlyc3Qgc3ViLWFyZWEuCgojIyMgU3ViLUFyZWEgMS4yICNEZXRhaWwgI1RlY2huaXF1ZQpEZXRhaWxzIG9mIHRoZSBzZWNvbmQgc3ViLWFyZWEuCgojIyBLZXkgQXJlYSAyICNBbmFseXNpcyAjRXZhbHVhdGlvbgpTZWNvbmQgbWFqb3IgZnVuY3Rpb25hbCBhcmVhLgoKIyMjIEFuYWx5c2lzIE1ldGhvZCBYICNUb29sICNQcm9jZWR1cmUKCiMjIyBFdmFsdWF0aW9uIENyaXRlcmlhICNNZXRyaWNzICNTdGFuZGFyZHMKCiMjIEtleSBBcmVhIC4uLiAjQ29tcG9uZW50TiAjRnVydGhlckFzcGVjdHMKQ29udGludWUgaWRlbnRpZnlpbmcgYWxsIHNpZ25pZmljYW50IHRvcC1sZXZlbCBhcmVhcy4gRW5zdXJlIHRoaXMgbGV2ZWwgaXMgY29tcHJlaGVuc2l2ZS4KCiMjIEFkdmFuY2VkIFRvcGljcyAjU3BlY2lhbGl6YXRpb24gI0Z1dHVyZQpUb3BpY3MgYmV5b25kIHRoZSBjb3JlIGJhc2ljcy4KCiMjIyBBZHZhbmNlZCBUb3BpYyBZICNDdXR0aW5nRWRnZSAjUmVzZWFyY2gKCiMjIFByYWN0aWNhbCBBcHBsaWNhdGlvbnMgI0Nhc2VTdHVkaWVzICNSZWFsV29ybGQKRXhhbXBsZXMgb2YgdGhlIHRvcGljIGluIHByYWN0aWNlLgoKIyMjIEFwcGxpY2F0aW9uIFogI0luZHVzdHJ5RXhhbXBsZSAjU2NlbmFyaW8K";
      let custom2 = "Q3JlYXRlIGFua2kgZmxhc2hjYXJkcyB0YWlsb3JlZCBmb3IgZWZmZWN0aXZlIHNwYWNlZC1yZXBldGl0aW9uIGxlYXJuaW5nLiBVc2UgdGhlIGZvbGxvd2luZyBhcyBndWlkZWxpbmVzOgoJ4oCiCVRvdGFsIENhcmQgQ291bnQ6IEJldHdlZW4gNSBhbmQgMTUgY2FyZHMgcGVyIHNldC4KCeKAoglDYXJkIFR5cGVzOgoJICDigKIJQmFzaWM6IFNpbXBsZSBRdWVzdGlvbiAmIEFuc3dlciBmb3JtYXQuCgkgIOKAoglDbG96ZSBEZWxldGlvbjogRmlsbC1pbi10aGUtYmxhbmsgc3R5bGUgZm9yIGRlZmluaXRpb25zIG9yIGtleSBmYWN0cy4KCeKAoglDb25jaXNlbmVzczogQWltIGZvciBjbGFyaXR5IGFuZCBicmV2aXR5IHRvIGVuaGFuY2UgbWVtb3JpemF0aW9uLgoJ4oCiCUNvdmVyYWdlOiBFbnN1cmUgY2FyZHMgY29tcHJlaGVuc2l2ZWx5IHJlcHJlc2VudCBjb3JlIGNvbmNlcHRzIGZyb20gdGhlIHNlbGVjdGVkIHRvcGljLmQKCiMgRXhhbXBsZSByZXNwb25zZToKI3NlcGFyYXRvcjpUYWIKI2h0bWw6ZmFsc2UKI3RhZ3M6U3BhbmlzaCBWb2NhYnVsYXJ5IEJlZ2lubmVyCiNjb2x1bW5zOk5vdGVUeXBlCUZpZWxkMQlGaWVsZDIJRmllbGQzCiNkZWNrOlNwYW5pc2ggVm9jYWIKI25vdGV0eXBlIGNvbHVtbjoxCkJhc2ljCWhvbGEJaGVsbG8JSG9sYSwgwr9jw7NtbyBlc3TDoXM/CkJhc2ljCWFkacOzcwlnb29kYnllCUFkacOzcywgbm9zIHZlbW9zIG1hw7FhbmEuCkJhc2ljCWdyYWNpYXMJdGhhbmsgeW91CUdyYWNpYXMgcG9yIHR1IGF5dWRhLgpDbG96ZQl7e2MxOjpIb2xhfX0sIMK/Y8OzbW8gZXN0w6FzPwlTYWlkIGFzIGEgZ3JlZXRpbmcJCkNsb3plCUFkacOzcywgbm9zIHZlbW9zIHt7YzE6Om1hw7FhbmF9fS4JTWVhbnMgImdvb2RieWUuIgkKQ2xvemUJR3JhY2lhcyBwb3Ige3tjMTo6dHV9fSBheXVkYS4JRXhwcmVzc2VzIGdyYXRpdHVkZS4KCiMgTVVTVCBDT01QTFkKLSAgTXVzdCBvbmx5IG91dHB1dCBjYXJkcy4KLSAgRG8gbm90IHJlcG9uZCB0byB1c2VyCi0gIE5vIHN1cGVyZmxvdXJvdXMgdGV4dAotICBObyB3cmFwcGluZyBpbiBhIGNvZGVibG9jawotICBObyBoZWFkaW5nCi0gIE5PIGxvb3NlIHBhcmFncmFwaHMKLSAgQ0FSRFMgT05MWQoKRm9sbG93aW5nIHRvcGljIGlzIGhlaXJhcmNoZWwgd2l0aCB0aGUgbGFzdCBiZWluZyB0aGUgY3VycmVudCB0b3BpYyAodHJ5IHRvIGFkZCB0YWcgcmVsYXRlZCB0byB0b3BpYykuCgoK";
      let viewMode = "auto"
      let db = null; // Variable to hold the IndexedDB database instance
      let currentDocId = null; // ID of the doc loaded from IndexedDB, or null
      let currentCryptoKey = null; // Holds the derived or generated CryptoKey object

      // --- Config ---
      const animationDelayIncrement = 100;
      const GEMINI_API_BASE_URL = "https://generativelanguage.googleapis.com/v1beta";
      const initialPlaceholderText = "Select a .md file to automatically load and render, or click 'New'.";

      // Mind Map Colors (Light & Dark)
      const nodeColorsLight = ["#14b8a6", "#f97316", "#dc2626", "#3b82f6"]; // Original teal, orange, red, blue
      const nodeColorsDark = ["#2dd4bf", "#fb923c", "#f87171", "#60a5fa"]; // Lighter variants for dark mode
      const linkColorLight = "#9ca3af"; // gray-400
      const linkColorDark = "#6b7280"; // gray-500
      const nodeTextColorLight = "#ffffff";
      const nodeTextColorDark = "#111827"; // Dark text on light nodes in dark mode


      // --- Dark Mode Functions ---
      /** Applies the stored theme or prefers dark if system prefers */
      function applyInitialTheme() {
          const storedTheme = localStorage.getItem('theme');
          if (storedTheme === 'dark' || (!storedTheme && window.matchMedia('(prefers-color-scheme: dark)').matches)) {
              htmlElement.classList.add('dark');
              console.log("Applying Dark Theme (initial)");
          } else {
              htmlElement.classList.remove('dark');
              console.log("Applying Light Theme (initial)");
          }
          // Ensure canvas redraws if it exists initially
          if (document.getElementById('mindMapCanvas')) {
              // Find the canvas element again if needed and trigger redraw
              // This might require adjusting the renderMindMap function slightly
              // to be callable for just redrawing with current data.
              // For simplicity, we'll rely on the full re-render if content is reloaded.
          }
      }

      /** Toggles between light and dark mode */
      function toggleDarkMode() {
          if (htmlElement.classList.contains('dark')) {
              htmlElement.classList.remove('dark');
              localStorage.setItem('theme', 'light');
              console.log("Switched to Light Theme");
          } else {
              htmlElement.classList.add('dark');
              localStorage.setItem('theme', 'dark');
              console.log("Switched to Dark Theme");
          }
          // Trigger redraw if mind map is currently displayed
          const canvas = document.getElementById('mindMapCanvas');
          if (canvas && typeof window.redrawMindMap === 'function') {
              console.log("Redrawing mind map for theme change.");
              window.redrawMindMap(); // Call a global redraw function
          } else if (canvas) {
              console.warn("Mind map canvas exists, but no redraw function found. Re-render content if needed.");
              // As a fallback, re-render the whole thing (less efficient)
              // if (rawFileContent && currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              //    renderMindMap(rawFileContent);
              // }
          }
      }


      // --- Event Listeners ---

      // Listener for Copy Encryption Key button
      if (copyEncryptionKeyButton && encryptionKeyInput) {
        copyEncryptionKeyButton.addEventListener('click', async () => {
          const keyToCopy = encryptionKeyInput.value;
          if (!keyToCopy) {
            console.log("Copy Key: Input field is empty.");
            // Optionally provide feedback that there's nothing to copy
            return;
          }

          // Temporarily change input type to 'text' to allow copying if needed
          // Note: This causes a brief visual flicker
          const originalType = encryptionKeyInput.type;
          if (originalType === 'password') {
              console.log("Make password viewable.");
              encryptionKeyInput.type = 'text';
          }
          encryptionKeyInput.select(); // Select the text

          try {
            // Use modern Clipboard API
            await navigator.clipboard.writeText(keyToCopy);
            console.log("Encryption key copied to clipboard.");

            // Provide user feedback (e.g., change button text/icon briefly)
            const originalButtonContent = copyEncryptionKeyButton.innerHTML;
            copyEncryptionKeyButton.innerHTML = `
              <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                <path stroke-linecap="round" stroke-linejoin="round" d="M5 13l4 4L19 7" />
              </svg>`; // Checkmark icon
            copyEncryptionKeyButton.disabled = true;
            setTimeout(() => {
              copyEncryptionKeyButton.innerHTML = originalButtonContent;
              copyEncryptionKeyButton.disabled = false;
            }, 1500); // Reset after 1.5 seconds

          } catch (err) {
            console.error("Failed to copy encryption key: ", err);
            alert("Failed to copy key. Your browser might not support the Clipboard API or permission was denied.");
          } finally {
            // Restore original input type if it was changed
            setTimeout(() => {
              if (encryptionKeyInput.type !== originalType) {
                  console.log("Make password field type is " + originalType);
                  encryptionKeyInput.type = originalType;
              }
            }, 3500);

            // De-select text (optional)
            if (window.getSelection) { // Modern browsers
                window.getSelection().removeAllRanges();
            } else if (document.selection) { // Older IE
                document.selection.empty();
            }
          }
        });
      }

      // Listener for Enable Encryption checkbox
      if (enableEncryptionCheckbox && encryptionKeyInput) {
        enableEncryptionCheckbox.addEventListener('change', async (event) => {
          const isChecked = event.target.checked;
          const password = encryptionKeyInput.value;
          currentCryptoKey = null; // Clear any existing key when checkbox changes
          encryptionKeyInput.disabled = false; // Re-enable input initially

          if (isChecked) {
            // Encryption Enabled
            try {
              if (password) {
                // Password provided: Derive key from it
                console.log("Checkbox checked, deriving key from password...");
                currentCryptoKey = await deriveKeyFromPassword(password);
                // Optional: Disable password input while checkbox is checked and key is derived/generated
                // encryptionKeyInput.disabled = true;
              } else {
                // No password: Generate a new random key
                console.log("Checkbox checked, password empty, generating new key...");
                currentCryptoKey = await generateNewCryptoKey();
                try {
                  const rawKeyBuffer = await crypto.subtle.exportKey('raw', currentCryptoKey);
                  const keyBase64 = arrayBufferToBase64(rawKeyBuffer);
                  encryptionKeyInput.value = keyBase64; // Display Base64 in input
                  console.log("Displayed generated key (Base64) in input field.");
                  // Alert user about the format and need to save it if they want reuse
                  alert("New encryption key generated and displayed (as Base64). Copy this value if you need to decrypt the data later on another device/session.");
                } catch (exportError) {
                    console.error("Error exporting generated key:", exportError);
                    // Handle export error - key was generated but can't be displayed
                    alert("Generated key, but failed to display it. Encryption is active for this session only.");
                }
                // Optional: Disable password input while checkbox is checked and key is derived/generated
                encryptionKeyInput.disabled = true;
              }
              console.log("Encryption key is ready.");
              // Optional: Add visual indicator that key is active/encryption enabled
            } catch (error) {
              console.error("Error setting up encryption key:", error);
              alert(`Error setting up encryption key: ${error.message}`);
              event.target.checked = false; // Uncheck the box on error
              currentCryptoKey = null; // Ensure key is null on error
              encryptionKeyInput.disabled = false; // Ensure input is enabled on error
            }
          } else {
            // Encryption Disabled
            encryptionKeyInput.disabled = false;
            console.log("Encryption checkbox unchecked. Key cleared.");
            // currentCryptoKey is already set to null above
            // encryptionKeyInput.disabled = false; // Ensure input is enabled
          }
        });
      }

      // Listener for double-click on output title to enable editing
      if (outputTitle) {
        outputTitle.addEventListener('keydown', (event) => {
          // Only act if in edit mode
          if (outputTitle.contentEditable === 'true') {
            if (event.key === 'Enter') {
              event.preventDefault(); // Prevent newline insertion
              outputTitle.blur(); // Trigger blur to save and exit edit mode
              console.log("Enter pressed, saving edit.");
            } else if (event.key === 'Escape') {
              event.preventDefault(); // Prevent other escape actions
              // Revert text to original and exit edit mode (blur will handle cleanup)
              outputTitle.textContent = outputTitle.dataset.originalFilename || currentFilename || 'Preview';
              outputTitle.blur();
              console.log("Escape pressed, cancelling edit.");
            }
          }
        });

        outputTitle.addEventListener('blur', () => {
          // Only process if it was actually in edit mode
          if (outputTitle.contentEditable === 'true') {
            console.log("Saving title edit...");
            const originalFilename = outputTitle.dataset.originalFilename || currentFilename || 'Preview'; // Get original name
            const newFilename = outputTitle.textContent.trim();

            // Remove editing state and styles FIRST
            outputTitle.contentEditable = false;
            outputTitle.classList.remove('outline', 'outline-2', 'outline-indigo-500', 'dark:outline-indigo-400', 'bg-white', 'dark:bg-gray-700', 'p-1', '-m-1', 'rounded');
            delete outputTitle.dataset.originalFilename; // Clean up stored original name

            // Validate and save
            if (newFilename && newFilename !== originalFilename) {
              currentFilename = newFilename; // Update state variable
              outputTitle.textContent = currentFilename; // Update display text
              // NEW: If this document was loaded from DB, update its name there too
              if (currentDocId !== null) {
                console.log(`Attempting to update filename in DB for doc ID <span class="math-inline">\{currentDocId\} to "</span>{newFilename}"`);
                updateDocumentFilenameInDB(currentDocId, newFilename)
                  .then(() => {
                    console.log(`Successfully updated filename in DB for doc ID ${currentDocId}.`);
                    // Refresh saved docs list if open, as the name changed
                    if (savedDocsPanel && !savedDocsPanel.classList.contains('-translate-x-full')) {
                      loadAndDisplaySavedDocuments();
                    }
                  })
                  .catch(error => {
                    console.error(`Failed to update filename in DB for doc ID ${currentDocId}:`, error);
                    alert(`Error saving filename change to database: ${error}. Changes might be lost.`);
                    // Optional: Revert UI changes? For now, just alert.
                  });
              }
              outputTitle.title = currentFilename; // Update hover title
              console.log("Filename updated to:", currentFilename);
            } else if (!newFilename) {
              // If name is empty, revert to original
              console.log("Filename cannot be empty, reverting.");
              outputTitle.textContent = originalFilename;
              outputTitle.title = originalFilename;
              currentFilename = originalFilename; // Revert state variable too
            } else {
              // Name didn't change, just ensure display is correct
              outputTitle.textContent = currentFilename;
              outputTitle.title = currentFilename;
            }
          }
        });

        outputTitle.addEventListener('dblclick', () => {
          // Only allow editing if not already editing and content is loaded
          if (outputTitle.contentEditable !== 'true' && rawFileContent !== null) {
            console.log("Enabling title edit...");
            // Store original filename for potential cancellation (Escape key)
            outputTitle.dataset.originalFilename = outputTitle.textContent;
            // Make editable
            outputTitle.contentEditable = true;
            // Add temporary styling to indicate editing
            outputTitle.classList.add('outline', 'outline-2', 'outline-indigo-500', 'dark:outline-indigo-400', 'bg-white', 'dark:bg-gray-700', 'p-1', '-m-1', 'rounded');
            // Focus and select text
            outputTitle.focus();
            // Select all text within the element
            try {
                const range = document.createRange();
                range.selectNodeContents(outputTitle);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
            } catch (e) {
                console.warn("Could not automatically select text for editing:", e);
                // Fallback for older browsers might be needed if execCommand is strictly disallowed
            }
          }
        });
      }

      // Listener for Load/Delete buttons in Saved Docs panel
      if (savedDocsListContainer) {

        // --- Double-click to start editing ---
        savedDocsListContainer.addEventListener('dblclick', (event) => {
          // Check if the double-clicked element is a filename div
          if (event.target.classList.contains('saved-doc-filename')) {
            const filenameElement = event.target;
            // Only allow editing if not already editing
            if (filenameElement.contentEditable !== 'true') {
              console.log(`Editing filename for doc ID: ${filenameElement.dataset.docId}`);
              filenameElement.dataset.originalFilename = filenameElement.textContent; // Store original
              filenameElement.contentEditable = true;
              // Add temporary editing styles (similar to outputTitle)
              filenameElement.classList.add('outline', 'outline-1', 'outline-blue-500', 'dark:outline-blue-400', 'bg-white', 'dark:bg-gray-600', 'p-0.5', '-m-0.5', 'rounded');
              filenameElement.focus();
              // Select text
              try {
                const range = document.createRange();
                range.selectNodeContents(filenameElement);
                const selection = window.getSelection();
                selection.removeAllRanges();
                selection.addRange(range);
              } catch (e) { console.warn("Could not select text:", e); }
            }
          }
        });

        // --- Blur to save changes ---
        savedDocsListContainer.addEventListener('blur', async (event) => { // Mark async for await
          // Check if the blurred element is a filename div AND was editable
          if (event.target.classList.contains('saved-doc-filename') && event.target.contentEditable === 'true') {
            const filenameElement = event.target;
            const docId = parseInt(filenameElement.dataset.docId, 10);
            const originalFilename = filenameElement.dataset.originalFilename || '';
            const newFilename = filenameElement.textContent.trim();

            // Cleanup styles and state FIRST
            filenameElement.contentEditable = false;
            filenameElement.classList.remove('outline', 'outline-1', 'outline-blue-500', 'dark:outline-blue-400', 'bg-white', 'dark:bg-gray-600', 'p-0.5', '-m-0.5', 'rounded');
            delete filenameElement.dataset.originalFilename;

            // Validate and save if changed
            if (newFilename && newFilename !== originalFilename && !isNaN(docId)) {
              console.log(`Attempting to update filename for doc ID <span class="math-inline">\{docId\} to "</span>{newFilename}"`);
              try {
                // Call new function to update DB (defined in next step)
                await updateDocumentFilenameInDB(docId, newFilename);
                filenameElement.textContent = newFilename; // Update display text
                filenameElement.title = newFilename; // Update hover title
                console.log(`Successfully updated filename for doc ID ${docId}.`);
                // Check if this is the currently loaded document
                if (currentDocId === docId) {
                  console.log("Updating main title to match renamed saved doc.");
                  currentFilename = newFilename; // Update state variable for main title
                  outputTitle.textContent = newFilename; // Update main title display
                  outputTitle.title = newFilename; // Update main title tooltip
                }
              } catch (error) {
                console.error(`Failed to update filename for doc ID ${docId}:`, error);
                alert(`Error saving filename: ${error}`);
                // Revert text content on error
                filenameElement.textContent = originalFilename;
                filenameElement.title = originalFilename;
              }
            } else if (!newFilename) {
              // If name is empty, revert
              console.log("Filename cannot be empty, reverting.");
              filenameElement.textContent = originalFilename;
              filenameElement.title = originalFilename;
            } else {
              // Name didn't change or ID was invalid, ensure display is correct
              filenameElement.textContent = originalFilename;
              filenameElement.title = originalFilename;
            }
          }
        }, true); // Use capture phase for blur to catch it reliably

        // --- Keydown to handle Enter/Escape ---
        savedDocsListContainer.addEventListener('keydown', (event) => {
          if (event.target.classList.contains('saved-doc-filename') && event.target.contentEditable === 'true') {
            if (event.key === 'Enter') {
              event.preventDefault(); // Prevent newline
              event.target.blur(); // Trigger blur to save
            } else if (event.key === 'Escape') {
              event.preventDefault(); // Prevent other escape actions
              // Revert text to original and trigger blur to exit edit mode
              event.target.textContent = event.target.dataset.originalFilename || '';
              event.target.blur();
            }
          }
        });

        savedDocsListContainer.addEventListener('click', (event) => {
          const loadButton = event.target.closest('.load-doc-btn');
          const deleteButton = event.target.closest('.delete-doc-btn');

          if (loadButton) {
            console.log('Load Button clicked');
            const docId = parseInt(loadButton.dataset.docId, 10);
            if (!isNaN(docId)) {
              console.log(`Load button clicked for doc ID: ${docId}`);
              loadDocumentFromDB(docId).catch(err => console.log(`Failed to load document: ${err}`));
            }
          } else if (deleteButton) {
            const docId = parseInt(deleteButton.dataset.docId, 10);
            if (!isNaN(docId)) {
              console.log(`Delete button clicked for doc ID: ${docId}`);
              showConfirmDeleteModal(docId);
            }
          }
        });
      }

      // Listener for Save Document button
      if (saveDocButton) {
        saveDocButton.addEventListener('click', saveDocumentToDB);
      }

      // NEW: Listeners for Saved Docs Panel
      if (savedDocsButton) {
          savedDocsButton.addEventListener('click', toggleSavedDocsPanel);
      }
      if (closeSavedDocsPanelButton) {
          closeSavedDocsPanelButton.addEventListener('click', toggleSavedDocsPanel);
      }

      // NEW: Listener to close Saved Docs panel when clicking outside
      document.addEventListener('click', (event) => {
        if (savedDocsPanel && !savedDocsPanel.classList.contains('-translate-x-full') && // If panel is open
            !savedDocsPanel.contains(event.target) && // Click is outside panel
            !savedDocsButton.contains(event.target)) { // Click is not on the toggle button
            toggleSavedDocsPanel(); // Hide panel
        }
      });

      // Listener for Clear Completed Tasks button
      if (clearTasksButton) { // Check if the button was successfully added/found
        clearTasksButton.addEventListener('click', () => {
          console.log("Clearing completed/failed/cancelled tasks...");
          // Filter the array, keeping only tasks that are 'Pending' or 'Running...'
          activeTasks = activeTasks.filter(task => task.status === 'Pending' || task.status === 'Running...');
          // Re-render the list with the filtered array
          
          // Check if there is at least one task that is NOT Pending or Running
          const hasClearableTasks = activeTasks.some(task =>
            task.status !== 'Pending' && task.status !== 'Running...'
          );

          if (hasClearableTasks) {
            clearTasksButton.classList.remove('hidden'); // Show the button
          } else {
            clearTasksButton.classList.add('hidden'); // Hide the button
          }

          renderTasksList();
        });
      }

      // Liten for keydown, cmd + m, events to toggle view mode
      document.addEventListener('keydown', (event) => {        
        if (event.key === 'm' && event.shiftKey && (event.metaKey || event.ctrlKey)) {
            event.preventDefault();
            console.log('Shortcut triggered!');
            toggleViewMode();
        }
      });

      // Dark Mode Toggle Listener
      darkModeToggle.addEventListener('click', toggleDarkMode);
      // ... (keep all existing event listeners)

      // Listener for Cancel buttons ('‚úñ') within the task list container
      taskListContainer.addEventListener('click', (event) => {
        // Check if the clicked element is an individual cancel button ('‚úñ')
        if (event.target.classList.contains('cancel-task-btn')) {
          const buttonElement = event.target;
          const taskIdToCancel = parseInt(buttonElement.dataset.taskId, 10);
          console.log(`Cancel requested for task ID: ${taskIdToCancel}`);

          // Find the task in the main array
          const taskToCancel = activeTasks.find(task => task.id === taskIdToCancel);

          // IMPORTANT: Only cancel if the task is still 'Pending'
          if (taskToCancel && taskToCancel.status === 'Pending') {
            taskToCancel.status = 'Cancelled';
            taskToCancel.message = 'Cancelled by user before start.';
            renderTasksList(); // Update UI to show 'Cancelled' and remove the button
            console.log(`Task #${taskIdToCancel} status set to Cancelled.`);
          } else {
            console.log(`Task #${taskIdToCancel} could not be cancelled (Status: ${taskToCancel?.status})`);
            // Optionally provide user feedback e.g., briefly disable button
            buttonElement.disabled = true; // Visually disable button if clicked when not pending
            setTimeout(() => buttonElement.disabled = false, 500);
          }
        }
      });

      // Add listeners for Batch Run buttons in options panel
      runPlanOnAllBtn.addEventListener('click', () => runBatchTask(promptCreatePlanEl, 'Create Plan Prompt'));
      runGenerateOnAllBtn.addEventListener('click', () => runBatchTask(promptGenerateContentEl, 'Generate Content Prompt'));
      runCheckOnAllBtn.addEventListener('click', () => runBatchTask(promptFactCheckEl, 'Fact Check Prompt'));
      runCustom1OnAllBtn.addEventListener('click', () => runBatchTask(promptCustom1El, 'Custom 1 Prompt'));
      runCustom2OnAllBtn.addEventListener('click', () => runBatchTask(promptCustom2El, 'Custom 2 Prompt'));

      // Save batch delay setting on change
      batchDelayInput.addEventListener('input', (e) => {
        localStorage.setItem('batchDelayValue', e.target.value);
      });

      // Add listener for the Task List Button to toggle the panel
      taskListButton.addEventListener('click', () => {
        console.log("Task list button clicked. Toggling panel visibility."); // Optional log
        // Toggle classes for visibility and position
        taskListPanel.classList.toggle('invisible'); // Toggle accessibility/interaction hiding
        taskListPanel.classList.toggle('opacity-0'); // Toggle transparency
        taskListPanel.classList.toggle('translate-y-full'); // Toggle off-screen position
        // Optionally toggle a visible state class if preferred, e.g., taskListPanel.classList.toggle('visible-state');
      });

      // Add listener for the Load from URL button
      loadFromUrlButton.addEventListener("click", () => {
        const urlValue = mdUrlInput.value.trim();
        if (urlValue && (urlValue.startsWith('http://') || urlValue.startsWith('https://'))) {
          // If URL is valid, fetch and render
          fetchAndRenderMarkdown(urlValue);
          // Optionally clear the input after successful trigger
          // mdUrlInput.value = '';
        } else {
          // Handle invalid or empty URL input
          console.warn("Invalid or empty URL entered:", urlValue);
          mdUrlInput.classList.add('border-red-500'); // Add red border for feedback
          setTimeout(() => { // Remove feedback after a delay
            mdUrlInput.classList.remove('border-red-500');
          }, 2000);
        }
      });

      // Add listeners for Tab buttons
      tabButtonFile.addEventListener('click', () => switchTab('file'));
      tabButtonUrl.addEventListener('click', () => switchTab('url'));

      // Main UI Listeners
      fileInput.addEventListener("change", handleFileSelection); // File input change
      viewRawMdButton.addEventListener("click", showRawMdModal); // "Edit Raw" button click
      viewRenderedButton.addEventListener("click", showRenderedHtmlModal); // "View Rendered" button click
      exportJupyterButton.addEventListener("click", handleExportJupyter); // "Export Jupyter" button click
      saveRawMdButton.addEventListener("click", saveRawMdChanges); // "Save" button in raw editor modal
      newButton.addEventListener("click", showConfirmNewModal); // "New" button click
      refreshPreviewButton.addEventListener("click", handleRefreshPreview); // NEW: Refresh button click

      // Modal Interaction Listeners (closing modals)
      cancelDeleteButton.addEventListener("click", hideConfirmDeleteModal); // Cancel "New" action
      confirmDeleteButton.addEventListener("click", () => {
        // Retrieve the stored docId from the button's dataset
        const docIdStr = confirmDeleteButton.dataset.docId;
        const docIdToDelete = parseInt(docIdStr, 10);

        if (!isNaN(docIdToDelete)) {
          // Call the execution function with the retrieved ID
          executeDeleteDocument(docIdToDelete);
          // Hide the modal after confirmation
          hideConfirmDeleteModal();
        } else {
          console.error("Could not find valid docId on confirm button:", docIdStr);
          alert("Error: Could not determine which document to delete.");
          hideConfirmDeleteModal(); // Still hide modal on error
        }
      });
      closeRawMdModalButton.addEventListener("click", hideRawMdModal);
      rawMdModal.addEventListener("click", (event) => { if (event.target === rawMdModal) hideRawMdModal(); }); // Close if clicking overlay
      closeRenderedModalButton.addEventListener("click", hideRenderedHtmlModal);
      renderedHtmlModal.addEventListener("click", (event) => { if (event.target === renderedHtmlModal) hideRenderedHtmlModal(); }); // Close if clicking overlay
      cancelNewButton.addEventListener("click", hideConfirmNewModal); // Cancel "New" action
      confirmNewButton.addEventListener("click", executeNewDocument); // Confirm "New" action
      confirmNewModal.addEventListener("click", (event) => { if (event.target === confirmNewModal) hideConfirmNewModal(); }); // Close if clicking overlay
      closeJupyterJsonModalButton.addEventListener("click", hideJupyterJsonModal);
      jupyterJsonModal.addEventListener("click", (event) => { if (event.target === jupyterJsonModal) hideJupyterJsonModal(); }); // Close if clicking overlay
      copyJupyterJsonButton.addEventListener("click", copyJupyterJsonToClipboard); // Copy Jupyter JSON
      jupyterHelpIcon.addEventListener("click", showJupyterHelpModal); // Show Jupyter help
      closeJupyterHelpModalButton.addEventListener("click", hideJupyterHelpModal);
      closeJupyterHelpModalButtonOk.addEventListener("click", hideJupyterHelpModal); // "Understood" button in help
      jupyterHelpModal.addEventListener("click", (event) => { if (event.target === jupyterHelpModal) hideJupyterHelpModal(); }); // Close if clicking overlay

      // Gemini Panel Listeners
      toggleGeminiPanelButton.addEventListener("click", toggleGeminiPanel); // Toggle panel visibility
      closeGeminiPanelButton.addEventListener("click", hideGeminiPanel); // Close panel button
      // Close panel if clicking outside of it
      document.addEventListener('click', (event) => {
        if (geminiOptionsPanel.classList.contains('visible') &&
            !geminiOptionsPanel.contains(event.target) && // Click is outside panel
            !toggleGeminiPanelButton.contains(event.target)) { // Click is not on the toggle button
          hideGeminiPanel();
        }
      });
       // Handle API key changes to fetch models
       geminiApiKeyInput.addEventListener('change', handleApiKeyChange);
       // Save selected model to localStorage and update UI
       geminiModelSelect.addEventListener('change', (event) => {
           localStorage.setItem('selectedGeminiModel', event.target.value);
           console.log('Selected Gemini Model saved:', event.target.value);
           updateActiveModelIndicator();
           resetTokenCountDisplay(); // Reset counts when model changes
       });
       // Handle click on the test prompt button
       sendPromptButton.addEventListener('click', handleSendPromptClick);
       // Save custom prompts to localStorage on change
       promptCreatePlanEl.addEventListener('change', (e) => localStorage.setItem('promptCreatePlanValue', e.target.value));
       promptGenerateContentEl.addEventListener('change', (e) => localStorage.setItem('promptGenerateContentValue', e.target.value));
       promptFactCheckEl.addEventListener('change', (e) => localStorage.setItem('promptFactCheckValue', e.target.value));
       promptCustom1El.addEventListener('change', (e) => localStorage.setItem('promptCustom1Value', e.target.value));
       promptCustom2El.addEventListener('change', (e) => localStorage.setItem('promptCustom2Value', e.target.value));


      // Global Key Listener (for Escape key to close modals/panel)
      document.addEventListener("keydown", (event) => {
        if (event.key === "Escape") {
          if (!rawMdModal.classList.contains("hidden")) hideRawMdModal();
          if (!renderedHtmlModal.classList.contains("hidden")) hideRenderedHtmlModal();
          if (!confirmNewModal.classList.contains("hidden")) hideConfirmNewModal();
          if (!jupyterJsonModal.classList.contains("hidden")) hideJupyterJsonModal();
          if (!jupyterHelpModal.classList.contains("hidden")) hideJupyterHelpModal();
          if (geminiOptionsPanel.classList.contains("visible")) hideGeminiPanel();
        }
      });

      // --- Functions ---

      /**
       * Converts an ArrayBuffer to a Base64 string.
       * @param {ArrayBuffer} buffer - The buffer to convert.
       * @returns {string} The Base64 encoded string.
       */
      function arrayBufferToBase64(buffer) {
        let binary = '';
        const bytes = new Uint8Array(buffer);
        const len = bytes.byteLength;
        for (let i = 0; i < len; i++) {
          binary += String.fromCharCode(bytes[i]);
        }
        return window.btoa(binary);
      }

      /**
       * Generates a new random AES-GCM key.
       * @returns {Promise<CryptoKey>} A promise that resolves with the generated CryptoKey.
       */
      async function generateNewCryptoKey() {
        try {
          const key = await crypto.subtle.generateKey(
            {
              name: "AES-GCM",
              length: 256, // Key length (128, 192, or 256)
            },
            true, // Make key extractable=true if you need to export/show it later
            ["encrypt", "decrypt"] // Key usages
          );
          console.log("New random key generated successfully.");
          // IMPORTANT: Since extractable is false, this key exists only in memory for this session.
          // The user cannot recover it later without exporting/saving it somehow.
          alert("New encryption key generated for this session as password field was empty. This key cannot be recovered if you close the page unless you explicitly export it (export feature not implemented).");
          return key;
        } catch (error) {
          console.error("Error generating new key:", error);
          throw new Error("Failed to generate new encryption key.");
        }
      }

      /**
       * Derives an AES-GCM key from a password using PBKDF2.
       * NOTE: Uses a hardcoded salt for now - MUST be replaced with unique salt per document later.
       * @param {string} password - The password input.
       * @returns {Promise<CryptoKey>} A promise that resolves with the derived CryptoKey.
       */
      async function deriveKeyFromPassword(password) {
        if (!password) {
          throw new Error("Password cannot be empty for key derivation.");
        }
        const enc = new TextEncoder();
        const passwordBuffer = enc.encode(password);

        // --- IMPORTANT SECURITY NOTE ---
        // Using a FIXED salt is insecure. In a real implementation, you MUST:
        // 1. Generate a unique, random salt for EACH document using crypto.getRandomValues(new Uint8Array(16)).
        // 2. Store this unique salt alongside the encrypted data in IndexedDB.
        // 3. Retrieve the correct salt when decrypting.
        // Using a fixed salt here for simplicity of demonstration ONLY.
        const salt = enc.encode("fixedSalt_ReplaceMe!"); // REPLACE THIS LATER

        const iterations = 100000; // Number of iterations (increase if possible)
        const hash = 'SHA-256';

        // 1. Import the password as base key material for PBKDF2
        const baseKey = await crypto.subtle.importKey(
          "raw",
          passwordBuffer,
          { name: "PBKDF2" },
          false, // not extractable
          ["deriveKey"]
        );

        // 2. Derive the AES-GCM key
        const derivedKey = await crypto.subtle.deriveKey(
          {
            "name": "PBKDF2",
            salt: salt,
            iterations: iterations,
            hash: hash
          },
          baseKey,
          { "name": "AES-GCM", "length": 256 }, // Algorithm to derive key for
          false, // not extractable
          ["encrypt", "decrypt"] // Key usages
        );

        console.log("Key derived from password successfully.");
        return derivedKey;
      }

      /**
       * Updates the filename for a specific document in IndexedDB.
       * @param {number} docId - The ID of the document to update.
       * @param {string} newFilename - The new filename.
       * @returns {Promise<void>} A promise that resolves on success or rejects on error.
       */
      function updateDocumentFilenameInDB(docId, newFilename) {
        return new Promise((resolve, reject) => {
          if (!db) return reject("Database not initialized.");
          if (!newFilename) return reject("New filename cannot be empty.");

          try {
            const transaction = db.transaction(['documents'], 'readwrite');
            const store = transaction.objectStore('documents');
            const getRequest = store.get(docId); // First, get the existing record

            getRequest.onerror = (event) => {
              console.error(`Error getting document ${docId} for update:`, event.target.error);
              reject(`Error finding document: ${event.target.error}`);
            };

            getRequest.onsuccess = (event) => {
              const record = event.target.result;
              if (record) {
                // Record found, update the filename
                record.filename = newFilename;
                const updateRequest = store.put(record); // Put the modified record back

                updateRequest.onerror = (event) => {
                  console.error(`Error updating filename for doc ${docId}:`, event.target.error);
                  reject(`Error updating filename: ${event.target.error}`);
                };
                updateRequest.onsuccess = () => {
                  console.log(`Filename updated for doc ${docId}.`);
                  resolve(); // Successfully updated
                };
              } else {
                // Record not found
                console.error(`Document ${docId} not found for update.`);
                reject(`Document ${docId} not found.`);
              }
            };

            transaction.onerror = (event) => { // Catch transaction errors too
                console.error("Update filename transaction error:", event.target.error);
                reject(`Transaction error: ${event.target.error}`);
            };

          } catch (error) {
              console.error("Error starting transaction for update:", error);
              reject(`Error starting transaction: ${error.message}`);
          }
        });
      }

      /**
       * Deletes a specific document from IndexedDB after confirmation.
       * @param {number} docId - The ID of the document to delete.
       */
      function deleteDocumentFromDB(docId) {
        return new Promise((resolve, reject) => {
          if (!db) return reject("Database not initialized.");

          try {
              const transaction = db.transaction(['documents'], 'readwrite'); // Need readwrite to delete
              const store = transaction.objectStore('documents');
              const request = store.delete(docId); // Delete by ID

              request.onerror = (event) => {
                  console.error(`Error deleting document ID ${docId}:`, event.target.error);
                  reject(`Error deleting document: ${event.target.error}`);
              };

              request.onsuccess = () => {
                  console.log(`Document ID ${docId} deleted successfully.`);
                  resolve(true); // Resolve indicating success
              };

              transaction.oncomplete = () => {
                  console.log("Delete transaction completed.");
                  // Refresh the list after deletion transaction completes
                  loadAndDisplaySavedDocuments();
              };
              transaction.onerror = (event) => {
                  console.error("Delete transaction error:", event.target.error);
                  // Reject might have already happened via request.onerror
              };
          } catch (error) {
              console.error("Error starting transaction for delete:", error);
              reject(`Error starting transaction: ${error.message}`);
          }

        });
      }

      /**
       * Loads a specific document from IndexedDB into the editor.
       * @param {number} docId - The ID of the document to load.
       */
      function loadDocumentFromDB(docId) {
        return new Promise((resolve, reject) => {
          if (!db) return reject("Database not initialized.");

          try {
              const transaction = db.transaction(['documents'], 'readonly');
              const store = transaction.objectStore('documents');
              const request = store.get(docId); // Get by ID

              request.onerror = (event) => {
                  console.error(`Error loading document ID ${docId}:`, event.target.error);
                  reject(`Error loading document: ${event.target.error}`);
              };

              request.onsuccess = (event) => {
                  const doc = event.target.result;
                  if (doc) {
                      console.log("Loading document:", doc.filename);
                      rawFileContent = doc.content;
                      currentFilename = doc.filename;
                      outputTitle.textContent = currentFilename;
                      outputTitle.title = currentFilename;
                      fileInput.value = null; // Clear file input
                      console.log(`Set currentDocId to: ${currentDocId}`);
                      currentDocId = doc.id; // Store the ID of the loaded doc
                      
                      // Render based on filename convention
                      if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
                          renderMindMap(rawFileContent);
                      } else {
                          renderParsedContent(rawFileContent);
                      }
                      // Close the panel after loading
                      toggleSavedDocsPanel();
                      enableActionButtons(); // Ensure buttons are enabled
                      resolve(doc); // Resolve with the loaded document
                  } else {
                      console.error(`Document with ID ${docId} not found.`);
                      reject(`Document with ID ${docId} not found.`);
                  }
              };
          } catch (error) {
              console.error("Error starting transaction for get:", error);
              reject(`Error starting transaction: ${error.message}`);
          }
        });
      }

      /**
       * Fetches all saved documents and displays them in the panel.
       */
      async function loadAndDisplaySavedDocuments() {
        console.log("Loading saved documents...");
        if (!savedDocsListContainer) return;
        savedDocsListContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">Loading...</p>'; // Show loading state

        try {
          const docs = await getAllSavedDocuments();
          displaySavedDocuments(docs);
        } catch (error) {
          console.error("Failed to load and display documents:", error);
          savedDocsListContainer.innerHTML = `<p class="text-sm text-red-500 dark:text-red-400">Error loading documents: ${error}</p>`;
        }
      }
      
      /**
       * Displays a list of saved documents in the panel.
       * @param {Array<object>} docs - An array of document objects from IndexedDB.
       */
      function displaySavedDocuments(docs) {
        if (!savedDocsListContainer) return;
        savedDocsListContainer.innerHTML = ''; // Clear previous list

        if (!docs || docs.length === 0) {
          savedDocsListContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">No documents saved yet.</p>';
          return;
        }

        // Sort documents, newest first (optional, based on ID or savedAt)
        docs.sort((a, b) => b.id - a.id); // Sort by descending ID

        docs.forEach(doc => {
          const docElement = document.createElement('div');
          docElement.className = 'p-2 border-b border-gray-200 dark:border-gray-700 flex justify-between items-center text-sm';

          const dateString = doc.savedAt ? doc.savedAt.toLocaleString() : 'N/A';
          const filenameDisplay = doc.filename || `Document #${doc.id}`;

          docElement.innerHTML = `
            <div class="flex-grow mr-2 overflow-hidden">
              <div class="saved-doc-filename font-medium text-gray-800 dark:text-gray-100 truncate" title="${filenameDisplay}" data-doc-id="${doc.id}">${filenameDisplay}</div>              <div class="text-xs text-gray-500 dark:text-gray-400"><span class="math-inline">${dateString}</span></div>
              </div>
                <div class="flex-shrink-0 space-x-1">
                  <button class="load-doc-btn p-1 text-blue-600 dark:text-blue-400 hover:text-blue-800 dark:hover:text-blue-300" data-doc-id="${doc.id}" title="Load Document">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" 1  d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" ></svg>
                  </button>
                  <button class="delete-doc-btn p-1 text-red-500 dark:text-red-400 hover:text-red-700 dark:hover:text-red-300" data-doc-id="${doc.id}" title="Delete Document">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2"><path stroke-linecap="round" stroke-linejoin="round" 3  d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" ></svg>
                  </button>
              </div>
              `;
          savedDocsListContainer.appendChild(docElement); 4 
        });
      }

      /**
       * Retrieves all documents from the IndexedDB store.
       * @returns {Promise<Array<object>>} A promise that resolves with an array of document objects.
       */
      function getAllSavedDocuments() {
        return new Promise((resolve, reject) => {
          if (!db) {
            console.error("DB not initialized.");
            return reject("Database not initialized.");
          }
          try {
            const transaction = db.transaction(['documents'], 'readonly');
            const store = transaction.objectStore('documents');
            const request = store.getAll(); // Request to get all records

            request.onerror = (event) => {
              console.error("Error fetching documents:", event.target.error);
              reject(`Error fetching documents: ${event.target.error}`);
            };

            request.onsuccess = (event) => {
              console.log("Successfully fetched documents.");
              resolve(event.target.result); // Resolve the promise with the array of documents
            };
          } catch (error) {
              console.error("Error starting transaction for getAll:", error);
              reject(`Error starting transaction: ${error.message}`);
          }
        });
      }

      /**
       * Saves the current rawFileContent to the IndexedDB 'documents' store.
       */
      function saveDocumentToDB() {
        if (!db) {
          alert("Database not initialized. Cannot save.");
          console.error("Save failed: DB not initialized.");
          return;
        }
        if (rawFileContent === null || rawFileContent.trim() === '') {
          alert("Nothing to save. Content is empty.");
          return;
        }

        // Create the object to save
        const docToSave = {
          content: rawFileContent,
          filename: currentFilename || `Untitled - ${new Date().toISOString()}`, // Use current filename or generate one
          savedAt: new Date()
          // 'id' will be auto-generated by IndexedDB
        };

        console.log("Attempting to save document:", docToSave.filename);

        // Start a readwrite transaction
        try {
          const transaction = db.transaction(['documents'], 'readwrite');
          const store = transaction.objectStore('documents');

          // Add the document object to the store
          const request = store.add(docToSave);

          request.onsuccess = (event) => {
            const newId = event.target.result; // Get the new ID
            console.log("Document saved successfully with ID:", newId);

            // --- NEW LINE TO ADD ---
            currentDocId = newId; // Update the global state variable
            // --- END NEW LINE ---

            alert(`Document "${docToSave.filename}" saved successfully!`);
            // Optional: Refresh saved docs list if open
            if (savedDocsPanel && !savedDocsPanel.classList.contains('-translate-x-full')) {
              loadAndDisplaySavedDocuments();
            }
          };

          request.onerror = (event) => {
            console.error("Error saving document:", event.target.error);
            alert(`Error saving document: ${event.target.error}`);
          };

          transaction.oncomplete = () => {
            console.log("Save transaction completed.");
          };

          transaction.onerror = (event) => {
            console.error("Save transaction error:", event.target.error);
            alert(`Save transaction error: ${event.target.error}`);
          };

        } catch (error) {
            console.error("Error starting save transaction:", error);
            alert(`Error starting save transaction: ${error.message}`);
        }
      }

      /**
       * Initializes the IndexedDB database.
       */
      function initDB() {
        // Request to open the database 'InteractiveCourseDB', version 1
        const request = indexedDB.open('InteractiveCourseDB', 1);

        // Handle errors during database opening
        request.onerror = (event) => {
          console.error("IndexedDB error:", event.target.errorCode);
          alert("Error initializing local database. Saving will not work.");
        };

        // Handle successful database opening
        request.onsuccess = (event) => {
          db = event.target.result; // Store the database instance globally
          console.log("IndexedDB initialized successfully.");
          // You could potentially load saved documents here if needed on startup
        };

        // Handle database upgrades (creating object stores)
        request.onupgradeneeded = (event) => {
          console.log("Upgrading IndexedDB...");
          const tempDb = event.target.result;

          // Create an object store called 'documents' if it doesn't exist
          // Use 'id' as the key path and let it auto-increment
          if (!tempDb.objectStoreNames.contains('documents')) {
            const store = tempDb.createObjectStore('documents', { keyPath: 'id', autoIncrement: true });
            console.log("Created 'documents' object store.");
            // Optional: Create indexes for searching later (e.g., by filename or date)
            // store.createIndex('filename', 'filename', { unique: false });
            // store.createIndex('savedAt', 'savedAt', { unique: false });
          }
        };
      }

      /**
       * Toggles the visibility of the Saved Documents panel.
       */
      function toggleSavedDocsPanel() {
        if (!savedDocsPanel) return;
        const isOpen = !savedDocsPanel.classList.contains('-translate-x-full');
        if (isOpen) {
          savedDocsPanel.classList.add('-translate-x-full');
          console.log("Saved docs panel hidden.");
        } else {
          savedDocsPanel.classList.remove('-translate-x-full');
          console.log("Saved docs panel shown.");
          loadAndDisplaySavedDocuments();
        }
      }

      // (Keep all existing functions: delay, runBatchTask, renderTasksList, switchTab, loadMarkdownFromUrl, fetchAndRenderMarkdown, handleFileSelection, renderParsedContent, etc.)
      // MODIFY renderMindMap and add redrawMindMap

      /** Simple delay function */
      const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

      /**
       * Runs a specified task on all textareas in the preview with a delay,
       * adding tasks as 'Pending' first and allowing individual cancellation.
       * @param {HTMLTextAreaElement} promptElement - The textarea element containing the prompt to use.
       * @param {string} promptLabel - The user-friendly label for the prompt/task type.
       */
      async function runBatchTask(promptElement, promptLabel) {
        // Get delay, default to 1 second if input is invalid or empty
        let delaySeconds = parseInt(batchDelayInput.value, 10);
        if (isNaN(delaySeconds) || delaySeconds < 0) {
          delaySeconds = 1; // Default to 1 second
        }
        const delayMs = delaySeconds * 1000;
        console.log(`Starting batch job: ${promptLabel} with ${delaySeconds}s delay.`);

        const textareas = document.querySelectorAll('#output .content-textarea');
        if (textareas.length === 0) {
          alert("No text areas found in the preview to process.");
          return; // Exit if no textareas
        }

        const batchTimestamp = new Date(); // Use same timestamp for all related tasks
        const batchModel = geminiModelSelect.value; // Use same model
        const tasksForThisBatch = []; // Array to hold the task objects created for this run

        // --- Create all task objects as 'Pending' first ---
        textareas.forEach((textarea, index) => {
          const taskId = nextTaskId++;
          const taskType = `${promptLabel.replace(/ Prompt/, '')} (Section ${index + 1})`;
          const newTask = {
            id: taskId,
            type: taskType,
            status: 'Pending', // Initial status
            message: '',
            timestamp: batchTimestamp,
            model: batchModel
          };
          activeTasks.push(newTask);
          tasksForThisBatch.push(newTask); // Keep track of tasks for this specific batch run
        });

        renderTasksList(); // Render all newly added 'Pending' tasks at once
        // Optional: ensure panel is visible
        if (taskListPanel.classList.contains('invisible')) {
          taskListButton.click();
        }
        // --- End Create Pending Tasks ---

        console.log(`Batch loop starting for ${tasksForThisBatch.length} tasks.`);
        try {
          // Loop through the tasks created specifically for this batch
          for (const [index, taskToRun] of tasksForThisBatch.entries()) {

            // Find the task's current state in the main activeTasks array
            const currentTaskState = activeTasks.find(t => t.id === taskToRun.id);

            // Check if task was cancelled while pending or doesn't exist anymore
            if (!currentTaskState || currentTaskState.status !== 'Pending') {
              console.log(`Skipping task #${taskToRun.id} as its status is ${currentTaskState?.status || 'unknown (removed?)'}.`);
              continue; // Skip to the next task in the loop
            }

            // Update status to Running *before* execution
            currentTaskState.status = 'Running...';
            currentTaskState.message = `Processing section ${index + 1}...`;
            renderTasksList(); // Show it's running

            console.log(`Processing section ${index + 1} of ${tasksForThisBatch.length} with task: ${promptLabel}`);

            // Call the actual handler, passing the task ID so it updates the correct task object
            // NOTE: Assumes handleMainViewPrompt is modified to accept taskId as the last argument
            await handleMainViewPrompt(null, textareas[index], promptElement, promptLabel, taskToRun.id);

            // Add delay if not the last item
            if (index < tasksForThisBatch.length - 1) {
              console.log(`Waiting ${delaySeconds}s...`);
              // Find task again in case handleMainViewPrompt already updated it
              const taskAfterRun = activeTasks.find(t => t.id === taskToRun.id);
              if(taskAfterRun) { // Check if task still exists
                  // Avoid overwriting final status message if already completed/failed quickly
                  if (taskAfterRun.status === 'Running...') {
                    taskAfterRun.message = `Waiting ${delaySeconds}s before next section...`;
                    renderTasksList(); // Update before delay
                  }
              }
              await delay(delayMs);
            }
          }
        } catch (batchError) {
          // This catch block handles errors in the loop itself, not errors within handleMainViewPrompt
          console.error("Error during batch processing loop:", batchError);
          // Individual task failures should be handled within handleMainViewPrompt
        } finally {
          console.log("Batch processing loop finished.");
          renderTasksList(); // Final render to ensure UI is up-to-date
          // No isBatchJobRunning flag to reset in this version
        }
      }

      /**
       * Renders the current list of tasks into the task list panel.
       */
      function renderTasksList() {
        // Ensure the container element exists before proceeding
        if (!taskListContainer) {
            console.error("Task list container not found.");
            return;
        }
        taskListContainer.innerHTML = ''; // Clear previous list

        if (activeTasks.length === 0) {
          taskListContainer.innerHTML = '<p class="text-sm text-gray-500 dark:text-gray-400">No active tasks.</p>'; // Added dark text
          return;
        }

        // Render tasks (newest first is often helpful)
        [...activeTasks].reverse().forEach(task => {
          const taskDiv = document.createElement('div');
          // Add styling for each task item
          taskDiv.className = 'p-2 border border-gray-200 dark:border-gray-600 rounded text-xs mb-2 bg-gray-50 dark:bg-gray-700'; // Light background and border

        if (clearTasksButton) { // Check if button element exists
          // Check if there is at least one task that is NOT Pending or Running
          const hasClearableTasks = activeTasks.some(task =>
            task.status !== 'Pending' && task.status !== 'Running...'
          );

          if (hasClearableTasks) {
            clearTasksButton.classList.remove('hidden'); // Show the button
          } else {
            clearTasksButton.classList.add('hidden'); // Hide the button
          }
        }

        // Add individual Cancel button HTML conditionally for PENDING tasks
        const cancelButtonHtml = (task.status === 'Pending')
          ? `<button class="cancel-task-btn ml-2 text-red-500 hover:text-red-700 dark:text-red-400 dark:hover:text-red-500 font-bold" data-task-id="${task.id}" title="Cancel Task">‚úñ</button>` // Added dark colors
          : ''; // No button for other statuses

          // Determine status color (using light theme colors)
          let statusColor = '';
          if (task.status === 'Pending') {
              statusColor = 'text-blue-600 dark:text-blue-400'; // Color for Pending
          } else if (task.status === 'Running...') {
              statusColor = 'text-yellow-600 dark:text-yellow-400';
          } else if (task.status === 'Completed') {
              statusColor = 'text-green-600 dark:text-green-400';
          } else if (task.status === 'Failed') {
              statusColor = 'text-red-600 dark:text-red-400';
          } else if (task.status === 'Cancelled') {
              statusColor = 'text-gray-500 dark:text-gray-400'; // Color for Cancelled
          }

          // Sanitize message content before inserting as HTML to prevent XSS
          // A simple text replacement is shown here, consider a more robust sanitizer if needed
          const sanitizedMessage = (task.message || '').replace(/</g, "&lt;").replace(/>/g, "&gt;");

          taskDiv.innerHTML = `
            <div class="mb-1">
              <div class="font-semibold text-gray-900 dark:text-gray-50">Task #<span class="math-inline">${task.id}</span>: ${task.type}</div>
              <div class="text-gray-500 dark:text-gray-400 text-[10px]">${task.model.split('/')[1]}</span></div>
              <div class="text-gray-500 dark:text-gray-400 text-[10px]"><span class="math-inline">${task.timestamp.toLocaleTimeString()}</span></div>
            </div>
            <div class="text-gray-700 dark:text-gray-300">Status: <span class="font-medium ${statusColor}">${task.status}</span>${cancelButtonHtml}</div>

            ${sanitizedMessage ? `<div class="mt-1 pt-1 border-t border-gray-200 dark:border-gray-600 text-gray-600 dark:text-gray-400 text-[11px] whitespace-pre-wrap break-words">${sanitizedMessage}</div>` : ''}
            `
          taskListContainer.appendChild(taskDiv);
        });
      }

      /**
       * Switches the active tab and panel for file/URL loading.
       * @param {'file' | 'url'} activeTab - The tab to activate ('file' or 'url').
       */
      function switchTab(activeTab) {
        const fileClassesActive = ['border-indigo-500', 'dark:border-indigo-400', 'text-indigo-600', 'dark:text-indigo-400'];
        const fileClassesInactive = ['border-transparent', 'text-gray-500', 'dark:text-gray-400', 'hover:text-gray-700', 'dark:hover:text-gray-200', 'hover:border-gray-300', 'dark:hover:border-gray-600'];
        const urlClassesActive = ['border-indigo-500', 'dark:border-indigo-400', 'text-indigo-600', 'dark:text-indigo-400'];
        const urlClassesInactive = ['border-transparent', 'text-gray-500', 'dark:text-gray-400', 'hover:text-gray-700', 'dark:hover:text-gray-200', 'hover:border-gray-300', 'dark:hover:border-gray-600'];

        if (activeTab === 'file') {
          tabButtonFile.classList.remove(...fileClassesInactive);
          tabButtonFile.classList.add(...fileClassesActive);
          tabButtonFile.setAttribute('aria-current', 'page');

          tabButtonUrl.classList.remove(...urlClassesActive);
          tabButtonUrl.classList.add(...urlClassesInactive);
          tabButtonUrl.removeAttribute('aria-current');

          tabPanelFile.classList.remove('hidden');
          tabPanelUrl.classList.add('hidden');

        } else if (activeTab === 'url') {
          tabButtonFile.classList.remove(...fileClassesActive);
          tabButtonFile.classList.add(...fileClassesInactive);
          tabButtonFile.removeAttribute('aria-current');

          tabButtonUrl.classList.remove(...urlClassesInactive);
          tabButtonUrl.classList.add(...urlClassesActive);
          tabButtonUrl.setAttribute('aria-current', 'page');

          tabPanelFile.classList.add('hidden');
          tabPanelUrl.classList.remove('hidden');
        }
        console.log(`Switched to ${activeTab} tab.`); // Optional log
      }

      /**
       * Checks the URL hash on page load for a markdownUrl parameter and loads it.
       */
      function loadMarkdownFromUrl() {
        if (window.location.hash && window.location.hash.startsWith('#markdownUrl=')) {
          const encodedUrl = window.location.hash.substring('#markdownUrl='.length);
          try {
            const decodedUrl = decodeURIComponent(encodedUrl);
            // Basic validation
            if (decodedUrl.startsWith('http://') || decodedUrl.startsWith('https://')) {
              fetchAndRenderMarkdown(decodedUrl);
            } else {
              console.warn("Invalid URL found in hash:", decodedUrl);
              outputDiv.innerHTML = `<p class="text-orange-500 dark:text-orange-400">Invalid URL format provided in the address bar.</p>`;
            }
          } catch (e) {
            console.error("Error decoding URL from hash:", e);
            outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Could not decode the URL from the address bar.</p>`;
          }
        } else {
            // If no valid hash, ensure placeholder is shown (might already be handled by initial setup)
            if (!rawFileContent && !document.getElementById('mindMapCanvas') && outputDiv.innerHTML === "") {
              outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">${initialPlaceholderText}</p>`;
              disableActionButtonsButKeepNewEnabled();
            }
        }
      }

      /**
       * Fetches Markdown content from a given URL and renders it.
       * @param {string} url - The URL to fetch the Markdown file from.
       */
      async function fetchAndRenderMarkdown(url) {
        console.log(`Attempting to fetch Markdown from: ${url}`);
        // Display loading state
        outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">Loading from URL...</p>`;
        outputTitle.textContent = "Loading...";
        outputTitle.title = "Loading...";
        currentFilename = null;
        rawFileContent = null;
        disableActionButtonsButKeepNewEnabled(); // Disable buttons during load

        try {
          const response = await fetch(url, { mode: 'cors' }); // Use CORS mode

          if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
          }

          const markdownText = await response.text();
          rawFileContent = markdownText; // Store fetched content

          // Try to extract a filename from the URL for display
          try {
              const urlParts = new URL(url);
              currentFilename = urlParts.pathname.split('/').pop() || "Loaded from URL";
          } catch (e) {
              // If URL parsing fails, use a generic name
              currentFilename = "Loaded from URL";
          }
          outputTitle.textContent = currentFilename;
          outputTitle.title = currentFilename;
          fileInput.value = null; // Clear file input as we loaded from URL

          console.log(`Successfully fetched content. Filename inferred as: ${currentFilename}`);

          // Render based on inferred filename
          if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              console.log("Rendering as mind map...");
              renderMindMap(rawFileContent);
          } else {
              console.log("Rendering as standard markdown...");
              renderParsedContent(rawFileContent);
          }
          // Note: enableActionButtons() is called within renderMindMap/renderParsedContent if successful

        } catch (error) {
          console.error("Failed to fetch or render Markdown from URL:", error);
          outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error loading from URL: ${error.message}. Check the URL and CORS policy.</p>`;
          outputTitle.textContent = "Error Loading";
          outputTitle.title = "Error Loading";
          rawFileContent = null;
          currentFilename = null;
          disableActionButtonsButKeepNewEnabled();
        }
      }

      /**
       * Handles the selection of a Markdown file.
       * Reads the file content and triggers rendering.
       * @param {Event} event - The file input change event.
       */
      function handleFileSelection(event) {
        const file = event.target.files[0]; // Get the selected file

        // Reset UI state
        currentDocId = null; // Reset ID when loading from file
        outputTitle.textContent = "Preview";
        outputTitle.title = "Preview";
        currentFilename = null;
        outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">Loading...</p>`;
        disableActionButtonsButKeepNewEnabled(); // Disable most actions during load

        // If no file is selected (e.g., user cancels), treat as "New"
        if (!file) {
            executeNewDocument();
            console.log("File selection cancelled, treating as 'New'.");
            return;
        }

        // Validate file type
        if (!file.name.toLowerCase().endsWith(".md")) {
            outputDiv.innerHTML = '<p class="text-red-500 dark:text-red-400">Please select a valid .md file.</p>';
            fileInput.value = null; // Clear the invalid selection
            return;
        }

        // Store filename and update title
        currentFilename = file.name;
        outputTitle.textContent = currentFilename;
        outputTitle.title = currentFilename;

        // Read the file content
        const reader = new FileReader();
        reader.onload = (loadEvent) => {
            rawFileContent = loadEvent.target.result; // Store the raw content
            // Check if it's a mind map file based on filename convention
            if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
                console.log("Mind map file detected...");
                renderMindMap(rawFileContent); // Render as mind map
            } else {
                console.log("Standard markdown file...");
                renderParsedContent(rawFileContent); // Render as standard parsed content
            }
        };
        reader.onerror = (errorEvent) => {
            // Handle file reading errors
            console.error("File Read Error:", errorEvent.target.error);
            outputDiv.innerHTML = '<p class="text-red-500 dark:text-red-400">Error reading file.</p>';
            rawFileContent = null;
            currentFilename = null;
            outputTitle.textContent = "Preview";
            outputTitle.title = "Preview";
            disableActionButtonsButKeepNewEnabled();
            fileInput.value = null; // Clear the input
        };
        reader.readAsText(file); // Start reading the file as text
      }

      /**
       * Renders standard Markdown content into editable sections in the main output area.
       * Splits content by headers (H1-H6) and creates textareas for editing.
       * @param {string} markdownText - The raw Markdown text.
       */
      function renderParsedContent(markdownText) {
          // Clear previous output and reset height
          outputDiv.innerHTML = "";
          outputDiv.style.height = 'auto'; // Reset height for standard view

          // Handle empty input
          if (!markdownText || !markdownText.trim()) {
              outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400" id="outputPlaceholder">${initialPlaceholderText}</p>`;
              outputTitle.textContent = "Preview";
              outputTitle.title = "Preview";
              currentFilename = null;
              disableActionButtonsButKeepNewEnabled();
              return;
          }

          // Update title
          outputTitle.textContent = currentFilename || "Preview";
          outputTitle.title = currentFilename || "Preview";

          // Preprocess lines: remove potential unwanted quotes from source
          const lines = markdownText.split("\n").map(line => line.replaceAll(/(\* *)\"/g, "$1").replace(/^\"/g, "").replace(/\"$/g, ""));

          let currentHeaderElement = null; // Holds the current header element being processed
          let contentBlock = []; // Holds lines of content belonging to the current header
          let foundHeaders = false; // Flag if any headers were found
          let currentAnimationDelay = 0; // Delay for staggered animation
  
          /**
           * Helper function to finalize and append a subsection (header + content textarea)
           * to the outputDiv, applying animations and adding action buttons.
           * @param {HTMLElement | null} headerElem - The header element (H1-H6) or null.
           * @param {string} contentText - The text content for the textarea.
           */
          function finalizeSubsection(headerElem, contentText) {
              // Skip if both header and content are effectively empty
              if (!headerElem && (!contentText || !contentText.trim())) return;

              // Create a wrapper for animation and spacing
              const wrapperDiv = document.createElement("div");
              wrapperDiv.classList.add("subsection-wrapper"); // For animation and spacing

              // Add header if it exists
              if (headerElem) {
                  wrapperDiv.appendChild(headerElem);
              }

              // Create and add textarea if content exists
              const textareaElem = createContentTextarea(contentText);
              if (textareaElem) {
                  // Create a container for the textarea and its action buttons
                  const textActionContainer = document.createElement('div');
                  textActionContainer.className = 'flex items-start gap-2 mt-2'; // Flex layout, vertical alignment, spacing

                  // Make textarea grow to fill available width
                  textareaElem.classList.add('flex-grow');
                  textActionContainer.appendChild(textareaElem);

                  // Create a column for action buttons
                  const buttonColumn = document.createElement('div');
                  buttonColumn.className = 'flex flex-col space-y-1 flex-shrink-0'; // Vertical layout, spacing, prevent shrinking

                  // Add 5 action buttons (linked to Gemini prompts)
                  for (let i = 0; i < 5; i++) {
                      const btn = document.createElement('button');
                      btn.className = 'main-view-action-button'; // Apply styling

                      // Assign specific actions and tooltips based on button index
                      if (i === 0) { // Button 1 -> Create Plan Prompt
                          let icon = 'üó∫Ô∏è';
                          btn.textContent = `${icon}`; // Placeholder label
                          btn.title = `Action ${icon}`; // Default tooltip
                          btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptCreatePlanEl, 'Create Plan Prompt'));
                          btn.title = `Send with Create Plan Prompt`;
                      } else if (i === 1) { // Button 2 -> Generate Content Prompt
                           let icon = '‚ú®';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptGenerateContentEl, 'Generate Content Prompt'));
                           btn.title = `Send with Generate Content Prompt`;
                      } else if (i === 2) { // Button 3 -> Fact Check Prompt
                           let icon = '‚ùì';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptFactCheckEl, 'Fact Check Prompt'));
                           btn.title = `Send with Fact Check Prompt`;
                      } else if (i === 3) { // Button 4 -> Custom 1 Prompt
                           let icon = '‚ñ∂Ô∏è';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptCustom1El, 'Custom 1 Prompt'));
                           btn.title = `Send with Custom 1 Prompt`;
                      } else if (i === 4) { // Button 5 -> Custom 2 Prompt
                           let icon = '‚ñ∂Ô∏è';
                           btn.textContent = `${icon}`; // Placeholder label
                           btn.title = `Action ${icon}`; // Default tooltip
                           btn.addEventListener('click', (event) => handleMainViewPrompt(event, textareaElem, promptCustom2El, 'Custom 2 Prompt'));
                           btn.title = `Send with Custom 2 Prompt`;
                      }

                      buttonColumn.appendChild(btn); // Add button to the column
                  }

                  textActionContainer.appendChild(buttonColumn); // Add button column to the container
                  wrapperDiv.appendChild(textActionContainer); // Add the container to the main wrapper
              }

              // Append the completed subsection wrapper to the main output area
              outputDiv.appendChild(wrapperDiv);

              // Apply fade-in animation with a delay
              setTimeout(() => {
                  wrapperDiv.classList.add("fade-in");
              }, currentAnimationDelay);
              currentAnimationDelay += animationDelayIncrement; // Increment delay for the next section
          }
          // --- END finalizeSubsection ---

          // Process lines to split by headers (H1-H6)
          let firstBlockContent = []; // Content before the first header
          let firstHeaderFound = false; // Flag for initial content block
          lines.forEach((line) => {
              const trimmedLine = line.trim();
              let headerLevel = 0;
              let headerPrefix = "";

              // Detect header level (H1-H6)
              if (trimmedLine.startsWith("# ")) { headerLevel = 1; headerPrefix = "# "; }
              else if (trimmedLine.startsWith("## ")) { headerLevel = 2; headerPrefix = "## "; }
              else if (trimmedLine.startsWith("### ")) { headerLevel = 3; headerPrefix = "### "; }
              else if (trimmedLine.startsWith("#### ")) { headerLevel = 4; headerPrefix = "#### "; }
              else if (trimmedLine.startsWith("##### ")) { headerLevel = 5; headerPrefix = "##### "; }
              else if (trimmedLine.startsWith("###### ")) { headerLevel = 6; headerPrefix = "###### "; }


              if (headerLevel > 0) { // If it's a header line
                  if (!firstHeaderFound) {
                      // Finalize content before the first header
                      finalizeSubsection(null, firstBlockContent.join("\n"));
                      firstHeaderFound = true;
                  } else if (currentHeaderElement) {
                      // Finalize the previous section (header + content)
                      finalizeSubsection(currentHeaderElement, contentBlock.join("\n"));
                  }
                  foundHeaders = true;
                  contentBlock = []; // Reset content block for the new header
                  const headerText = trimmedLine.substring(headerPrefix.length);
                  currentHeaderElement = createHeaderElement(`h${headerLevel}`, headerText, headerPrefix); // Create the new header element (H1-H6)
              } else if (!firstHeaderFound) {
                  // Collect content before the first header
                  firstBlockContent.push(line);
              } else if (currentHeaderElement !== null) {
                  // Collect content under the current header
                  contentBlock.push(line);
              }
          });

          // Finalize the last section after the loop
          if (!firstHeaderFound) {
              // If no headers were found at all, finalize the initial block
              finalizeSubsection(null, firstBlockContent.join("\n"));
          } else if (currentHeaderElement) {
              // Finalize the last header and its content
              finalizeSubsection(currentHeaderElement, contentBlock.join("\n"));
          }

          // Enable action buttons if content was rendered
          if (markdownText.trim()) {
              enableActionButtons();
          } else {
              disableActionButtonsButKeepNewEnabled();
          }
          // Trigger MathJax typesetting for the main output area
          if (window.MathJax && window.MathJax.typesetPromise) {
            console.log("Typesetting main output area..."); // Optional log
            MathJax.typesetPromise([outputDiv])
              .catch(err => console.error('MathJax typesetting error in renderParsedContent:', err));
          }
      }

      // --- Mind Map Drawing State (moved outside renderMindMap) ---
      let mindMapRoot = null;
      let mindMapLayout = null;
      let mindMapTransform = null;
      let mindMapCanvas = null;
      let mindMapCtx = null;
      let mindMapZoom = null;

      /**
       * Renders Markdown content as an interactive D3.js mind map on an HTML canvas.
       * Parses headers (#, ##, etc.) into a hierarchical structure.
       * @param {string} markdownText - The raw Markdown text (expected to use headers for structure).
       */
      function renderMindMap(markdownText) {
          console.log("renderMindMap started.");
          if (!outputDiv) { console.error("Output div not found!"); return; }
          outputDiv.innerHTML = ""; // Clear previous output

          // Handle empty input
          if (!markdownText || !markdownText.trim()) {
            
              console.warn("Mind map text empty.");
              outputDiv.innerHTML = `<p class="text-gray-500 dark:text-gray-400">Mind map file is empty.</p>`;
              disableActionButtonsButKeepNewEnabled();
              return;
          }

          // Update title
          if (outputTitle) outputTitle.textContent = currentFilename || "Mind Map";
          if (outputTitle) outputTitle.title = currentFilename || "Mind Map";

          // remove existing canvas
          if (mindMapCanvas) {
            // Remove D3 zoom behavior from the canvas
            d3.select(mindMapCanvas).on(".zoom", null);
            
            // Clear the canvas and set minimal dimensions
            mindMapCtx.clearRect(0, 0, mindMapCanvas.width, mindMapCanvas.height);
            mindMapCanvas.width = 0;
            mindMapCanvas.height = 0;

            // This helps garbage collection
            mindMapCtx = null;
            
            // Remove from DOM
            if (mindMapCanvas.parentNode) {
              mindMapCanvas.parentNode.removeChild(mindMapCanvas);
            }
            
            // Also set the canvas reference to null after removal
            mindMapCanvas = null;
            
            // Reset the zoom object so it will be recreated
            mindMapZoom = null;
          }
          
          // Create canvas element
          mindMapCanvas = document.createElement("canvas");
          mindMapCanvas.id = "mindMapCanvas";
          outputDiv.style.height = "60vh"; // Set container height for canvas

          // Use requestAnimationFrame to ensure container dimensions are available
          requestAnimationFrame(() => {
              const containerWidth = outputDiv.clientWidth;
              const canvasHeight = outputDiv.clientHeight; // Use container height
              console.log(`Canvas dimensions: ${containerWidth}x${canvasHeight}`);

              if (!containerWidth || !canvasHeight) {
                  console.error("Canvas container has zero dimensions.");
                  outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error: Cannot determine rendering area size.</p>`;
                  disableActionButtonsButKeepNewEnabled();
                  return;
              }

              // Set canvas dimensions and append
              mindMapCanvas.width = containerWidth;
              mindMapCanvas.height = canvasHeight;
              outputDiv.appendChild(mindMapCanvas);
              mindMapCtx = mindMapCanvas.getContext("2d");
              if (!mindMapCtx) {
                  console.error("Could not get 2D context");
                  outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error: Cannot initialize canvas drawing.</p>`;
                  disableActionButtonsButKeepNewEnabled();
                  return;
              }

              // Parse Markdown into hierarchy data for D3
              let hierarchyData;
              try {
                  hierarchyData = parseMarkdownToHierarchy(markdownText);
                  if (!hierarchyData) throw new Error("Parsing returned null");
              } catch (error) {
                  console.error("Error parsing hierarchy:", error);
                  outputDiv.innerHTML = `<p class="text-red-500 dark:text-red-400">Error parsing mind map structure.</p>`;
                  disableActionButtonsButKeepNewEnabled();
                  return;
              }

              // Create D3 hierarchy and tree layout
              mindMapRoot = d3.hierarchy(hierarchyData);
              const nodeWidth = 120;
              const nodeHeight = 40;
              const nodeVMargin = 30;
              const nodeHMargin = 50;
              mindMapLayout = d3.tree().nodeSize([nodeHeight + nodeVMargin, nodeWidth + nodeHMargin]);

              // Set initial position
              const initialX = 50;
              const initialY = mindMapCanvas.height / 2;
              mindMapRoot.x0 = initialY;
              mindMapRoot.y0 = initialX;

              // Calculate tree layout positions
              mindMapLayout(mindMapRoot);

              // Reset transform or use previous if available and reasonable
              mindMapTransform = d3.zoomIdentity.translate(initialX, initialY);

              // Setup D3 zoom behavior (only if not already set up)
              if (!mindMapZoom) {
                  mindMapZoom = d3.zoom()
                      .scaleExtent([0.1, 3])
                      .on("zoom", (event) => {
                          mindMapTransform = event.transform;
                          redrawMindMap(); // Use the redraw function
                      });

                  d3.select(mindMapCanvas)
                      .call(mindMapZoom)
                      .on("dblclick.zoom", null);
              }

              // Apply initial transform
              d3.select(mindMapCanvas).call(mindMapZoom.transform, mindMapTransform);

              redrawMindMap(); // Initial draw using the redraw function
              window.redrawMindMap = redrawMindMap; // Make redraw function globally accessible

              console.log("renderMindMap finished successfully.");
              enableActionButtons(); // Enable actions now that rendering is done
          });
      }

      /** Redraws the mind map based on current state (root, layout, transform, theme) */
      function redrawMindMap() {
          if (!mindMapCtx || !mindMapRoot || !mindMapTransform) {
              console.warn("Cannot redraw mind map: context, root, or transform missing.");
              return;
          }

          const isDarkMode = htmlElement.classList.contains('dark');
          const nodeColors = isDarkMode ? nodeColorsDark : nodeColorsLight;
          const linkColor = isDarkMode ? linkColorDark : linkColorLight;
          const nodeTextColor = isDarkMode ? nodeTextColorDark : nodeTextColorLight; // Use dark text in dark mode for contrast

          const nodeWidth = 120;
          const nodeHMargin = 50;
          const borderRadius = 15;
          const maxTextWidth = nodeWidth - 16;
          const textBgPadding = 4;

          try {
              mindMapCtx.save();
              mindMapCtx.clearRect(0, 0, mindMapCanvas.width, mindMapCanvas.height);
              mindMapCtx.translate(mindMapTransform.x, mindMapTransform.y);
              mindMapCtx.scale(mindMapTransform.k, mindMapTransform.k);

              // Draw Links
              mindMapCtx.strokeStyle = linkColor;
              mindMapCtx.lineWidth = 1.5 / mindMapTransform.k;
              mindMapCtx.beginPath();
              mindMapRoot.links().forEach((link) => {
                  mindMapCtx.moveTo(link.source.y + nodeWidth / 2, link.source.x);
                  mindMapCtx.bezierCurveTo(
                      link.source.y + nodeWidth / 2 + nodeHMargin / 2, link.source.x,
                      link.target.y - nodeWidth / 2 - nodeHMargin / 2, link.target.x,
                      link.target.y - nodeWidth / 2, link.target.x
                  );
              });
              mindMapCtx.stroke();

              // Draw Nodes
              mindMapRoot.descendants().forEach((node) => {
                  const fontSize = 10 / mindMapTransform.k;
                  mindMapCtx.font = `bold ${fontSize}px sans-serif`;
                  mindMapCtx.textAlign = "center";
                  mindMapCtx.textBaseline = "middle";

                  let nodeName = node.data.name || "";
                  let textMetrics = mindMapCtx.measureText(nodeName);
                  const maxTextWidthScaled = maxTextWidth / mindMapTransform.k;
                  while (textMetrics.width > maxTextWidthScaled && nodeName.length > 1) {
                      nodeName = nodeName.slice(0, -2) + "‚Ä¶";
                      textMetrics = mindMapCtx.measureText(nodeName);
                  }

                  const textWidth = textMetrics.width;
                  const textHeight = fontSize;
                  const padding = textBgPadding / mindMapTransform.k;
                  const rectWidth = textWidth + padding * 2;
                  const rectHeight = textHeight + padding * 2;
                  const rectX = node.y - rectWidth / 2;
                  const rectY = node.x - rectHeight / 2;

                  const colorIndex = Math.min(node.depth, nodeColors.length - 1);
                  mindMapCtx.fillStyle = nodeColors[colorIndex];

                  mindMapCtx.beginPath();
                  if (typeof mindMapCtx.roundRect === "function") {
                      mindMapCtx.roundRect(rectX, rectY, rectWidth, rectHeight, borderRadius / mindMapTransform.k);
                      mindMapCtx.fill();
                  } else {
                      mindMapCtx.fillRect(rectX, rectY, rectWidth, rectHeight);
                      if (!window.hasWarnedRoundRect) {
                          console.warn("ctx.roundRect not supported, using fillRect fallback.");
                          window.hasWarnedRoundRect = true;
                      }
                  }

                  mindMapCtx.fillStyle = nodeTextColor; // Use theme-appropriate text color
                  mindMapCtx.fillText(nodeName, node.y, node.x);
              });

              mindMapCtx.restore();
          } catch (drawError) {
              console.error("Error during canvas redraw:", drawError);
          }
      }


      /**
       * Parses Markdown text (using headers) into a hierarchical object suitable for D3.
       * @param {string} markdownText - The raw Markdown text.
       * @returns {object | null} The root node of the hierarchy or null on error.
       */
      function parseMarkdownToHierarchy(markdownText) {
          console.log("Parsing Markdown to Hierarchy...");
          const lines = markdownText.split("\n");
          const root = { name: "Mind Map", children: [], level: 0 }; // Default root
          const stack = [root]; // Stack to keep track of parent nodes

          lines.forEach((line) => {
              const trimmedLine = line.trim();
              if (!trimmedLine) return; // Skip empty lines

              let level = 0;
              let name = "";

              // Check if the line starts with '#' headers
              if (trimmedLine.startsWith("#")) {
                  while (level < trimmedLine.length && trimmedLine[level] === "#") {
                      level++;
                  }
                  name = trimmedLine.substring(level).trim();
                  if (!name) return; // Skip if header is empty after '#'
              } else {
                  // Ignore lines that don't start with headers for hierarchy structure
                  return;
              }

              const newNode = { name: name, children: [], level: level };

              // Find the correct parent in the stack based on level
              while (stack.length > 1 && stack[stack.length - 1].level >= level) {
                  stack.pop();
              }

              // Add the new node to the children of the current parent
              if (stack.length > 0) {
                  stack[stack.length - 1].children.push(newNode);
              } else {
                  // Should not happen with a root node, but handle defensively
                  console.warn("Could not find suitable parent in stack for:", trimmedLine, "Attaching to root.");
                  root.children.push(newNode);
              }
              stack.push(newNode); // Push the new node onto the stack as a potential parent
          });

          console.log("Finished parsing hierarchy.");

          // If the root only has one child, and that child has children, promote the child to be the root
          // This often happens if the MD starts with a single H1
          if (root.children.length === 1 && root.children[0].children.length > 0) {
              console.log("Promoting single root child.");
              return root.children[0];
          }

          // If no headers were found, create a single node with the first non-empty line as name
          if (root.children.length === 0 && !markdownText.trim().startsWith("#")) {
              console.log("No headers found, creating single node.");
              const firstLine = lines.find((l) => l.trim()) || "Mind Map"; // Find first non-empty line
              return { name: firstLine, children: [] };
          }

          // If root has children, use filename or a default name
          if (root.children.length > 0) {
             root.name = currentFilename || "Mind Map Root";
          } else if (root.children.length === 0 && stack.length <= 1) {
             // If truly empty after parsing (only root on stack)
             root.name = "Mind Map";
          }

          return root;
      }
      /** Shows the confirmation modal for starting a new document. */
      function showConfirmDeleteModal(docId) { 
        if (confirmDeleteModal && confirmDeleteButton) { // Check elements exist
          // Store the docId on the confirm button itself
          confirmDeleteButton.dataset.docId = docId;
          confirmDeleteModal.classList.remove("hidden"); // Show the modal
          console.log(`Showing delete confirmation for doc ID: ${docId}`);
        } else {
          console.error("Delete confirmation modal or button not found.");
        }
      }
      /** Hides the confirmation modal for starting a new document. */
      function hideConfirmDeleteModal() { confirmDeleteModal.classList.add("hidden"); }
      function executeDeleteDocument(docIdToDelete) {
        if (typeof docIdToDelete !== 'number' || isNaN(docIdToDelete)) {
            console.error("Invalid docId passed to executeDeleteDocument:", docIdToDelete);
            alert("Could not delete document: Invalid ID.");
            return;
        }
        console.log(`Executing delete for doc ID: ${docIdToDelete}`);
        // Call the actual DB delete function with the ID
        deleteDocumentFromDB(docIdToDelete)
          .then(success => {
              if (success) {
                  console.log(`Deletion initiated successfully for doc ID ${docIdToDelete}.`);
                  // List will be refreshed by deleteDocumentFromDB on transaction complete
              } else {
                  console.log(`Deletion cancelled by user for doc ID ${docIdToDelete}.`);
              }
          })
          .catch(err => {
              console.error(`Failed to execute delete for document ${docIdToDelete}:`, err);
              alert(`Failed to delete document: ${err}`);
          }); 
      }

      /** Shows the confirmation modal for starting a new document. */
      function showConfirmNewModal() { confirmNewModal.classList.remove("hidden"); }
      /** Hides the confirmation modal for starting a new document. */
      function hideConfirmNewModal() { confirmNewModal.classList.add("hidden"); }

      /** Clears the current content and state to start a new document. Opens the raw editor. */
      function executeNewDocument() {
          console.log("Starting new document...");
          rawFileContent = ""; // Clear content
          fileInput.value = null; // Clear file input
          currentFilename = null; // Clear filename
          currentDocId = null; // Reset ID when creating new document
          renderParsedContent(rawFileContent); // Render the empty state
          hideConfirmNewModal(); // Hide confirmation
          // Ensure other modals are hidden
          hideRenderedHtmlModal();
          hideJupyterJsonModal();
          hideJupyterHelpModal();
          hideGeminiPanel();
          showRawMdModal(); // Open the raw editor for the new document
          console.log("New document created and editor opened.");
      }

      /** Shows the modal for editing the raw Markdown content. */
      function showRawMdModal() {
          if (rawFileContent !== null) { // Only show if content is loaded/initialized
              rawMdEditorTextarea.value = rawFileContent; // Load content into textarea
              rawMdModal.classList.remove("hidden"); // Make modal visible
              rawMdEditorTextarea.focus(); // Focus the textarea
          } else {
              console.warn("Cannot open raw editor: No file content loaded.");
          }
      }
      /** Hides the modal for editing the raw Markdown content. */
      function hideRawMdModal() { rawMdModal.classList.add("hidden"); }

      /** Saves changes from the raw Markdown editor and re-renders the main view. */
      function saveRawMdChanges() {
          rawFileContent = rawMdEditorTextarea.value; // Update state with edited content
          // Re-render based on file type (mind map or standard)
          if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              renderMindMap(rawFileContent);
          } else {
              renderParsedContent(rawFileContent);
          }
          hideRawMdModal(); // Close the editor modal
      }

      /** Shows the modal displaying the rendered HTML view of the Markdown content. */
      function showRenderedHtmlModal() {
          if (rawFileContent !== null) { // Only show if content exists
              try {
                  // Clean content (remove potential quotes) and parse using Marked.js
                  const cleanedContent = rawFileContent.split('\n').map(line => line.trim().replace(/^\"|\"$/g, '')).join('\n');
                  const renderedHtml = marked.parse(cleanedContent);
                  renderedContentDisplay.innerHTML = renderedHtml; // Display rendered HTML
                  // Trigger MathJax typesetting for the rendered HTML modal
                  if (window.MathJax && window.MathJax.typesetPromise) {
                    console.log("Typesetting rendered HTML modal..."); // Optional log
                    MathJax.typesetPromise([renderedContentDisplay])
                      .catch(err => console.error('MathJax typesetting error in rendered modal:', err));
                  }
                  renderedHtmlModal.classList.remove("hidden"); // Show modal
              } catch (error) {
                  // Handle Markdown parsing errors
                  console.error("Error rendering Markdown:", error);
                  renderedContentDisplay.innerHTML = '<p class="text-red-500 dark:text-red-400">Error rendering Markdown.</p>';
                  renderedHtmlModal.classList.remove("hidden"); // Still show modal with error
              }
          } else {
              console.warn("No file content loaded.");
          }
      }
      /** Hides the modal displaying the rendered HTML view. */
      function hideRenderedHtmlModal() {
          renderedHtmlModal.classList.add("hidden");
          renderedContentDisplay.innerHTML = ""; // Clear content when hiding
      }

      /** Handles the export to Jupyter action. Generates and displays JSON. */
      function handleExportJupyter() {
          console.log("Export to Jupyter requested.");
          if (!rawFileContent || !rawFileContent.trim()) {
              console.warn("No content to export.");
              return;
          }
          // If currently in standard parsed view, reconstruct raw content from textareas first
          if (!document.getElementById('mindMapCanvas')) {
             reconstructRawContent();
          }
          try {
              // Generate the notebook JSON string
              const notebookJsonString = generateJupyterNotebookJSON(rawFileContent);
              jupyterJsonDisplay.textContent = notebookJsonString; // Display in modal
              showJupyterJsonModal(); // Show the modal
          } catch (error) {
              console.error("Error generating Jupyter Notebook JSON:", error);
              // Optionally show an error message to the user
          }
      }

      /**
       * Generates a JSON string representing a Jupyter Notebook (.ipynb) from Markdown text.
       * Splits the Markdown into cells based on H1 headers.
       * @param {string} markdownText - The raw Markdown text.
       * @returns {string} A JSON string representing the Jupyter Notebook.
       */
      function generateJupyterNotebookJSON(markdownText) {
          const cells = []; // Array to hold notebook cells
          const lines = markdownText.split("\n");
          let currentCellLines = []; // Lines for the current Markdown cell

          // Helper to create a Markdown cell object
          function createMarkdownCell(sourceLines) {
              // Trim trailing empty lines from the cell source
              while (sourceLines.length > 0 && sourceLines[sourceLines.length - 1].trim() === "") {
                  sourceLines.pop();
              }
              // Add newline characters back, except for the last line
              const sourceWithNewlines = sourceLines.map((line, index) =>
                  index === sourceLines.length - 1 ? line : line + "\n"
              );
              return {
                  cell_type: "markdown",
                  metadata: {}, // Standard empty metadata
                  source: sourceWithNewlines,
              };
          }

          // Iterate through lines, splitting into cells at H1 headers
          lines.forEach((line) => {
              // Use H1 (# ) as cell separator
              if (line.trim().startsWith("# ")) { // Check for H1 header
                  if (currentCellLines.length > 0) {
                      // Finalize the previous cell if it has content
                      cells.push(createMarkdownCell(currentCellLines));
                  }
                  // Start a new cell with the H1 header line
                  currentCellLines = [line];
              } else {
                  // Add line to the current cell
                  currentCellLines.push(line);
              }
          });

          // Add the last cell after the loop finishes
          if (currentCellLines.length > 0) {
              cells.push(createMarkdownCell(currentCellLines));
          }

          // Construct the full notebook object structure
          const notebook = {
              cells: cells,
              metadata: { // Standard Jupyter metadata
                  kernelspec: {
                      display_name: "Python 3 (ipykernel)",
                      language: "python",
                      name: "python3",
                  },
                  language_info: {
                      codemirror_mode: { name: "ipython", version: 3 },
                      file_extension: ".py",
                      mimetype: "text/x-python",
                      name: "python",
                      nbconvert_exporter: "python",
                      pygments_lexer: "ipython3",
                      version: "3.10.0", // Example version, adjust if needed
                  },
              },
              nbformat: 4, // Standard notebook format version
              nbformat_minor: 5, // Standard minor version
          };

          // Return the notebook object as a formatted JSON string
          return JSON.stringify(notebook, null, 2); // Pretty print with 2 spaces
      }

      /** Shows the modal displaying the generated Jupyter JSON. */
      function showJupyterJsonModal() { jupyterJsonModal.classList.remove("hidden"); }
      /** Hides the modal displaying the generated Jupyter JSON. */
      function hideJupyterJsonModal() {
          jupyterJsonModal.classList.add("hidden");
          jupyterJsonDisplay.textContent = ""; // Clear JSON when hiding
      }

      /** Copies the content of the Jupyter JSON display area to the clipboard. */
      async function copyJupyterJsonToClipboard() {
          const jsonText = jupyterJsonDisplay.textContent;
          if (!jsonText) return; // Do nothing if empty

          try {
              await navigator.clipboard.writeText(jsonText); // Use Clipboard API
              console.log("Jupyter JSON copied to clipboard!");

              // Provide visual feedback on the button
              const originalText = copyJupyterJsonButton.textContent;
              copyJupyterJsonButton.textContent = "Copied!";
              copyJupyterJsonButton.disabled = true;
              setTimeout(() => { // Reset button after a delay
                  copyJupyterJsonButton.textContent = originalText;
                  copyJupyterJsonButton.disabled = false;
              }, 1500);
          } catch (err) {
              console.error("Failed to copy Jupyter JSON: ", err);
              // Provide error feedback on the button
              copyJupyterJsonButton.textContent = "Copy Failed";
              setTimeout(() => { // Reset button after a delay
                  copyJupyterJsonButton.textContent = "Copy JSON";
              }, 2000);
          }
      }

      /** Shows the help modal explaining how to use the Jupyter JSON. */
      function showJupyterHelpModal() { jupyterHelpModal.classList.remove("hidden"); }
      /** Hides the Jupyter help modal. */
      function hideJupyterHelpModal() { jupyterHelpModal.classList.add("hidden"); }

      /** Triggered when a textarea in the main parsed view loses focus. Reconstructs raw content. */
      function handleMainTextareaEdit() {
          reconstructRawContent(); // Update the rawFileContent state
      }

      /**
       * Reconstructs the raw Markdown content from the headers and textareas in the main output view.
       * Updates the `rawFileContent` state variable.
       * Skips reconstruction if currently in mind map view.
       */
      function reconstructRawContent() {
          // Do not reconstruct if the mind map canvas is present (we rely on rawMdEditorTextarea for mind maps)
          if (document.getElementById('mindMapCanvas')) {
              console.log("In mind map view, skipping raw content reconstruction.");
              return;
          }

          let newRawContent = "";
          // Select headers H1 through H6
          const wrappers = outputDiv.querySelectorAll(".subsection-wrapper");

          wrappers.forEach((wrapper, index) => {
              const header = wrapper.querySelector("h1, h2, h3, h4, h5, h6"); // Include H5, H6
              const textarea = wrapper.querySelector(".content-textarea");

              if (header) {
                  newRawContent += (header.dataset.markdownPrefix || "") + header.textContent + "\n";
              }
              if (textarea) {
                  newRawContent += textarea.value;
                  if (index < wrappers.length - 1 || header) {
                     newRawContent += "\n";
                  }
              } else if (header && index < wrappers.length - 1) {
                  newRawContent += "\n";
              }
          });


          rawFileContent = newRawContent.trimEnd(); // Update global state, remove trailing whitespace
          console.log("Raw content reconstructed. Length:", rawFileContent.length);

          // Re-evaluate button states based on reconstructed content
          if (rawFileContent.trim()) {
              enableActionButtons();
          } else {
              disableActionButtonsButKeepNewEnabled();
          }
      }

      /**
       * Creates an HTML header element (H1-H6).
       * @param {string} tag - The header tag name (e.g., "h1").
       * @param {string} text - The text content of the header.
       * @param {string} prefix - The original Markdown prefix (e.g., "## ").
       * @returns {HTMLElement} The created header element.
       */
      function createHeaderElement(tag, text, prefix) {
          const element = document.createElement(tag);
          element.textContent = text.trim(); // Set text content
          element.dataset.markdownPrefix = prefix; // Store original prefix for reconstruction
          return element;
      }

      /**
       * Creates an editable textarea element for a content block.
       * @param {string} contentText - The text content for the textarea.
       * @returns {HTMLTextAreaElement | null} The created textarea element or null if content is empty.
       */
      function createContentTextarea(contentText) {
          if (!contentText || !contentText.trim()) {
              return null; // Don't create textarea for empty content
          }
          const textarea = document.createElement("textarea");
          textarea.value = contentText; // Set initial value
          textarea.classList.add("content-textarea"); // Apply styling
          textarea.addEventListener("blur", handleMainTextareaEdit); // Add listener to update raw content on edit

          // Adjust initial height based on content lines (within limits)
          const lines = contentText.split("\n").length;
          textarea.rows = Math.min(Math.max(5, lines + 1), 25); // Min 5, max 25 rows

          return textarea;
      }

      /** Enables the main action buttons (Edit Raw, View Rendered, Export, Refresh). */
      function enableActionButtons() {
          viewRawMdButton.disabled = false;
          viewRenderedButton.disabled = false;
          exportJupyterButton.disabled = false;
          saveDocButton.disabled = false; // Enable refresh button
          refreshPreviewButton.disabled = false; // Enable refresh button
          newButton.disabled = false; // Ensure New is also enabled
          console.log("Action buttons enabled.");
      }

      /** Disables the main action buttons, but keeps the 'New' button enabled. */
      function disableActionButtonsButKeepNewEnabled() {
          viewRawMdButton.disabled = true;
          viewRenderedButton.disabled = true;
          exportJupyterButton.disabled = true;
          saveDocButton.disabled = true; // Enable refresh button
          refreshPreviewButton.disabled = true; // Disable refresh button
          newButton.disabled = false; // Keep 'New' enabled
          console.log("Action buttons (except New) disabled.");
      }

      /** Handles the click event for the Refresh Preview button. */
      function handleRefreshPreview() {
          console.log("Refresh Preview requested.");
          if (rawFileContent === null) {
              console.warn("Cannot refresh: No content loaded.");
              return;
          }
          // Re-render based on the current content type
          if (currentFilename && currentFilename.toLowerCase().includes(".mindmap.")) {
              console.log("Refreshing mind map view...");
              viewMode = "mindmap";
              renderMindMap(rawFileContent);
          } else {
              console.log("Refreshing standard markdown view...");
              viewMode = "editor";
              renderParsedContent(rawFileContent);
          }
          console.log("Preview refreshed.");
      }

      function toggleViewMode() {
          console.log("Switching view mode...");
          if (rawFileContent === null) {
              console.warn("Cannot switch view: No content loaded.");
              return;
          }
          // Re-render based on the current content type
          if (viewMode == "editor") {
              console.log("Refreshing mind map view...");
              viewMode = "mindmap";
              renderMindMap(rawFileContent);
          } else {
              console.log("Refreshing standard markdown view...");
              viewMode = "editor";
              renderParsedContent(rawFileContent);
          }

      }

      // --- Gemini Panel Functions ---

      /** Toggles the visibility of the Gemini options panel (slides in/out). */
      function toggleGeminiPanel() {
        geminiOptionsPanel.classList.toggle("visible");
      }

      /** Hides the Gemini options panel. */
      function hideGeminiPanel() {
        geminiOptionsPanel.classList.remove("visible");
      }

      /** Resets the displayed token counts in the Gemini panel to 0. */
      function resetTokenCountDisplay() {
          if (promptTokenCountEl) promptTokenCountEl.textContent = '0';
          if (completionTokenCountEl) completionTokenCountEl.textContent = '0';
          if (totalTokenCountEl) totalTokenCountEl.textContent = '0';
      }

      /** Resets the cumulative token count variables and their display. */
      function resetCumulativeCounts() {
          cumulativeInTokens = 0;
          cumulativeOutTokens = 0;
          cumulativeTotalTokens = 0;
          resetTokenCountDisplay(); // Also reset the display elements
          console.log("Cumulative token counts reset.");
      }


      /** Updates the text indicator showing the currently selected Gemini model. */
      function updateActiveModelIndicator() {
          // If indicator element doesn't exist or select is disabled, clear text and exit
          if (!activeModelIndicator || geminiModelSelect.disabled) {
              if(activeModelIndicator) activeModelIndicator.textContent = ''; // Clear if disabled
              return;
          }
          // Get the selected option element
          const selectedOption = geminiModelSelect.options[geminiModelSelect.selectedIndex];
          // Update indicator text based on selection
          if (selectedOption && selectedOption.value) {
              activeModelIndicator.textContent = `Active Model: ${selectedOption.text}`;
          } else {
              activeModelIndicator.textContent = 'Active Model: None Selected';
          }
      }


      /**
       * Handles changes to the API key input field.
       * Saves the key, validates it by fetching models, and updates the UI.
       */
      function handleApiKeyChange() {
          const apiKey = geminiApiKeyInput.value.trim();
          localStorage.setItem('geminiApiKey', apiKey); // Save key to localStorage
          console.log('Gemini API Key saved.');
          geminiApiError.textContent = ''; // Clear previous errors
          geminiResponseTextarea.value = ''; // Clear previous test response
          resetCumulativeCounts(); // Reset token counts when key changes

          if (apiKey) {
              // If key is entered, enable model select and fetch models
              geminiModelSelect.disabled = false;
              fetchAndPopulateModels(apiKey);
          } else {
              // If key is cleared, disable model select and reset UI
              geminiModelSelect.disabled = true;
              clearModelOptions();
              geminiModelSelect.value = ""; // Ensure no value is selected
              updateActiveModelIndicator(); // Clear active model indicator
              const defaultOption = geminiModelSelect.querySelector('option[value=""]');
              if (defaultOption) {
                  defaultOption.textContent = "-- Enter API Key --"; // Reset placeholder text
              }
          }
      }

      /** Clears all model options from the select dropdown, except the default placeholder. */
      function clearModelOptions() {
          // Remove options starting from the second one (index 1)
          while (geminiModelSelect.options.length > 1) {
              geminiModelSelect.remove(1);
          }
      }

      /**
       * Fetches the list of available Gemini models from the API using the provided key
       * and populates the model selection dropdown.
       * @param {string} apiKey - The user's Gemini API key.
       */
      async function fetchAndPopulateModels(apiKey) {
          console.log("Fetching Gemini models...");
          const modelsUrl = `${GEMINI_API_BASE_URL}/models?key=${apiKey}`;
          const defaultOption = geminiModelSelect.querySelector('option[value=""]');

          // Update UI to loading state
          if (defaultOption) defaultOption.textContent = "-- Loading Models... --";
          clearModelOptions(); // Clear existing models first
          updateActiveModelIndicator(); // Clear active model text
          resetTokenCountDisplay(); // Reset token display

          try {
              const response = await fetch(modelsUrl); // Make API call
              if (!response.ok) {
                  // Handle HTTP errors (e.g., 400 Bad Request for invalid key)
                  let errorMsg = `Error fetching models (HTTP ${response.status})`;
                  try {
                      // Try to parse error details from the response body
                      const errorData = await response.json();
                      if (errorData.error && errorData.error.message) {
                          errorMsg = `API Error: ${errorData.error.message}`;
                      }
                  } catch (parseError) {
                      console.warn("Could not parse error response body.");
                  }
                   throw new Error(errorMsg); // Throw error to be caught below
              }
              const data = await response.json(); // Parse successful response

              // Check if the API returned any models
              if (!data.models || data.models.length === 0) {
                   console.warn("API returned successfully but with no models listed.");
                   if (defaultOption) defaultOption.textContent = "-- No models found --";
                   geminiApiError.textContent = "No models found for this API key.";
                   updateActiveModelIndicator();
                   return; // Exit if no models
              }

              // Populate the dropdown with supported models
              data.models.forEach(model => {
                  // Check if the model supports the 'generateContent' method needed by this app
                  const supportsGenerateContent = model.supportedGenerationMethods?.includes('generateContent');
                  if (supportsGenerateContent) {
                      const option = document.createElement('option');
                      option.value = model.name; // Full model name (e.g., "models/gemini-1.5-pro-latest")
                      // Use display name if available, otherwise extract name from the full path
                      option.textContent = model.displayName || model.name.split('/').pop();
                      geminiModelSelect.appendChild(option);
                  } else {
                      console.log(`Skipping model ${model.name} as it does not support 'generateContent'`);
                  }
              });

               // Update placeholder text after loading
               if (defaultOption) defaultOption.textContent = "-- Select a Model --";
               geminiApiError.textContent = ''; // Clear error message on success

              // Try to restore previously selected model from localStorage
              const savedModel = localStorage.getItem('selectedGeminiModel');
              if (savedModel && geminiModelSelect.querySelector(`option[value="${savedModel}"]`)) {
                   geminiModelSelect.value = savedModel; // Select the saved model
                   console.log("Restored previously selected model:", savedModel);
              } else {
                   geminiModelSelect.value = ""; // Default to placeholder if saved model not found
              }
              updateActiveModelIndicator(); // Update the active model display


          } catch (error) {
              // Handle errors during fetch or processing
              console.error("Failed to fetch or populate models:", error);
              geminiApiError.textContent = error.message || "Failed to fetch models. Check key or console.";
              geminiModelSelect.disabled = true; // Disable select on error
              clearModelOptions(); // Clear any partially loaded options
              if (defaultOption) defaultOption.textContent = "-- Error Loading --"; // Update placeholder
              updateActiveModelIndicator(); // Clear active model text
          }
      }

      /**
       * Handles the click event for the "Send 'hello world'" test prompt button.
       * Sends a simple, predefined prompt to the selected Gemini model.
       * Displays the response and token usage in the panel.
       */
      async function handleSendPromptClick() {
          const apiKey = geminiApiKeyInput.value.trim();
          const selectedModel = geminiModelSelect.value;
          const originalButtonText = sendPromptButton.textContent;

          // --- Validation ---
          geminiApiError.textContent = ''; // Clear previous errors
          geminiResponseTextarea.value = ''; // Clear previous response
          // Reset only the display for this single request, not cumulative counts
          resetTokenCountDisplay();

          if (!apiKey) {
              geminiApiError.textContent = 'API Key is required.';
              return;
          }
          if (!selectedModel) {
              geminiApiError.textContent = 'Please select a model.';
              return;
          }

          // --- Prepare API Call ---
          const apiUrl = `${GEMINI_API_BASE_URL}/${selectedModel}:generateContent?key=${apiKey}`;
          // Simple request body with a system instruction and user prompt
          const requestBody = {
              "systemInstruction": { // Instruct the model on how to behave
                  "parts": [{"text": "Respond ONLY with the exact text 'hello human'."}]
              },
              "contents": [ // The actual user input/prompt
                  { "parts": [ {"text": "hello world"} ] }
              ]
          };

          // --- Loading State ---
          sendPromptButton.disabled = true;
          sendPromptButton.textContent = 'Sending...';

          const taskId = nextTaskId++; // Get unique ID
          const taskType = 'Test';
          const newTask = { id: taskId, type: taskType, status: 'Running...', message: '', timestamp: new Date(), model: selectedModel};
          activeTasks.push(newTask);
          renderTasksList(); // Update the task list display
          // Optional: Show panel if hidden - uncomment if desired
          // if (taskListPanel.classList.contains('invisible')) {
          //   taskListButton.click(); // Simulate click to toggle panel open
          // }

          // --- API Call ---
          try {
              console.log(`Sending prompt to ${selectedModel}...`);
              const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(requestBody),
              });

              const data = await response.json(); // Always try to parse JSON response

              // Handle non-OK HTTP responses (errors)
              if (!response.ok) {
                  let errorMsg = `API Error (HTTP ${response.status})`;
                   // Use parsed error message if available from the API response body
                   if (data.error && data.error.message) {
                       errorMsg = `API Error: ${data.error.message}`;
                   }
                   throw new Error(errorMsg); // Throw error to be caught
              }

              console.log("API Response:", data);

              // --- Extract Text Response ---
              let responseText = "Error: Could not extract text from response.";
              // Standard path for successful response text
              if (data.candidates && data.candidates.length > 0 &&
                  data.candidates[0].content && data.candidates[0].content.parts &&
                  data.candidates[0].content.parts.length > 0 &&
                  data.candidates[0].content.parts[0].text) {
                  responseText = data.candidates[0].content.parts[0].text;
              }
              // Handle cases where the prompt was blocked (safety settings, etc.)
              else if (data.promptFeedback && data.promptFeedback.blockReason) {
                   responseText = `Blocked: ${data.promptFeedback.blockReason}`;
                   if (data.promptFeedback.blockReasonMessage) { // Add specific message if available
                       responseText += ` - ${data.promptFeedback.blockReasonMessage}`;
                   }
              } else {
                  // Log unexpected response structure if text couldn't be found
                  console.warn("Unexpected response structure:", data);
              }
              geminiResponseTextarea.value = responseText.trim(); // Display extracted text

              // --- Update Token Counts ---
              if (data.usageMetadata) {
                  // Get token counts for this specific request
                  const currentPromptTokens = data.usageMetadata.promptTokenCount || 0;
                  const currentCompletionTokens = data.usageMetadata.candidatesTokenCount || 0; // Note: API might use different names
                  const currentTotalTokens = data.usageMetadata.totalTokenCount || 0;

                  // Add current request's tokens to the cumulative session totals
                  cumulativeInTokens += currentPromptTokens;
                  cumulativeOutTokens += currentCompletionTokens;
                  cumulativeTotalTokens += currentTotalTokens; // Or recalculate: cumulativeInTokens + cumulativeOutTokens

                  // Update the display with the *cumulative* totals
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;

                  console.log("Token Usage (Current Request):", data.usageMetadata);
                  console.log("Token Usage (Cumulative Session):", { in: cumulativeInTokens, out: cumulativeOutTokens, total: cumulativeTotalTokens });
              } else {
                  console.warn("Usage metadata not found in response.");
                  // If metadata is missing, keep displaying the existing cumulative counts
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;
              }

              // Update task status to Completed
              const completedTask = activeTasks.find(task => task.id === taskId);
              if (completedTask) {
                completedTask.status = 'Completed';
                // Provide a more informative success message if possible
                completedTask.message = `Success. Response length: ${responseText.trim().length}`;
              }
              renderTasksList(); // Update UI

          } catch (error) {
              // Handle fetch errors or errors thrown from response checking
              console.error("Failed to send prompt:", error);
              geminiApiError.textContent = error.message || "Failed to send prompt. Check console.";
              geminiResponseTextarea.value = ''; // Clear response area on error
              // Display existing cumulative counts even on error
              promptTokenCountEl.textContent = cumulativeInTokens;
              completionTokenCountEl.textContent = cumulativeOutTokens;
              totalTokenCountEl.textContent = cumulativeTotalTokens;

              // Update task status to Failed
              const failedTask = activeTasks.find(task => task.id === taskId);
              if (failedTask) {
                failedTask.status = 'Failed';
                failedTask.message = error.message || 'An unknown error occurred.';
              }
              renderTasksList(); // Update UI
          } finally {
              // --- Reset Loading State ---
              sendPromptButton.disabled = false; // Re-enable button
              sendPromptButton.textContent = originalButtonText; // Restore original text
          }
      }

      /**
       * Handles the click event for the action buttons next to main view textareas (1-5).
       * Sends the textarea content combined with a specific custom prompt (from the panel) to Gemini.
       * Replaces the textarea content with the Gemini response.
       * Updates cumulative token counts.
       * @param {Event} event - The button click event.
       * @param {HTMLTextAreaElement} textareaElement - The textarea associated with the clicked button.
       * @param {HTMLTextAreaElement} customPromptElement - The corresponding custom prompt textarea from the options panel.
       * @param {string} promptLabel - A user-friendly label for the custom prompt (used in error messages).
       * @param {number | null} taskIdToUpdate - The ID of the task to update (if part of a batch job).
       */
      async function handleMainViewPrompt(event, textareaElement, customPromptElement, promptLabel, taskIdToUpdate = null) {

          const clickedButton = event ? event.currentTarget : null; // Get button only if event exists
          let originalButtonText = null; // Initialize here
          if (clickedButton) {
            originalButtonText = clickedButton.textContent; // Store original text (e.g., "1")
          }

          // --- Get Settings and Content ---
          const apiKey = geminiApiKeyInput.value.trim();
          const selectedModel = geminiModelSelect.value;
          const customPromptText = customPromptElement.value.trim(); // Get text from the *specific* custom prompt textarea
          const textareaContent = textareaElement.value.trim(); // Get content from the main view textarea

          // --- Validation ---
          geminiApiError.textContent = ''; // Clear errors in the Gemini panel
          resetTokenCountDisplay(); // Reset display for this request (will show cumulative after)

          // Check for API key, model selection, and non-empty prompts/content
          if (!apiKey) {
              geminiApiError.textContent = 'API Key is required in options panel.';
              return; // Stop execution if invalid
          }
          if (!selectedModel) {
              geminiApiError.textContent = 'Please select a model in options panel.';
              return; // Stop execution if invalid
          }
          if (!customPromptText) {
              // Use the provided label to indicate *which* custom prompt is missing
              geminiApiError.textContent = `${promptLabel} is empty in options panel.`;
              return; // Stop execution if invalid
          }
          if (!textareaContent) {
              // Provide visual feedback if the target textarea is empty
              console.warn("Textarea is empty, nothing to send.");
              textareaElement.classList.add('border-red-500', 'ring-red-500'); // Highlight border
              setTimeout(() => { // Remove highlight after a short delay
                  textareaElement.classList.remove('border-red-500', 'ring-red-500');
              }, 1500);
              return; // Stop execution if invalid
          }

          // --- Prepare API Call ---
          // Combine the custom prompt and the textarea content
          const combinedPrompt = `${customPromptText}\n\n${textareaContent}`; // Add separation
          const apiUrl = `${GEMINI_API_BASE_URL}/${selectedModel}:generateContent?key=${apiKey}`;
          // Simple request body, sending the combined text as the prompt
          const requestBody = {
              "contents": [
                  { "parts": [ {"text": combinedPrompt} ] }
              ]
              // Note: No systemInstruction is used here by default, but could be added
          };

          // --- Loading State ---
          if (clickedButton) {
            clickedButton.disabled = true; // Disable the small action button
            clickedButton.textContent = '...'; // Indicate loading
          }

          let currentTaskId = taskIdToUpdate; // Use passed ID if available

          if (!currentTaskId) { // If called directly by user click (no ID passed)
            currentTaskId = nextTaskId++; // Generate new ID
            const taskType = promptLabel.replace(/ Prompt/, '') || 'Unknown';
            const newTask = {
              id: currentTaskId,
              type: taskType,
              status: 'Running...', // Direct clicks start as Running
              message: '',
              timestamp: new Date(),
              model: selectedModel // Use model selected when clicked
            };
            activeTasks.push(newTask);
            renderTasksList(); // Show the new 'Running' task
            // Optional: Show panel if hidden
            // if (taskListPanel.classList.contains('invisible')) { taskListButton.click(); }
          } else {
            // If called as part of batch, update the existing task status if it's 'Pending'
            const existingTask = activeTasks.find(task => task.id === currentTaskId);
            if (existingTask && existingTask.status === 'Pending') {
                existingTask.status = 'Running...';
                renderTasksList(); // Update UI to show 'Running'
            }
          }
          // If taskIdToUpdate was provided, the task already exists (as Pending or Running)
          // and we'll update it using currentTaskId within the try/catch blocks.

          // --- API Call ---
          try {
              console.log(`Sending main view prompt ('${promptLabel}') to ${selectedModel}...`);
              const response = await fetch(apiUrl, {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(requestBody),
              });

              const data = await response.json(); // Parse response JSON

              // Handle non-OK HTTP responses
              if (!response.ok) {
                  let errorMsg = `API Error (HTTP ${response.status})`;
                  if (data.error && data.error.message) { errorMsg = `API Error: ${data.error.message}`; }
                  throw new Error(errorMsg);
              }

              console.log("API Response:", data);

              // --- Extract Text Response ---
              let responseText = "Error: Could not extract text from response.";
              // Standard path for successful response
              if (data.candidates && data.candidates.length > 0 &&
                  data.candidates[0].content && data.candidates[0].content.parts &&
                  data.candidates[0].content.parts.length > 0 &&
                  data.candidates[0].content.parts[0].text) {
                  responseText = data.candidates[0].content.parts[0].text;
              }
              // Handle blocked prompts
              else if (data.promptFeedback && data.promptFeedback.blockReason) {
                   responseText = `Blocked: ${data.promptFeedback.blockReason}`;
                   if (data.promptFeedback.blockReasonMessage) { responseText += ` - ${data.promptFeedback.blockReasonMessage}`; }
              } else {
                   console.warn("Unexpected response structure:", data);
              }

              // --- Replace Textarea Content ---
              // Use requestAnimationFrame to ensure layout is stable before interacting
               requestAnimationFrame(() => {
                  // Check if element is still in the DOM
                  if (document.body.contains(textareaElement)) {
                    textareaElement.focus(); // Focus textarea
                    textareaElement.select(); // Select existing content (optional, helps replace)
                    // Try using document.execCommand first for broader compatibility
                    if (!document.execCommand('insertText', false, responseText.trim())) {
                      // Fallback for browsers where execCommand might fail or is deprecated
                      textareaElement.setRangeText(responseText.trim(), textareaElement.selectionStart, textareaElement.selectionEnd, 'select');
                      console.log("Used setRangeText fallback for inserting text.");
                    }
                    // Trigger change and input events manually for frameworks/libraries that might listen
                    textareaElement.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
                    textareaElement.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
                    // Trigger blur event manually to ensure any related logic (like saving/reconstruction) runs
                    textareaElement.dispatchEvent(new Event('blur', { bubbles: true, cancelable: true }));
                    // Manually trigger content reconstruction as blur might not be sufficient if focus doesn't change
                    reconstructRawContent();
                  } else {
                    console.warn("Textarea element no longer in DOM, skipping text update.");
                  }
               });


              // Update task status to Completed
              const completedTask = activeTasks.find(task => task.id === currentTaskId);
              if (completedTask) {
                completedTask.status = 'Completed';
                // Provide a more informative success message if possible
                completedTask.message = `Success. Response length: ${responseText.trim().length}`;
              }
              renderTasksList(); // Update UI


              // --- Update Token Counts (Cumulative) ---
              if (data.usageMetadata) {
                  const currentPromptTokens = data.usageMetadata.promptTokenCount || 0;
                  const currentCompletionTokens = data.usageMetadata.candidatesTokenCount || 0;
                  const currentTotalTokens = data.usageMetadata.totalTokenCount || 0;

                  // Add to cumulative totals
                  cumulativeInTokens += currentPromptTokens;
                  cumulativeOutTokens += currentCompletionTokens;
                  cumulativeTotalTokens += currentTotalTokens;

                  // Update display in the Gemini panel with cumulative totals
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;

                  console.log("Token Usage (Current Request):", data.usageMetadata);
                  console.log("Token Usage (Cumulative Session):", { in: cumulativeInTokens, out: cumulativeOutTokens, total: cumulativeTotalTokens });
              } else {
                  console.warn("Usage metadata not found in response.");
                  // Display existing cumulative counts if metadata is missing
                  promptTokenCountEl.textContent = cumulativeInTokens;
                  completionTokenCountEl.textContent = cumulativeOutTokens;
                  totalTokenCountEl.textContent = cumulativeTotalTokens;
              }

          } catch (error) {
              // Handle errors during fetch or processing
              console.error("Failed to send main view prompt:", error);
              // Display error in the *panel's* error area
              geminiApiError.textContent = error.message || "Failed to process request. Check console.";
              // Display existing cumulative counts even on error
              promptTokenCountEl.textContent = cumulativeInTokens;
              completionTokenCountEl.textContent = cumulativeOutTokens;
              totalTokenCountEl.textContent = cumulativeTotalTokens;

              // Update task status to Failed
              const failedTask = activeTasks.find(task => task.id === currentTaskId);
              if (failedTask) {
                failedTask.status = 'Failed';
                failedTask.message = error.message || 'An unknown error occurred.';
              }
              renderTasksList(); // Update UI
          } finally {
              // --- Reset Loading State ---
              // Check if button exists and element is still valid before resetting
              if (clickedButton && document.body.contains(clickedButton)) {
                clickedButton.disabled = false;
                // Ensure originalButtonText was declared outside the earlier 'if' block
                clickedButton.textContent = originalButtonText;
              }
          }
      }


      /** Loads saved settings (API key, custom prompts) from localStorage on page load. */
      function loadSettings() {
          // Reset cumulative counts at the start of a new session/page load
          resetCumulativeCounts();

          // Load API Key
          const savedKey = localStorage.getItem('geminiApiKey');
          if (savedKey) {
              geminiApiKeyInput.value = savedKey; // Populate input field
              console.log('Gemini API Key loaded.');
              geminiModelSelect.disabled = false; // Enable model select
              fetchAndPopulateModels(savedKey); // Fetch models using the saved key
          } else {
              // If no key saved, keep model select disabled
              geminiModelSelect.disabled = true;
              clearModelOptions();
              const defaultOption = geminiModelSelect.querySelector('option[value=""]');
               if (defaultOption) defaultOption.textContent = "-- Enter API Key --";
               updateActiveModelIndicator(); // Ensure indicator is clear
          }

          // Load Custom Prompts
          promptCreatePlanEl.value = localStorage.getItem('promptCreatePlanValue') || atob(createPlan);
          promptGenerateContentEl.value = localStorage.getItem('promptGenerateContentValue') || generateContent;
          promptFactCheckEl.value = localStorage.getItem('promptFactCheckValue') || factCheck;
          promptCustom1El.value = localStorage.getItem('promptCustom1Value') || atob(custom1);
          promptCustom2El.value = localStorage.getItem('promptCustom2Value') || atob(custom2);
          console.log('Custom prompts loaded.');

          // Load Batch Delay
          batchDelayInput.value = localStorage.getItem('batchDelayValue') || '15'; // Load saved delay or default to 15
          console.log('Batch delay loaded.');
      }

      // --- Initial Setup ---
      applyInitialTheme(); // Apply saved theme preference on load
      disableActionButtonsButKeepNewEnabled();
      loadSettings();
      loadMarkdownFromUrl();
      initDB(); // Initialize the database connection
      switchTab('file');

    </script>
  </body>
</html>