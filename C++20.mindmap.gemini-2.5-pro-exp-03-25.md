# C++ Programming Language #Main #Core #Language #Programming

An overview of the C++ programming language, covering its history, philosophy, and fundamental concepts required to become proficient.

## Introduction and Basics #Level1 #Fundamentals #Setup #History

Covers the initial setup, basic syntax, history, and foundational elements of C++.

### History and Evolution #Level2 #History #Timeline #Standards

Discusses the origins of C++, its relationship with C, and the evolution through different standard revisions (C++98, C++03, C++11, C++14, C++17, C++20, C++23).

### Setting up the Environment #Level2 #Setup #Compiler #IDE #Build

Guides on installing a C++ compiler (like GCC, Clang, MSVC), choosing an Integrated Development Environment (IDE) or text editor, and understanding the compilation process (preprocessing, compilation, assembly, linking).

#### Compilers #Level3 #Tools #GCC #Clang #MSVC

Details on popular C++ compilers.

#### IDEs and Editors #Level3 #Tools #VSCode #CLion #Vim #Emacs

Information on Integrated Development Environments and text editors suitable for C++ development.

#### Build Systems #Level3 #Tools #Make #CMake #Ninja #Meson

Introduction to build automation tools used in C++ projects.

### Basic Syntax and Structure #Level2 #Syntax #Structure #Program #EntryPoint

Explains the fundamental syntax rules, the structure of a basic C++ program, and the `main` function.

#### Comments #Level3 #Syntax #Documentation #Readability

How to write single-line (`//`) and multi-line (`/* ... */`) comments.

#### The `main` Function #Level3 #Syntax #EntryPoint #Execution

The entry point of every C++ program.

#### Preprocessor Directives #Level3 #Syntax #Preprocessing #Include #Define

Instructions for the preprocessor, like `#include` for header files and `#define` for macros.

### Variables and Data Types #Level2 #Fundamentals #Variables #Data #Types #Memory

Covers how data is stored and manipulated using variables and different data types.

#### Primitive Data Types #Level3 #Data #Types #Integer #Float #Character #Boolean

Basic built-in types like `int`, `float`, `double`, `char`, `bool`, `void`, `wchar_t`.

#### Type Modifiers #Level3 #Data #Types #Signed #Unsigned #Short #Long

Modifiers like `signed`, `unsigned`, `short`, `long` that alter primitive types.

#### Variable Declaration and Initialization #Level3 #Variables #Declaration #Initialization #Scope

How to declare variables, initialize them with values, and understand variable scope.

#### Constants #Level3 #Variables #const #constexpr #Immutability

Defining constants using `const` and `constexpr` keywords.

##### `consteval` (C++20) #Level4 #Constants #CompileTime #ImmediateFunctions #C++20

Specifies that a function *must* produce a compile-time constant value (immediate function).

##### `constinit` (C++20) #Level4 #Constants #Initialization #Static #ZeroInitialization #C++20

Asserts that a variable with static or thread storage duration is initialized statically (at compile time / before dynamic initialization).

#### Literals #Level3 #Syntax #Values #Representation

Representations of fixed values in code (e.g., `10`, `3.14f`, `'a'`, `"hello"`).

#### Type Deduction (`auto`) #Level3 #Syntax #C++11 #TypeInference

Using the `auto` keyword for automatic type deduction during variable declaration (introduced in C++11).

### Operators #Level2 #Fundamentals #Operators #Expressions #Computation

Symbols that perform operations on operands (variables and values).

#### Arithmetic Operators #Level3 #Operators #Math #Calculation

Operators like `+`, `-`, `*`, `/`, `%`.

#### Relational Operators #Level3 #Operators #Comparison #Logic #Boolean

Operators like `==`, `!=`, `>`, `<`, `>=`, `<=`.

#### Logical Operators #Level3 #Operators #Logic #Boolean #Conditions

Operators like `&&` (AND), `||` (OR), `!` (NOT).

#### Bitwise Operators #Level3 #Operators #Bits #Manipulation #LowLevel

Operators like `&`, `|`, `^`, `~`, `<<`, `>>`.

#### Assignment Operators #Level3 #Operators #Assignment #Variables

Operators like `=`, `+=`, `-=`, `*=`, `/=`, `%=`.

#### Increment/Decrement Operators #Level3 #Operators #++ #-- #Modification

Operators `++` and `--`.

#### Ternary Operator #Level3 #Operators #Conditional #Expression #Concise

The conditional operator `?:`.

#### Three-Way Comparison Operator (`<=>`) (C++20) #Level4 #Operators #Comparison #C++20 #Spaceship

The "spaceship operator" performs a three-way comparison (`<`, `==`, `>`) in one operation, returning `std::strong_ordering`, `std::weak_ordering`, or `std::partial_ordering`. Simplifies comparison code.

#### Operator Precedence and Associativity #Level3 #Operators #EvaluationOrder #Rules

Rules governing the order in which operators are evaluated in an expression.

## Control Flow #Level1 #Logic #Execution #Conditions #Loops

Structures that control the order in which statements are executed in a program.

### Conditional Statements #Level2 #ControlFlow #Conditions #DecisionMaking

Executing code blocks based on whether certain conditions are true or false.

#### `if` Statement #Level3 #Conditions #if #Basic

Executing code if a condition is true.

#### `if-else` Statement #Level3 #Conditions #if #else #Alternative

Executing one block of code if a condition is true, and another if it's false.

#### `if-else if-else` Statement #Level3 #Conditions #if #else if #else #Multiple

Handling multiple conditions sequentially.

#### `switch` Statement #Level3 #Conditions #switch #case #break #default #Multiway

Selecting one of many code blocks to execute based on the value of an expression.

#### Conditional Operator (`?:`) #Level3 #Conditions #Ternary #Concise #Expression

A shorthand for simple `if-else` statements within expressions.

### Looping Constructs #Level2 #ControlFlow #Loops #Iteration #Repetition

Repeating a block of code multiple times.

#### `for` Loop #Level3 #Loops #for #Counter #Initialization #Condition #Update

A loop typically used when the number of iterations is known beforehand.

#### Range-based `for` Loop (C++11) #Level3 #Loops #for #C++11 #Collections #Iteration

Iterating over elements in a range (like arrays, vectors, etc.) more easily. Now works with C++20 Ranges.

#### `while` Loop #Level3 #Loops #while #Condition #PreCheck

Repeating a block of code as long as a condition remains true (checked before each iteration).

#### `do-while` Loop #Level3 #Loops #do-while #Condition #PostCheck

Similar to `while`, but the condition is checked after the loop body executes at least once.

#### Loop Control Statements #Level3 #Loops #break #continue #goto #Flow #Control

Statements to alter the normal flow of loops: `break` (exit loop), `continue` (skip iteration), `goto` (unconditional jump - generally discouraged).

## Functions #Level1 #Modularity #Reusability #Abstraction #CodeOrganization

Blocks of code designed to perform a specific task, promoting modularity and reusability.

### Function Definition and Declaration #Level2 #Functions #Syntax #Signature #Prototype

Defining the structure and implementation of a function, and declaring its signature (prototype) before use.

#### Function Signature #Level3 #Functions #ReturnType #Name #Parameters

The function's name, return type, and parameter list.

#### Function Body #Level3 #Functions #Implementation #Logic #Statements

The block of code containing the statements that the function executes.

#### Function Declaration (Prototype) #Level3 #Functions #ForwardDeclaration #HeaderFiles

Declaring a function's signature without defining its body, often used in header files. Less necessary when using C++20 Modules.

### Function Call and Return Values #Level2 #Functions #Execution #ReturnValue #Flow

How to invoke a function and how functions return results to the caller.

#### Calling Functions #Level3 #Functions #Invocation #Arguments

Passing control and potentially arguments to a function.

#### Return Statement #Level3 #Functions #return #Output #Result

Using the `return` keyword to send a value back from the function.

#### `void` Return Type #Level3 #Functions #NoReturnValue #Procedures

Functions that do not return a value.

### Function Parameters and Arguments #Level2 #Functions #Input #DataPassing #Scope

Passing data into functions.

#### Pass by Value #Level3 #Functions #Parameters #Copying #Isolation

Passing a copy of the argument's value to the function parameter. Changes inside the function do not affect the original argument.

#### Pass by Reference #Level3 #Functions #Parameters #Aliasing #Modification #Efficiency

Passing a reference (alias) to the original argument. Changes inside the function affect the original argument. Uses `&`.

#### Pass by Pointer #Level3 #Functions #Parameters #Address #Memory #Modification #Legacy

Passing the memory address of the argument. Allows modification of the original argument via dereferencing (`*`). Often used in C-style programming.

#### Default Arguments #Level3 #Functions #Parameters #Optional #Flexibility #Overloading

Providing default values for parameters, making them optional during function calls.

#### Constant Parameters #Level3 #Functions #Parameters #const #Immutability #Safety

Using `const` to prevent modification of parameters passed by reference or pointer.

### Function Overloading #Level2 #Functions #Polymorphism #Signatures #Flexibility

Defining multiple functions with the same name but different parameter lists (number or types of parameters).

### Recursion #Level2 #Functions #Algorithms #SelfCall #BaseCase

Functions that call themselves, requiring a base case to stop the recursion.

### Inline Functions #Level2 #Functions #Performance #Optimization #inline #Hint

Requesting the compiler to replace the function call with the function's body to potentially reduce overhead (compiler hint, not a guarantee).

### Lambda Expressions (C++11) #Level2 #Functions #C++11 #Anonymous #Closures #Functional

Creating anonymous function objects (closures) inline, often used with algorithms and callbacks. C++20 added template parameter lists for generic lambdas and simplified captures.

#### Syntax and Capture Clauses #Level3 #Lambda #Syntax #Capture #[] #() #{}

Understanding the structure `[capture](parameters) <template> -> return_type { body }` and how variables are captured from the surrounding scope (`[]`, `[&]`, `[=]`, `[this]`). C++20 allows `[=, this]`.

### Function Pointers #Level2 #Functions #Pointers #Callbacks #DynamicBehavior

Variables that store the memory address of a function, allowing functions to be passed as arguments or assigned dynamically.

### `main` Function Arguments #Level2 #Functions #EntryPoint #CommandLine #argc #argv

Accessing command-line arguments passed to the program via `int argc` and `char* argv[]`.

## Data Structures #Level1 #DataOrganization #Storage #Management #Collections

Ways to organize and store data efficiently.

### Arrays #Level2 #DataStructures #Collection #FixedSize #ContiguousMemory

Fixed-size sequences of elements of the same type stored in contiguous memory locations.

#### One-Dimensional Arrays #Level3 #Arrays #Linear #Sequence #Indexing

Basic arrays accessed with a single index.

#### Multi-Dimensional Arrays #Level3 #Arrays #Matrix #Table #Grids #Indexing

Arrays of arrays, often used to represent tables or grids. C++23 adds `std::mdspan`.

#### Arrays and Pointers #Level3 #Arrays #Pointers #Memory #Decay #AddressArithmetic

The close relationship between array names and pointers, array decay, and pointer arithmetic.

#### C-style Strings (`char` arrays) #Level3 #Arrays #Strings #CStyle #NullTerminated #cstring

Representing strings as null-terminated arrays of characters.

### Pointers #Level2 #Memory #Address #Dereference #DynamicMemory #Indirection

Variables that store memory addresses of other variables.

#### Declaring and Initializing Pointers #Level3 #Pointers #Syntax #* #& #nullptr

Syntax for pointer declaration (`*`), getting addresses (`&`), and null pointers (`nullptr` in C++11).

#### Dereferencing Pointers #Level3 #Pointers #* #AccessingValue #Indirection

Accessing the value stored at the memory address pointed to by a pointer using the dereference operator (`*`).

#### Pointer Arithmetic #Level3 #Pointers #Memory #Navigation #Offsets

Performing arithmetic operations (addition, subtraction) on pointers to navigate memory, typically within arrays.

#### Pointers and Arrays #Level3 #Pointers #Arrays #Equivalence #Decay

Revisiting the relationship, how array names often decay to pointers.

#### Pointers to Pointers #Level3 #Pointers #Indirection #DoublePointer #DynamicArrays

Pointers that store the address of another pointer.

#### `void` Pointers #Level3 #Pointers #Generic #TypeAgnostic #Casting

Generic pointers that can point to any data type but must be cast before dereferencing.

#### Function Pointers #Level3 #Pointers #Functions #Callbacks #DynamicDispatch

Pointers that store the address of functions. (Covered also under Functions).

#### Smart Pointers (C++11) #Level3 #Pointers #RAII #MemoryManagement #unique_ptr #shared_ptr #weak_ptr

Wrapper classes that manage the lifetime of dynamically allocated memory, preventing memory leaks (`std::unique_ptr`, `std::shared_ptr`, `std::weak_ptr`). (See Memory Management and STL).

### References #Level2 #Memory #Aliasing #PassByReference #Simplicity #Safety

Aliases or alternative names for existing variables.

#### Declaring and Initializing References #Level3 #References #Syntax #& #Aliasing #Binding

Syntax for reference declaration (`&`). References must be initialized upon declaration and cannot be rebound.

#### References vs. Pointers #Level3 #References #Pointers #Comparison #Differences #UseCases

Key differences in syntax, nullability, reassignability, and typical use cases.

#### References as Function Parameters #Level3 #References #Functions #PassByReference #Efficiency #Modification

Using references for efficient pass-by-reference semantics.

#### References as Return Values #Level3 #References #Functions #ReturnValue #Aliasing #Caution

Returning references from functions (requires careful lifetime management).

### Structures (`struct`) #Level2 #DataStructures #Aggregation #Records #Composition

User-defined composite data types that group variables (members) of different data types under a single name. By default, members are public. C++20 allows designated initializers.

#### Defining Structs #Level3 #Structs #Syntax #Members #DataGrouping

How to define a structure using the `struct` keyword.

#### Accessing Members #Level3 #Structs #DotOperator #. #ArrowOperator #->

Using the dot operator (`.`) for struct variables and the arrow operator (`->`) for pointers to structs.

#### Structs and Functions #Level3 #Structs #Functions #Parameters #ReturnValues

Passing structs to functions and returning them.

#### Structs vs. Classes #Level3 #Structs #Classes #OOP #Comparison #DefaultAccess

Key difference is default member access (public for `struct`, private for `class`). Structs often used for plain data aggregation.

### Unions #Level2 #DataStructures #MemoryOptimization #OverlappingStorage #SpaceSaving

Special data structures that allow storing different data types in the same memory location (only one member is active at a time). Used for memory saving but requires careful handling.

### Enumerations (`enum`) #Level2 #DataStructures #Constants #NamedValues #TypeSafety #Readability

User-defined types consisting of a set of named integer constants (enumerators). C++20 adds `using enum`.

#### Unscoped Enumerations (`enum`) #Level3 #Enums #CStyle #IntegerConstants #NameClash

Traditional C-style enums where enumerators are in the surrounding scope.

#### Scoped Enumerations (`enum class`/`enum struct`) (C++11) #Level3 #Enums #C++11 #TypeSafety #Scoping #StrongTyping

Strongly-typed enums where enumerators are scoped within the enum name, preventing name clashes and implicit conversions to int.

## Object-Oriented Programming (OOP) #Level1 #OOP #Abstraction #Encapsulation #Inheritance #Polymorphism

A programming paradigm based on the concept of "objects", which can contain data (attributes) and code (methods).

### Classes #Level2 #OOP #Blueprints #Objects #Encapsulation #DataHiding

User-defined blueprints for creating objects. Encapsulate data and functions that operate on that data. Default member access is private. C++20 allows designated initializers for aggregates including classes under certain conditions.

#### Defining Classes #Level3 #Classes #Syntax #class #Members #Methods

Using the `class` keyword, defining member variables (attributes) and member functions (methods).

#### Access Specifiers (`public`, `private`, `protected`) #Level3 #Classes #Encapsulation #AccessControl #DataHiding

Keywords controlling the visibility and accessibility of class members. `public` (accessible anywhere), `private` (accessible only within the class), `protected` (accessible within the class and derived classes).

#### Member Functions (Methods) #Level3 #Classes #Methods #Behavior #Operations

Functions defined within a class that operate on the object's data.

#### Objects #Level3 #Classes #Instances #State #Behavior

Instances of a class, created based on the class blueprint. Each object has its own state (values of member variables).

#### Constructors #Level3 #Classes #Initialization #ObjectCreation #Default #Copy #Move

Special member functions called automatically when an object is created, used for initialization. Includes default, parameterized, copy, and move constructors (C++11).

#### Destructors #Level3 #Classes #Cleanup #ResourceManagement #~ #RAII

Special member functions called automatically when an object is destroyed, used for cleanup (e.g., releasing resources). Uses the tilde (`~`) prefix.

#### `this` Pointer #Level3 #Classes #Pointers #ObjectContext #SelfReference

A pointer implicitly available inside non-static member functions, pointing to the object itself. C++23 adds explicit `this` parameter.

#### `static` Members #Level3 #Classes #static #ClassScope #SharedData #SharedMethods

Members (variables or functions) that belong to the class itself, not to individual objects. Shared across all objects of the class.

#### `friend` Functions and Classes #Level3 #Classes #friend #EncapsulationBreaking #AccessGranting

Functions or classes declared as `friend` can access the private and protected members of the class they are friends with. Use with caution.

### Encapsulation #Level2 #OOP #DataHiding #InformationHiding #AccessControl #Bundling

Bundling data (attributes) and methods that operate on the data within a single unit (class), and restricting direct access to some components (usually data members) using access specifiers.

### Inheritance #Level2 #OOP #Reusability #IsA #Relationship #Hierarchy #CodeSharing

Mechanism where a new class (derived/child class) inherits properties (attributes and methods) from an existing class (base/parent class). Promotes code reuse and establishes an "is-a" relationship.

#### Base and Derived Classes #Level3 #Inheritance #Parent #Child #Superclass #Subclass

Defining parent (base) and child (derived) classes using the `:` syntax.

#### Types of Inheritance #Level3 #Inheritance #Single #Multiple #Multilevel #Hierarchical #Hybrid

Different patterns of inheritance: single (one base class), multiple (several base classes), multilevel (chain), hierarchical (one base, multiple derived), hybrid (combination).

#### Access Control and Inheritance #Level3 #Inheritance #public #protected #private #Visibility

How access specifiers (`public`, `protected`, `private`) in the base class and the inheritance type affect the accessibility of inherited members in the derived class.

#### Overriding Member Functions #Level3 #Inheritance #Polymorphism #VirtualFunctions #DynamicDispatch

Redefining a base class method in a derived class with the same signature. Often used with virtual functions for polymorphism.

#### Virtual Functions and Polymorphism #Level3 #Inheritance #Polymorphism #virtual #DynamicBinding #Runtime

Using the `virtual` keyword to enable dynamic dispatch (runtime polymorphism), allowing objects of derived classes to be treated as objects of the base class. C++20 adds `virtual` support for `operator<=>`.

#### Abstract Classes and Pure Virtual Functions #Level3 #Inheritance #Abstraction #Interface #virtual #= #0

Classes with one or more pure virtual functions (`virtual ... = 0;`). Cannot be instantiated directly and serve as interfaces or base classes for polymorphism.

#### Virtual Destructors #Level3 #Inheritance #Destructors #MemoryManagement #Polymorphism

Ensuring the correct destructor (base or derived) is called when deleting an object through a base class pointer. Essential for polymorphic hierarchies.

#### The Diamond Problem #Level3 #Inheritance #MultipleInheritance #Ambiguity #virtual #Inheritance

An ambiguity that arises in multiple inheritance when a class inherits from two classes that have a common base class. Solved using virtual inheritance.

### Polymorphism #Level2 #OOP #ManyForms #Flexibility #DynamicBehavior #Interfaces

The ability of objects to take on many forms. Allows treating objects of different classes in a uniform way, typically through a common base class or interface.

#### Compile-Time Polymorphism (Static) #Level3 #Polymorphism #StaticBinding #EarlyBinding #Overloading #Templates #Concepts

Achieved through function overloading, operator overloading, and templates (further refined by C++20 Concepts). Resolved at compile time.

#### Run-Time Polymorphism (Dynamic) #Level3 #Polymorphism #DynamicBinding #LateBinding #VirtualFunctions #Overriding

Achieved through virtual functions and inheritance. Resolved at run time.

### Operator Overloading #Level2 #OOP #SyntaxSugar #CustomTypes #Readability #Convenience

Defining custom behavior for standard operators (like `+`, `-`, `*`, `<<`, `>>`, `[]`, C++20 `<=>`) when used with objects of a user-defined class.

#### Syntax and Rules #Level3 #OperatorOverloading #operator #Keyword #Member #NonMember #friend

How to declare operator functions (as member functions or non-member/friend functions). Rules and limitations. Includes `operator<=>` in C++20.

#### Common Operators to Overload #Level3 #OperatorOverloading #Arithmetic #Comparison #IO #Assignment #Subscript #Spaceship

Examples like arithmetic operators, comparison operators (including `<=>`), stream insertion/extraction (`<<`, `>>`), assignment (`=`), subscript (`[]`).

## Memory Management #Level1 #Memory #Allocation #Deallocation #Pointers #RAII #Lifetime

Techniques for managing memory allocation and deallocation during program execution.

### Stack vs. Heap Memory #Level2 #Memory #Allocation #Lifetime #Scope #Performance

Understanding the two primary memory regions. Stack (automatic, fast, limited size, LIFO) for local variables and function calls. Heap (dynamic, slower, larger size, manual/smart pointer management) for objects with longer lifetimes.

#### Stack Allocation #Level3 #Memory #Automatic #LocalVariables #FunctionCalls #Scope

Memory managed automatically by the compiler. Variables allocated on the stack are destroyed when they go out of scope.

#### Heap Allocation (`new`, `delete`) #Level3 #Memory #Dynamic #Pointers #new #delete #ManualControl

Manually allocating memory on the heap using `new` and deallocating it using `delete`. Requires careful management to avoid leaks or dangling pointers. C++20 adds `new` expressions that can handle arrays likely to allocate too much memory.

##### `new` Operator #Level4 #Heap #Allocation #Constructor

Allocates memory and calls the constructor.

##### `delete` Operator #Level4 #Heap #Deallocation #Destructor #SingleObject

Calls the destructor and deallocates memory for a single object.

##### `new[]` Operator #Level4 #Heap #Allocation #Array #Constructor

Allocates memory for an array of objects and calls constructors.

##### `delete[]` Operator #Level4 #Heap #Deallocation #Array #Destructor

Calls destructors and deallocates memory for an array of objects. Must match `new[]`.

### Memory Leaks #Level2 #Memory #Errors #Bugs #ResourceManagement #delete

Occur when heap-allocated memory is no longer needed but not deallocated using `delete` or `delete[]`, leading to resource exhaustion. Smart pointers largely prevent this.

### Dangling Pointers #Level2 #Memory #Errors #Bugs #delete #nullptr

Pointers that point to memory locations that have already been deallocated or are no longer valid. Accessing them leads to undefined behavior. Smart pointers largely prevent this.

### Resource Acquisition Is Initialization (RAII) #Level2 #Memory #Idioms #Safety #ExceptionSafety #Destructors #SmartPointers

A core C++ idiom where resource lifetime (like memory, file handles, locks) is tied to the lifetime of an object with automatic storage duration (stack object or class member). Resources are acquired in the constructor and released in the destructor, ensuring cleanup even in the presence of exceptions.

### Smart Pointers (C++11 and later) #Level2 #Memory #RAII #Safety #ModernCpp #C++11 #unique_ptr #shared_ptr #weak_ptr

Classes that wrap raw pointers to manage the lifetime of heap-allocated objects automatically, leveraging RAII. Greatly reduces the risk of memory leaks and dangling pointers. C++20 adds `make_shared` support for arrays and improves atomic operations for `shared_ptr`.

#### `std::unique_ptr` #Level3 #SmartPointers #ExclusiveOwnership #MoveSemantics #Lightweight

Represents exclusive ownership of a resource. The resource is automatically deleted when the `unique_ptr` goes out of scope. Cannot be copied, only moved.

#### `std::shared_ptr` #Level3 #SmartPointers #SharedOwnership #ReferenceCounting #ThreadSafety

Allows multiple `shared_ptr` instances to co-own a resource. Uses reference counting to determine when the resource can be safely deleted (when the last `shared_ptr` is destroyed). C++20 adds atomic refcount operations and array support for `make_shared`.

#### `std::weak_ptr` #Level3 #SmartPointers #NonOwning #Cycles #Observation #shared_ptr

A non-owning pointer that observes a resource managed by `shared_ptr`(s). Used to break circular references between `shared_ptr` instances.

#### `std::make_unique` and `std::make_shared` #Level3 #SmartPointers #FactoryFunctions #ExceptionSafety #Performance

Helper functions (C++14 for `make_unique`) to create `unique_ptr` and `shared_ptr` instances safely and potentially more efficiently. C++20 adds array support to `make_shared`.

## Standard Template Library (STL) #Level1 #Library #Generics #Containers #Algorithms #Iterators #Utilities

A powerful library of generic components providing common data structures and algorithms.

### Introduction to STL #Level2 #STL #Generics #Efficiency #Reusability #Components

Overview of the STL's philosophy (generic programming) and its main components: containers, algorithms, iterators, and function objects (functors). C++20 Ranges provide a new way to interact with many STL components.

### Containers #Level2 #STL #DataStructures #Collections #Storage #Management

Classes that manage collections of objects. C++20 adds `contains` member function to associative containers and `std::span`.

#### Sequence Containers #Level3 #STL #Containers #Ordered #Linear #Access
##### `std::vector` #Level4 #Containers #DynamicArray #Contiguous #RandomAccess #AmortizedInsertion
Dynamically resizable array, contiguous memory, fast random access, efficient insertion/deletion at the end.
##### `std::deque` #Level4 #Containers #DoubleEndedQueue #NonContiguous #EfficientFrontBackInsertion
Double-ended queue, efficient insertion/deletion at both beginning and end, non-contiguous memory.
##### `std::list` #Level4 #Containers #DoublyLinkedList #NonContiguous #EfficientInsertionDeletion #SlowAccess
Doubly-linked list, efficient insertion/deletion anywhere, non-contiguous memory, slow sequential access.
##### `std::forward_list` (C++11) #Level4 #Containers #SinglyLinkedList #C++11 #MemoryEfficient #Minimalist
Singly-linked list, more memory efficient than `std::list`, minimal interface.
##### `std::array` (C++11) #Level4 #Containers #FixedSizeArray #Static #Contiguous #StackAllocated #C++11
Fixed-size array wrapper, contiguous memory, often stack-allocated, provides STL interface.
##### `std::span` (C++20) #Level4 #Containers #View #NonOwning #Contiguous #BoundsSafe #C++20
A non-owning view over a contiguous sequence of objects. Provides bounds-checked access.

#### Associative Containers #Level3 #STL #Containers #Ordered #KeyValue #Search #Lookup
##### `std::set` #Level4 #Containers #Set #UniqueKeys #Sorted #BinarySearchTree
Stores unique elements sorted by key. C++20 adds `contains()`.
##### `std::multiset` #Level4 #Containers #Set #DuplicateKeys #Sorted #BinarySearchTree
Similar to `std::set`, but allows duplicate keys. C++20 adds `contains()`.
##### `std::map` #Level4 #Containers #Map #KeyValue #UniqueKeys #Sorted #Pair #AssociativeArray
Stores key-value pairs with unique keys, sorted by key. C++20 adds `contains()`.
##### `std::multimap` #Level4 #Containers #Map #KeyValue #DuplicateKeys #Sorted #Pair #AssociativeArray
Similar to `std::map`, but allows duplicate keys. C++20 adds `contains()`.

#### Unordered Associative Containers (C++11) #Level3 #STL #Containers #Hashing #KeyValue #Search #AverageConstantTime #C++11
##### `std::unordered_set` #Level4 #Containers #HashSet #UniqueKeys #Unordered #HashTable
Stores unique keys using hashing. C++20 adds `contains()`.
##### `std::unordered_multiset` #Level4 #Containers #HashSet #DuplicateKeys #Unordered #HashTable
Allows duplicate keys using hashing. C++20 adds `contains()`.
##### `std::unordered_map` #Level4 #Containers #HashMap #KeyValue #UniqueKeys #Unordered #HashTable #AssociativeArray
Stores key-value pairs with unique keys using hashing. C++20 adds `contains()`.
##### `std::unordered_multimap` #Level4 #Containers #HashMap #KeyValue #DuplicateKeys #Unordered #HashTable #AssociativeArray
Allows duplicate key-value pairs using hashing. C++20 adds `contains()`.

#### Container Adapters #Level3 #STL #Containers #Interface #Restriction #Stack #Queue #PriorityQueue
##### `std::stack` #Level4 #Containers #LIFO #LastInFirstOut #vector #deque #list
Last-In, First-Out (LIFO) data structure. Adapts `vector`, `deque`, or `list`.
##### `std::queue` #Level4 #Containers #FIFO #FirstInFirstOut #deque #list
First-In, First-Out (FIFO) data structure. Adapts `deque` or `list`.
##### `std::priority_queue` #Level4 #Containers #Heap #OrderedExtraction #MaxHeap #MinHeap #vector #deque
Maintains elements in a specific order (usually max-heap), allowing efficient retrieval of the largest/highest-priority element. Adapts `vector` or `deque`.

### Iterators #Level2 #STL #Abstraction #Traversal #Containers #Algorithms #PointersGeneralization

Objects that provide a generic way to access elements in a container sequentially, acting like generalized pointers. They decouple algorithms from specific container implementations. C++20 Ranges offer an alternative model.

#### Iterator Categories #Level3 #Iterators #Input #Output #Forward #Bidirectional #RandomAccess #Capabilities

Classifications based on capabilities: Input (read-once, forward), Output (write-once, forward), Forward (read/write, multi-pass, forward), Bidirectional (like Forward, but can move backward), Random Access (like Bidirectional, plus constant-time jumps). C++20 Ranges use a related but distinct set of concepts.

#### Iterator Operations #Level3 #Iterators #Dereference #* #Increment #++ #Comparison #== #!= #Navigation

Common operations like accessing the element (`*`), moving to the next element (`++`), comparing iterators, etc.

#### Iterator Invalidation #Level3 #Iterators #Containers #Modification #Pointers #Safety

Rules regarding when operations on a container (like insertion or deletion) might invalidate existing iterators, potentially leading to errors if used.

#### Range-based `for` Loop and Iterators #Level3 #Iterators #C++11 #SyntaxSugar #Convenience #begin() #end()

How the range-based for loop uses `begin()` and `end()` member functions (or ADL) to get iterators implicitly. Works seamlessly with C++20 Ranges.

### Algorithms #Level2 #STL #Functions #Operations #Containers #Iterators #Generic #Reusability

Generic functions that perform common operations on sequences of elements, typically defined by iterators. C++20 Ranges library provides range-based algorithm versions.

#### Non-modifying Sequence Operations #Level3 #Algorithms #Querying #Searching #Counting #find #count #equal #search

Algorithms that inspect elements but do not change the sequence (e.g., `std::find`, `std::count`, `std::equal`, `std::for_each`, `std::search`). C++20 adds range-based versions (e.g., `std::ranges::find`).

#### Modifying Sequence Operations #Level3 #Algorithms #Transformation #Mutation #Reordering #copy #move #transform #replace #remove #reverse #sort

Algorithms that modify the elements or their order in the sequence (e.g., `std::copy`, `std::move`, `std::transform`, `std::replace`, `std::remove`, `std::reverse`, `std::fill`, `std::generate`). C++20 adds range-based versions.

#### Sorting and Related Operations #Level3 #Algorithms #Ordering #Searching #sort #stable_sort #partial_sort #binary_search #merge #lower_bound #upper_bound

Algorithms for sorting, merging, and searching within sorted or partitioned ranges (e.g., `std::sort`, `std::stable_sort`, `std::binary_search`, `std::merge`, `std::lower_bound`). C++20 adds range-based versions.

#### Numeric Algorithms #Level3 #Algorithms #Math #Calculation #accumulate #inner_product #partial_sum #iota

Algorithms for numerical computations on sequences (e.g., `std::accumulate`, `std::inner_product`, `std::iota`). Located in `<numeric>`. C++20 adds `std::midpoint`, `std::lerp`.

#### Algorithm Complexity #Level3 #Algorithms #Performance #BigO #Efficiency

Understanding the time and space complexity guarantees provided by STL algorithms.

#### Ranges Library (C++20) #Level3 #STL #Ranges #C++20 #Algorithms #Iterators #Views #Pipelines #Composition

A new model for working with sequences, using range objects instead of iterator pairs. Enables easy composition of algorithms using views and the pipe operator (`|`). Provides range-based versions of most algorithms.

### Function Objects (Functors) and Lambdas #Level2 #STL #Callables #Predicates #Comparison #Customization #Callbacks

Objects that can be called like functions (overloading `operator()`), often used to customize the behavior of STL algorithms (e.g., providing custom comparison functions for sorting). Lambda expressions provide a concise way to create these inline (enhanced in C++20).

#### Predefined Functors #Level3 #Functors #<functional> #Arithmetic #Comparison #Logical #Negators #Binders

Standard library functors for common operations (e.g., `std::plus`, `std::less`, `std::logical_not`). C++20 adds `std::bind_front`.

#### `std::function` (C++11) #Level3 #Functors #C++11 #TypeErasure #Wrapper #PolymorphicCallable

A general-purpose polymorphic function wrapper that can store, copy, and invoke any callable target (functions, lambdas, functors, function pointers).

### Utilities #Level2 #STL #Helpers #Pairs #Tuples #Time #Memory #SmartPointers #BitManipulation #Span

Miscellaneous useful components in the standard library.

#### `std::pair` #Level3 #Utilities #DataStructures #Tuple #Heterogeneous

A simple struct template holding exactly two heterogeneous elements.

#### `std::tuple` (C++11) #Level3 #Utilities #DataStructures #C++11 #Heterogeneous #FixedSize

A template holding a fixed-size collection of heterogeneous elements.

#### `<chrono>` Library (C++11) #Level3 #Utilities #Time #Duration #Clocks #TimePoints #C++11 #Calendar #Timezone

Facilities for working with time durations, time points, and clocks. C++20 added extensive calendar and time zone support.

#### `<memory>` Header #Level3 #Utilities #MemoryManagement #SmartPointers #Allocators #RAII

Includes smart pointers (`unique_ptr`, `shared_ptr`, `weak_ptr`), allocators, and other memory-related utilities. C++20 added functions like `std::construct_at`.

#### `<utility>` Header #Level3 #Utilities #pair #move #forward #swap #Helpers

Includes `std::pair`, `std::move`, `std::forward`, `std::swap`, and other basic utilities. C++20 added `std::cmp_equal`, `std::cmp_less`, etc. for safer integer comparisons.

#### `<bit>` Library (C++20) #Level3 #Utilities #BitManipulation #C++20 #Rotate #Count #Endian #Popcount

Header providing tools for bit manipulation, like counting set bits (`popcount`), finding first/last set bit, rotating bits, checking endianness, etc.

## Input/Output (I/O) #Level1 #IO #Streams #Files #Console #DataTransfer #Interaction

Mechanisms for reading data from and writing data to various sources like the console, files, and strings.

### I/O Streams #Level2 #IO #Abstraction #Buffering #Formatting #iostream

The core concept in C++ I/O, providing a consistent interface for different I/O operations using stream objects.

#### Stream Classes Hierarchy #Level3 #IO #ios_base #ios #istream #ostream #iostream #Inheritance

Understanding the inheritance hierarchy (`ios_base`, `ios`, `istream`, `ostream`, `iostream`) and their roles.

#### Standard Streams (`cin`, `cout`, `cerr`, `clog`) #Level3 #IO #Console #StandardInput #StandardOutput #StandardError #iostream

Predefined global stream objects for standard input, standard output, and standard error (unbuffered and buffered).

#### Stream Operators (`<<`, `>>`) #Level3 #IO #Insertion #Extraction #Overloading #Formatting #Convenience

The insertion (`<<`) operator for output and the extraction (`>>`) operator for input, often overloaded for user-defined types.

#### Formatted I/O #Level3 #IO #Formatting #Manipulators #Flags #Width #Precision #Fill

Controlling the appearance of output and parsing of input using manipulators (e.g., `std::endl`, `std::setw`, `std::setprecision`, `std::fixed`) and stream flags. Often superseded by C++20 `<format>`.

#### Unformatted I/O #Level3 #IO #RawData #get() #getline() #read() #write() #put() #Efficiency

Reading and writing raw bytes or characters without interpretation (e.g., `get()`, `getline()`, `read()`, `write()`, `put()`).

#### Stream State Flags #Level3 #IO #ErrorHandling #good() #bad() #fail() #eof() #StatusChecking

Checking the state of a stream (e.g., end-of-file, read/write errors) using member functions like `good()`, `fail()`, `eof()`, `bad()`.

### File I/O #Level2 #IO #Files #Persistence #Storage #fstream

Reading from and writing to files on the filesystem.

#### File Stream Classes (`ifstream`, `ofstream`, `fstream`) #Level3 #IO #Files #fstream #Input #Output #Bidirectional

Classes derived from `istream`, `ostream`, and `iostream` specifically for file operations. `ifstream` (input), `ofstream` (output), `fstream` (input/output).

#### Opening and Closing Files #Level3 #IO #Files #open() #close() #Constructor #Destructor #Modes #RAII

Opening files using constructors or the `open()` member function, specifying modes (e.g., `ios::in`, `ios::out`, `ios::app`, `ios::binary`). Files are typically closed automatically by the destructor (RAII).

#### File Modes #Level3 #IO #Files #ios::in #ios::out #ios::app #ios::binary #ios::trunc #ios::ate #Options

Flags to control how files are opened and accessed.

#### Reading and Writing Files #Level3 #IO #Files #Operators #Methods #Text #Binary

Using stream operators (`<<`, `>>`) or member functions (`read()`, `write()`, `getline()`) to transfer data.

#### File Positioning #Level3 #IO #Files #seekg() #seekp() #tellg() #tellp() #RandomAccess #Navigation

Moving the read (`seekg`, `tellg`) or write (`seekp`, `tellp`) position within a file for random access.

### String Streams #Level2 #IO #Memory #Strings #Formatting #Conversion #sstream

Performing I/O operations on strings stored in memory using stream semantics. Useful for string formatting and parsing. Often superseded by C++20 `<format>`.

#### String Stream Classes (`istringstream`, `ostringstream`, `stringstream`) #Level3 #IO #Strings #sstream #Input #Output #Bidirectional #Memory

Classes derived from `istream`, `ostream`, and `iostream` for in-memory string I/O. `istringstream` (input from string), `ostringstream` (output to string), `stringstream` (input/output).

#### Usage Scenarios #Level3 #IO #Strings #Parsing #Formatting #Conversion #DataConversion

Common uses like converting between numbers and strings, parsing formatted strings, building strings piece by piece.

### `<filesystem>` Library (C++17) #Level2 #IO #Filesystem #C++17 #Paths #Directories #Operations #Portability

A modern library for interacting with the filesystem in a portable way (querying paths, creating directories, iterating over directory contents, checking file status).

### `<format>` Library (C++20) #Level2 #IO #Formatting #C++20 #Text #PythonStyle #TypeSafe #PrintfAlternative #iostreamAlternative

A modern, type-safe, and extensible library for formatting text, inspired by Python's f-strings and C#'s formatting. Provides `std::format` as an alternative to `sprintf` and iostream formatting. C++23 adds `std::print`.

## Exception Handling #Level1 #Errors #Runtime #Robustness #ControlFlow #try #catch #throw

Mechanism for handling runtime errors or exceptional conditions in a structured way, allowing programs to recover gracefully or terminate predictably.

### Basic Concepts #Level2 #Exceptions #Errors #ControlFlow #Safety

Introduction to why exception handling is needed and the core concepts.

#### Throwing Exceptions (`throw`) #Level3 #Exceptions #Signaling #Errors #throw #Objects #Values

Using the `throw` keyword to signal that an exceptional condition has occurred. Can throw values of any type (often objects of exception classes).

#### Catching Exceptions (`try`, `catch`) #Level3 #Exceptions #Handling #Recovery #try #catch #Blocks #Types

Using `try` blocks to enclose code that might throw exceptions and `catch` blocks to handle specific types of exceptions.

#### The `catch(...)` Block #Level3 #Exceptions #CatchAll #Generic #Unhandled

A catch block that catches exceptions of any type. Often used as a last resort or for cleanup.

#### Exception Specifications (`noexcept`) #Level3 #Exceptions #Guarantees #Performance #Optimization #C++11 #noexcept

Specifying whether a function might throw exceptions (`throw(...)` - deprecated) or guarantees not to throw (`noexcept` - preferred in modern C++). `noexcept` can enable compiler optimizations.

#### `std::source_location` (C++20) #Level3 #Exceptions #Diagnostics #Debugging #SourceInfo #C++20

A utility to capture information about the source code location (file name, line number, function name) where it's evaluated, useful for logging and diagnostics without macros.

### Standard Exceptions #Level2 #Exceptions #Library #Hierarchy #<stdexcept> #<exception>

The standard exception class hierarchy defined in `<stdexcept>` and `<exception>`.

#### `std::exception` Class #Level3 #Exceptions #BaseClass #what() #Polymorphism

The base class for all standard exceptions. Provides the `what()` virtual function to get an explanatory string.

#### Common Standard Exception Classes #Level3 #Exceptions #<stdexcept> #logic_error #runtime_error #bad_alloc #bad_cast

Examples like `std::logic_error`, `std::runtime_error`, `std::invalid_argument`, `std::out_of_range`, `std::length_error`, `std::bad_alloc`, `std::bad_cast`.

### Stack Unwinding #Level2 #Exceptions #RAII #Destructors #ResourceManagement #Cleanup

The process where, when an exception is thrown, the program exits scopes sequentially, calling destructors for local objects with automatic storage duration until a matching `catch` block is found. Crucial for RAII.

### Exception Safety Guarantees #Level2 #Exceptions #Design #Robustness #Guarantees #RAII #Contracts

Designing code to behave correctly even in the presence of exceptions. Different levels of guarantee: Basic (invariants preserved, no leaks), Strong (operation has either completed successfully or state is unchanged), No-throw (operation guaranteed not to throw).

### Resource Management and Exceptions #Level2 #Exceptions #RAII #SmartPointers #Destructors #Cleanup #Safety

How RAII and smart pointers ensure resources are properly released during stack unwinding.

## Advanced Topics #Level1 #Advanced #Features #ModernCpp #Performance #Concurrency #Metaprogramming

More complex features and paradigms in C++, often introduced in later standards or used for specialized purposes.

### Templates #Level2 #Generics #Metaprogramming #CodeGeneration #Reusability #CompileTime

Allowing code (functions and classes) to operate on generic types without knowing the specific type beforehand. Code is generated by the compiler for each specific type used. Enhanced by C++20 Concepts.

#### Function Templates #Level3 #Templates #Functions #GenericAlgorithms #TypeDeduction

Creating functions that can work with different data types.

#### Class Templates #Level3 #Templates #Classes #GenericDataStructures #Containers #vector #map

Creating classes (like STL containers) that can hold or work with different data types.

#### Template Specialization #Level3 #Templates #Customization #Optimization #SpecificTypes

Providing specific implementations for a template when used with particular types.

#### Template Argument Deduction #Level3 #Templates #Compiler #Inference #auto

How the compiler determines the template arguments automatically based on function arguments or constructor arguments (CTAD improved in C++17/20).

#### Variadic Templates (C++11) #Level3 #Templates #C++11 #ParameterPacks #Recursion #sizeof... #Tuples #forward

Templates that can accept an arbitrary number of template arguments. Used extensively in modern C++ libraries (e.g., `std::tuple`, `std::function`, `std::thread` constructor).

#### Template Metaprogramming (TMP) #Level3 #Templates #Metaprogramming #CompileTime #Computation #TypeTraits #constexpr

Using templates to perform computations at compile time rather than runtime. Often involves recursion and specialization. `constexpr` functions often preferred now.

#### Concepts (C++20) #Level3 #Templates #Constraints #CompileTime #TypeChecking #Readability #C++20 #requires

A major C++20 feature allowing constraints to be placed on template parameters, improving error messages, readability, and enabling function overload resolution based on constraints (`requires` clauses and concepts).

### Move Semantics and Rvalue References (C++11) #Level2 #C++11 #Performance #Optimization #ResourceTransfer #&& #std::move #std::forward

Introduced in C++11 to allow efficient transfer of resources (like heap memory owned by objects) from temporary or expiring objects (rvalues) to other objects, avoiding expensive copies.

#### Lvalues and Rvalues #Level3 #MoveSemantics #Expressions #Identity #Address #Temporary

Understanding the distinction between lvalues (expressions that refer to objects with identity/address) and rvalues (expressions that refer to temporary/expiring values).

#### Rvalue References (`&&`) #Level3 #MoveSemantics #C++11 #Syntax #TemporaryBinding #Overloading

A new reference type that can bind to rvalues, enabling move semantics and perfect forwarding.

#### Move Constructor and Move Assignment Operator #Level3 #MoveSemantics #SpecialMemberFunctions #&& #ResourceStealing #Efficiency

Special member functions that take an rvalue reference parameter, designed to "steal" resources from the source object, leaving it in a valid but unspecified state. Implicitly `noexcept` under certain conditions in C++20.

#### `std::move` #Level3 #MoveSemantics #Casting #Rvalue #static_cast #OwnershipTransfer

A utility function (essentially a cast) that unconditionally casts its argument to an rvalue reference, signaling intent to move from it.

#### Perfect Forwarding (`std::forward`) #Level3 #MoveSemantics #Templates #RvalueReferences #ValueCategoryPreservation #&&

A technique, typically used in template functions taking forwarding references (`T&&`), to pass arguments to another function while preserving their original value category (lvalue or rvalue). Uses `std::forward`.

### Concurrency and Multithreading (C++11 and later) #Level2 #Concurrency #Parallelism #Threads #Synchronization #C++11 #<thread> #<mutex> #<atomic> #<future> #Coroutines

Support for writing programs that perform multiple tasks simultaneously. C++20 adds Coroutines, improves atomics.

#### `<thread>` Library #Level3 #Concurrency #Threads #std::thread #Creation #Joining #Detaching #jthread

Creating and managing threads of execution using `std::thread`. Includes joining (waiting for thread completion) and detaching (letting thread run independently). C++20 adds `std::jthread` which automatically joins on destruction (RAII).

#### Mutexes and Locking (`<mutex>`) #Level3 #Concurrency #Synchronization #MutualExclusion #std::mutex #std::lock_guard #std::unique_lock #Deadlocks

Primitives for protecting shared data from race conditions using mutual exclusion locks (`std::mutex`, `std::recursive_mutex`, `std::timed_mutex`). Lock guards (`std::lock_guard`, `std::unique_lock`) provide RAII-based locking. Understanding deadlocks.

#### Condition Variables (`<condition_variable>`) #Level3 #Concurrency #Synchronization #Waiting #Signaling #ProducerConsumer #std::condition_variable #notify_all_at_thread_exit

Mechanisms for threads to wait for certain conditions to become true, often used in conjunction with mutexes (`std::condition_variable`, `std::condition_variable_any`). C++20 adds `notify_all_at_thread_exit`.

#### Semaphores and Latches (C++20) #Level3 #Concurrency #Synchronization #C++20 #CountingSemaphore #BinarySemaphore #Latch #Barrier

New synchronization primitives introduced in C++20. Semaphores (`std::counting_semaphore`, `std::binary_semaphore`) for controlling access to a resource pool. Latches (`std::latch`) and Barriers (`std::barrier`) for coordinating groups of threads.

#### Atomics (`<atomic>`) #Level3 #Concurrency #LockFree #LowLevel #Performance #MemoryOrder #std::atomic #atomic_ref #wait #notify

Types and operations for atomic access to variables, suitable for low-level lock-free programming and inter-thread communication without explicit locks. C++20 adds `std::atomic_ref` (atomic operations on non-atomic objects), `wait`/`notify` operations, floating-point atomics, and `shared_ptr` atomic operations.

#### Futures and Promises (`<future>`) #Level3 #Concurrency #Asynchronous #Tasks #Results #Communication #std::async #std::promise #std::future #std::packaged_task

Mechanisms for managing asynchronous tasks and retrieving their results (`std::future`, `std::shared_future`). `std::promise` and `std::packaged_task` help set up the communication channel. `std::async` provides a high-level way to run functions asynchronously.

#### Coroutines (C++20) #Level3 #Concurrency #Asynchronous #Generators #co_await #co_yield #co_return #C++20 #Stackless

A C++20 feature providing stackless resumable functions, simplifying asynchronous programming, implementing generators, lazy sequences, and more. Uses `co_await`, `co_yield`, `co_return` keywords. Requires library support for promise types.

#### C++ Memory Model #Level3 #Concurrency #Atomics #LowLevel #Ordering #Guarantees #memory_order

Defines rules about how memory operations in one thread become visible to others, crucial for correct low-level atomic and lock-free programming. Specifies different memory orderings (`std::memory_order_relaxed`, `_acquire`, `_release`, etc.).

### Namespaces #Level2 #Organization #NameCollisions #Modularity #Scope #namespace #using

Mechanism for grouping related declarations (classes, functions, variables, templates) under a specific name to avoid naming conflicts in large projects.

#### Defining Namespaces #Level3 #Namespaces #Syntax #namespace #Scope

Using the `namespace` keyword to create a named scope.

#### Using Namespaces #Level3 #Namespaces #using #Declaration #Directive #ScopeResolution #:: #Access

Accessing members of a namespace using the scope resolution operator (`::`), `using` declarations (`using std::cout;`), or `using` directives (`using namespace std;` - often discouraged in headers). C++20 adds `using enum`.

#### Unnamed (Anonymous) Namespaces #Level3 #Namespaces #InternalLinkage #Static #FileScope

Namespaces defined without a name, giving their contents internal linkage (making them local to the current translation unit), similar to `static` at global scope in C.

### Type Casting #Level2 #TypeSystem #Conversion #Safety #Explicit #static_cast #dynamic_cast #const_cast #reinterpret_cast

Explicitly converting values from one type to another. C++ provides several casting operators for different purposes, generally safer than C-style casts.

#### `static_cast` #Level3 #Casting #CompileTime #RelatedTypes #Conversions #Pointers #void*

For conversions between related types (e.g., numeric types, pointers up/down inheritance hierarchy without runtime checks), and conversions involving `void*`. Performed at compile time where possible.

#### `dynamic_cast` #Level3 #Casting #Runtime #Polymorphism #RTTI #Inheritance #SafeDowncasting #virtual

Used for safely converting pointers or references within an inheritance hierarchy (downcasting). Requires RTTI (Run-Time Type Information) and works only with polymorphic types (classes with virtual functions). Returns `nullptr` (for pointers) or throws `std::bad_cast` (for references) on failure.

#### `const_cast` #Level3 #Casting #ConstVolatile #Modification #UndefinedBehavior #Danger

Used to add or remove `const` or `volatile` qualifiers. Modifying an object that was originally declared `const` through a `const_cast`'ed pointer leads to undefined behavior. Use with extreme caution.

#### `reinterpret_cast` #Level3 #Casting #LowLevel #BitPattern #Unsafe #NonPortable #Pointers #Integers

Lowest-level cast, performs a binary copy of the value without regard for type safety. Used for conversions between unrelated pointer types or between pointers and integers. Highly non-portable and unsafe.

#### C-style Casts (`(type)expression`) #Level3 #Casting #Legacy #Ambiguous #Unsafe #Discouraged

The older casting syntax inherited from C. Less safe because it can behave like any of the C++ casts depending on context, making intent unclear. Generally discouraged in C++.

### Run-Time Type Information (RTTI) #Level2 #Runtime #TypeIdentification #Polymorphism #typeid #dynamic_cast #Overhead

Mechanism allowing the type of an object to be determined at runtime. Enabled by default by most compilers but can be disabled. Used by `dynamic_cast` and the `typeid` operator.

#### `typeid` Operator #Level3 #RTTI #TypeInfo #Comparison #std::type_info

Returns a `std::type_info` object representing the dynamic type of an expression. Can be used for type comparison.

#### `std::type_info` Class #Level3 #RTTI #name() #hash_code() #Comparison

The class whose objects are returned by `typeid`. Provides functions like `name()` (returns implementation-defined type name) and `hash_code()`.

### Preprocessor #Level2 #Compilation #Preprocessing #Macros #ConditionalCompilation #Directives #TextManipulation #ModulesAlternative

A phase during compilation that processes source code before the actual compiler sees it. Handles directives starting with `#`. C++20 Modules offer an alternative to many preprocessor uses.

#### `#include` #Level3 #Preprocessor #HeaderFiles #CodeInclusion #Libraries #ModulesAlternative

Includes the content of another file (typically header files). Largely replaced by `import` with C++20 Modules.

#### `#define` and `#undef` #Level3 #Preprocessor #Macros #Constants #TextSubstitution #FunctionLikeMacros #Pitfalls

Defines symbolic constants or macros (text substitutions). Function-like macros can take arguments. `#undef` removes a definition. Prone to errors, often better alternatives exist (e.g., `const`, `constexpr`, `inline` functions, templates).

#### Conditional Compilation (`#ifdef`, `#ifndef`, `#if`, `#else`, `#elif`, `#endif`) #Level3 #Preprocessor #Portability #Debugging #FeatureToggles #PlatformSpecific

Allows including or excluding blocks of code based on whether macros are defined or conditions are met. Used for platform-specific code, debugging builds, header guards. Still relevant with Modules, but some uses diminish.

#### Header Guards #Level3 #Preprocessor #IncludeGuards #ifndef #define #endif #pragma #once #ModulesAlternative

A common pattern using `#ifndef`, `#define`, `#endif` (or the non-standard but widely supported `#pragma once`) to prevent multiple inclusions of the same header file within a single translation unit. Made obsolete by C++20 Modules.

#### Predefined Macros #Level3 #Preprocessor #__FILE__ #__LINE__ #__DATE__ #__TIME__ #__cplusplus #Diagnostics #Information

Macros automatically defined by the compiler providing information like the current file name, line number, compilation date/time, and C++ standard version. C++20 adds `__VA_OPT__`.

#### Modules (C++20) #Level3 #Preprocessor #Modules #Build #Performance #Headers #Encapsulation #C++20 #import #export

A major C++20 feature providing a modern alternative to header files (`#include`). Improves build times, provides stronger encapsulation, and avoids issues like macro leakage. Uses `import` and `export` keywords. Requires build system support.

## C++ Standards and Evolution #Level1 #Standards #History #Features #ModernCpp #Compatibility

The history of the C++ language standard and the major features introduced in each revision.

### C++98 / C++03 #Level2 #Standards #Legacy #Foundation #STL #Initial

The first ISO C++ standard. Established the core language features and the initial Standard Template Library (STL). C++03 was mostly a bug-fix release.

### C++11 ("Modern C++" Begins) #Level2 #Standards #ModernCpp #MajorRevision #auto #Lambda #MoveSemantics #Concurrency #SmartPointers #RangeFor #nullptr

A major revision that significantly modernized the language. Introduced `auto`, lambda expressions, rvalue references and move semantics, concurrency support (`std::thread`, `std::mutex`, etc.), smart pointers (`unique_ptr`, `shared_ptr`), range-based for loops, `nullptr`, `constexpr`, variadic templates, and much more.

### C++14 #Level2 #Standards #MinorRevision #Convenience #auto #Lambda #constexpr #make_unique

A smaller update focused on refining C++11 features. Introduced generic lambdas, `auto` return type deduction for functions, relaxed `constexpr` restrictions, `std::make_unique`.

### C++17 #Level2 #Standards #MajorRevision #Filesystem #ParallelSTL #optional #variant #any #string_view #StructuredBindings #if #constexpr

Another significant update. Introduced the `<filesystem>` library, parallel algorithms in the STL, `std::optional`, `std::variant`, `std::any`, `std::string_view`, structured bindings, `if constexpr`, inline variables, template argument deduction for class templates (CTAD).

### C++20 #Level2 #Standards #MajorRevision #Concepts #Modules #Coroutines #Ranges #SpaceshipOperator #<format> #BitManipulation #Calendar #Timezone #Atomics #jthread #span #consteval #constinit

A very large and impactful revision ("The Big Four": Concepts, Modules, Coroutines, Ranges). Also introduced the three-way comparison operator (`<=>`), `<format>` library, `<bit>` library, calendar/time zone support (`<chrono>`), `std::span`, `std::jthread`, improved atomics (`std::atomic_ref`, wait/notify), `consteval`, `constinit`, designated initializers, `using enum`, feature test macros, and many other refinements.

### C++23 #Level2 #Standards #MinorRevision #Refinements #std::expected #std::print #mdspan #import #std #DeducingThis

A more modest release focusing on improvements and additions. Key features include `std::expected` (for error handling), `std::print` (Python-like printing), `std::mdspan` (multi-dimensional array view), ability to `import std;` (if modules are supported), Deducing `this` (explicit object parameter).

### Future Standards (C++26 and beyond) #Level2 #Standards #Evolution #Proposals #StandardizationProcess #WG21

Ongoing work by the C++ Standards Committee (WG21) on future versions of the language. Discusses potential features like executors, reflection, pattern matching, contracts, linear algebra (`std::linalg`).

## Tools and Ecosystem #Level1 #Development #Workflow #Build #Debug #Profile #Libraries

The tools, libraries, and practices surrounding C++ development.

### Compilers #Level2 #Tools #GCC #Clang #MSVC #Intel #CompilerOptions #Optimization

Deep dive into specific compilers, common compiler flags (optimization levels, warning levels, standard selection - e.g., `-std=c++20`), cross-compilation. C++20 features require up-to-date compilers.

### Build Systems #Level2 #Tools #Automation #Make #CMake #Ninja #Meson #Bazel #Dependencies #ModulesSupport

Managing the compilation and linking process for projects of varying sizes. Handling dependencies. C++20 Modules require explicit support from the build system (CMake, Meson, etc. are adding support).

#### Make and Makefiles #Level3 #BuildSystems #Legacy #Automation #Rules #Dependencies

A traditional build tool based on rules and dependencies defined in Makefiles. Module support is difficult.

#### CMake #Level3 #BuildSystems #CrossPlatform #Generator #MetaBuild #Automation #WidelyUsed #ModulesSupport

A popular cross-platform meta-build system generator. Gaining robust support for C++20 Modules.

#### Other Build Systems #Level3 #BuildSystems #Ninja #Meson #Bazel #SCons #Build2 #ModulesSupport

Brief overview of other modern build systems like Ninja (focus on speed), Meson (usability, good Module support), Bazel (large scale).

### Debuggers #Level2 #Tools #Debugging #GDB #LLDB #VisualStudio #Breakpoints #Stepping #Inspection

Tools for finding and fixing errors in code. Using GDB, LLDB, or IDE-integrated debuggers. Debugging support for Coroutines is evolving.

### Profilers #Level2 #Tools #Performance #Analysis #Bottlenecks #Valgrind #Perf #VTune #Instruments

Tools for analyzing program performance (CPU usage, memory usage) to identify bottlenecks. Examples: Valgrind (Memcheck, Cachegrind), Linux `perf`, Intel VTune Profiler, Xcode Instruments.

### Static Analysis Tools #Level2 #Tools #CodeQuality #Bugs #Style #Linters #Clang-Tidy #Cppcheck #PVS-Studio #SonarQube #ConceptsCheck

Tools that analyze source code without executing it to find potential bugs, style issues, and anti-patterns. Can help enforce Concept usage and other C++20 features.

### Package Managers #Level2 #Tools #Dependencies #Libraries #Conan #Vcpkg #Hunter #Buckaroo

Tools for managing external library dependencies in C++ projects. Examples: Conan, vcpkg. Need to handle module-based dependencies if libraries adopt modules.

### Version Control Systems #Level2 #Tools #Collaboration #History #Tracking #Git #SVN #Mercurial

Systems for tracking changes to code over time and collaborating with others. Git is the de facto standard.

### Testing Frameworks #Level2 #Tools #Testing #UnitTesting #IntegrationTesting #GoogleTest #Catch2 #Doctest #Boost.Test

Libraries for writing and running automated tests (unit tests, integration tests). Examples: Google Test, Catch2, Doctest. Can leverage C++20 features in tests.

### Core Guidelines #Level2 #BestPractices #Style #Safety #ModernCpp #BjarneStroustrup #HerbSutter

A set of recommendations for writing better, safer, more maintainable modern C++ code, initiated by Bjarne Stroustrup and Herb Sutter. Updated to incorporate C++20 idioms.

### Common Libraries #Level2 #Libraries #Boost #Qt #Poco #Folly #Abseil #Networking #Graphics #Math

Overview of popular and influential third-party C++ libraries beyond the standard library (e.g., Boost, Qt for GUI, networking libraries, graphics libraries). Many are incorporating or leveraging C++20 features.

